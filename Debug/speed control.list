
speed control.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004864  080000c0  080000c0  000010c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000110  08004924  08004924  00005924  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08004a34  08004a34  00006010  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  08004a34  08004a34  00006010  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  08004a34  08004a34  00006010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08004a34  08004a34  00005a34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08004a38  08004a38  00005a38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000010  20000000  08004a3c  00006000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001cfc  20000010  08004a4c  00006010  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20001d0c  08004a4c  00006d0c  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00006010  2**0
                  CONTENTS, READONLY
 12 .debug_info   00022766  00000000  00000000  00006038  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000463e  00000000  00000000  0002879e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 0000fc48  00000000  00000000  0002cddc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001568  00000000  00000000  0003ca28  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00001724  00000000  00000000  0003df90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00016447  00000000  00000000  0003f6b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000210bd  00000000  00000000  00055afb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0008afcf  00000000  00000000  00076bb8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00101b87  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00003ce8  00000000  00000000  00101bcc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000078  00000000  00000000  001058b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	@ (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	@ (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	@ (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000010 	.word	0x20000010
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800490c 	.word	0x0800490c

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	@ (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	@ (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	@ (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			@ (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000014 	.word	0x20000014
 8000104:	0800490c 	.word	0x0800490c

08000108 <strlen>:
 8000108:	2300      	movs	r3, #0
 800010a:	5cc2      	ldrb	r2, [r0, r3]
 800010c:	3301      	adds	r3, #1
 800010e:	2a00      	cmp	r2, #0
 8000110:	d1fb      	bne.n	800010a <strlen+0x2>
 8000112:	1e58      	subs	r0, r3, #1
 8000114:	4770      	bx	lr
	...

08000118 <__gnu_thumb1_case_uqi>:
 8000118:	b402      	push	{r1}
 800011a:	4671      	mov	r1, lr
 800011c:	0849      	lsrs	r1, r1, #1
 800011e:	0049      	lsls	r1, r1, #1
 8000120:	5c09      	ldrb	r1, [r1, r0]
 8000122:	0049      	lsls	r1, r1, #1
 8000124:	448e      	add	lr, r1
 8000126:	bc02      	pop	{r1}
 8000128:	4770      	bx	lr
 800012a:	46c0      	nop			@ (mov r8, r8)

0800012c <__udivsi3>:
 800012c:	2200      	movs	r2, #0
 800012e:	0843      	lsrs	r3, r0, #1
 8000130:	428b      	cmp	r3, r1
 8000132:	d374      	bcc.n	800021e <__udivsi3+0xf2>
 8000134:	0903      	lsrs	r3, r0, #4
 8000136:	428b      	cmp	r3, r1
 8000138:	d35f      	bcc.n	80001fa <__udivsi3+0xce>
 800013a:	0a03      	lsrs	r3, r0, #8
 800013c:	428b      	cmp	r3, r1
 800013e:	d344      	bcc.n	80001ca <__udivsi3+0x9e>
 8000140:	0b03      	lsrs	r3, r0, #12
 8000142:	428b      	cmp	r3, r1
 8000144:	d328      	bcc.n	8000198 <__udivsi3+0x6c>
 8000146:	0c03      	lsrs	r3, r0, #16
 8000148:	428b      	cmp	r3, r1
 800014a:	d30d      	bcc.n	8000168 <__udivsi3+0x3c>
 800014c:	22ff      	movs	r2, #255	@ 0xff
 800014e:	0209      	lsls	r1, r1, #8
 8000150:	ba12      	rev	r2, r2
 8000152:	0c03      	lsrs	r3, r0, #16
 8000154:	428b      	cmp	r3, r1
 8000156:	d302      	bcc.n	800015e <__udivsi3+0x32>
 8000158:	1212      	asrs	r2, r2, #8
 800015a:	0209      	lsls	r1, r1, #8
 800015c:	d065      	beq.n	800022a <__udivsi3+0xfe>
 800015e:	0b03      	lsrs	r3, r0, #12
 8000160:	428b      	cmp	r3, r1
 8000162:	d319      	bcc.n	8000198 <__udivsi3+0x6c>
 8000164:	e000      	b.n	8000168 <__udivsi3+0x3c>
 8000166:	0a09      	lsrs	r1, r1, #8
 8000168:	0bc3      	lsrs	r3, r0, #15
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x46>
 800016e:	03cb      	lsls	r3, r1, #15
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0b83      	lsrs	r3, r0, #14
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x52>
 800017a:	038b      	lsls	r3, r1, #14
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0b43      	lsrs	r3, r0, #13
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x5e>
 8000186:	034b      	lsls	r3, r1, #13
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x6a>
 8000192:	030b      	lsls	r3, r1, #12
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0ac3      	lsrs	r3, r0, #11
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x76>
 800019e:	02cb      	lsls	r3, r1, #11
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	0a83      	lsrs	r3, r0, #10
 80001a6:	428b      	cmp	r3, r1
 80001a8:	d301      	bcc.n	80001ae <__udivsi3+0x82>
 80001aa:	028b      	lsls	r3, r1, #10
 80001ac:	1ac0      	subs	r0, r0, r3
 80001ae:	4152      	adcs	r2, r2
 80001b0:	0a43      	lsrs	r3, r0, #9
 80001b2:	428b      	cmp	r3, r1
 80001b4:	d301      	bcc.n	80001ba <__udivsi3+0x8e>
 80001b6:	024b      	lsls	r3, r1, #9
 80001b8:	1ac0      	subs	r0, r0, r3
 80001ba:	4152      	adcs	r2, r2
 80001bc:	0a03      	lsrs	r3, r0, #8
 80001be:	428b      	cmp	r3, r1
 80001c0:	d301      	bcc.n	80001c6 <__udivsi3+0x9a>
 80001c2:	020b      	lsls	r3, r1, #8
 80001c4:	1ac0      	subs	r0, r0, r3
 80001c6:	4152      	adcs	r2, r2
 80001c8:	d2cd      	bcs.n	8000166 <__udivsi3+0x3a>
 80001ca:	09c3      	lsrs	r3, r0, #7
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xa8>
 80001d0:	01cb      	lsls	r3, r1, #7
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	0983      	lsrs	r3, r0, #6
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xb4>
 80001dc:	018b      	lsls	r3, r1, #6
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0943      	lsrs	r3, r0, #5
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xc0>
 80001e8:	014b      	lsls	r3, r1, #5
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0903      	lsrs	r3, r0, #4
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xcc>
 80001f4:	010b      	lsls	r3, r1, #4
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	08c3      	lsrs	r3, r0, #3
 80001fc:	428b      	cmp	r3, r1
 80001fe:	d301      	bcc.n	8000204 <__udivsi3+0xd8>
 8000200:	00cb      	lsls	r3, r1, #3
 8000202:	1ac0      	subs	r0, r0, r3
 8000204:	4152      	adcs	r2, r2
 8000206:	0883      	lsrs	r3, r0, #2
 8000208:	428b      	cmp	r3, r1
 800020a:	d301      	bcc.n	8000210 <__udivsi3+0xe4>
 800020c:	008b      	lsls	r3, r1, #2
 800020e:	1ac0      	subs	r0, r0, r3
 8000210:	4152      	adcs	r2, r2
 8000212:	0843      	lsrs	r3, r0, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d301      	bcc.n	800021c <__udivsi3+0xf0>
 8000218:	004b      	lsls	r3, r1, #1
 800021a:	1ac0      	subs	r0, r0, r3
 800021c:	4152      	adcs	r2, r2
 800021e:	1a41      	subs	r1, r0, r1
 8000220:	d200      	bcs.n	8000224 <__udivsi3+0xf8>
 8000222:	4601      	mov	r1, r0
 8000224:	4152      	adcs	r2, r2
 8000226:	4610      	mov	r0, r2
 8000228:	4770      	bx	lr
 800022a:	e7ff      	b.n	800022c <__udivsi3+0x100>
 800022c:	b501      	push	{r0, lr}
 800022e:	2000      	movs	r0, #0
 8000230:	f000 f806 	bl	8000240 <__aeabi_idiv0>
 8000234:	bd02      	pop	{r1, pc}
 8000236:	46c0      	nop			@ (mov r8, r8)

08000238 <__aeabi_uidivmod>:
 8000238:	2900      	cmp	r1, #0
 800023a:	d0f7      	beq.n	800022c <__udivsi3+0x100>
 800023c:	e776      	b.n	800012c <__udivsi3>
 800023e:	4770      	bx	lr

08000240 <__aeabi_idiv0>:
 8000240:	4770      	bx	lr
 8000242:	46c0      	nop			@ (mov r8, r8)

08000244 <StartDefaultTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
 8000244:	b510      	push	{r4, lr}
  /* USER CODE BEGIN defaultTask */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8000246:	2001      	movs	r0, #1
 8000248:	f002 fe79 	bl	8002f3e <osDelay>
  for(;;)
 800024c:	e7fb      	b.n	8000246 <StartDefaultTask+0x2>
	...

08000250 <MX_FREERTOS_Init>:
void MX_FREERTOS_Init(void) {
 8000250:	b510      	push	{r4, lr}
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
 8000252:	2100      	movs	r1, #0
 8000254:	4a03      	ldr	r2, [pc, #12]	@ (8000264 <MX_FREERTOS_Init+0x14>)
 8000256:	4804      	ldr	r0, [pc, #16]	@ (8000268 <MX_FREERTOS_Init+0x18>)
 8000258:	f002 fdfd 	bl	8002e56 <osThreadNew>
 800025c:	4b03      	ldr	r3, [pc, #12]	@ (800026c <MX_FREERTOS_Init+0x1c>)
 800025e:	6018      	str	r0, [r3, #0]
}
 8000260:	bd10      	pop	{r4, pc}
 8000262:	46c0      	nop			@ (mov r8, r8)
 8000264:	08004984 	.word	0x08004984
 8000268:	08000245 	.word	0x08000245
 800026c:	2000002c 	.word	0x2000002c

08000270 <RPM_Task>:



/**********************************RPM CALUCLATIOn*******************************************/
void RPM_Task(void *pvParameters)
{
 8000270:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000272:	b08d      	sub	sp, #52	@ 0x34
    uint32_t local_pulse_count = 0;
    uint32_t last_transmit_time = osKernelGetTickCount(); // Use RTOS tick count
 8000274:	f002 fde4 	bl	8002e40 <osKernelGetTickCount>
    while (1)
    {
    	if (osKernelGetTickCount() - last_transmit_time >= 10000)
    	{   local_pulse_count=osMessageQueueGetCount(pulseQueue);
    		osMessageQueueReset(pulseQueue);
    		rpm=local_pulse_count*3;
 8000278:	2603      	movs	r6, #3
    uint32_t last_transmit_time = osKernelGetTickCount(); // Use RTOS tick count
 800027a:	0004      	movs	r4, r0
    		char tx_buffer[32];
    		char num_buffer[10];

    		// Manually build the string
    		strcpy(tx_buffer, "RPM: ");      // Copy the prefix
    		itoa(rpm, num_buffer, 10);       // Convert the number to a string (base 10)
 800027c:	250a      	movs	r5, #10
    	if (osKernelGetTickCount() - last_transmit_time >= 10000)
 800027e:	f002 fddf 	bl	8002e40 <osKernelGetTickCount>
 8000282:	4b19      	ldr	r3, [pc, #100]	@ (80002e8 <RPM_Task+0x78>)
 8000284:	1b00      	subs	r0, r0, r4
 8000286:	4298      	cmp	r0, r3
 8000288:	d929      	bls.n	80002de <RPM_Task+0x6e>
    	{   local_pulse_count=osMessageQueueGetCount(pulseQueue);
 800028a:	4f18      	ldr	r7, [pc, #96]	@ (80002ec <RPM_Task+0x7c>)
 800028c:	6838      	ldr	r0, [r7, #0]
 800028e:	f002 ff25 	bl	80030dc <osMessageQueueGetCount>
 8000292:	0004      	movs	r4, r0
    		rpm=local_pulse_count*3;
 8000294:	4374      	muls	r4, r6
    		osMessageQueueReset(pulseQueue);
 8000296:	6838      	ldr	r0, [r7, #0]
 8000298:	f002 ff24 	bl	80030e4 <osMessageQueueReset>
    		rpm=local_pulse_count*3;
 800029c:	4f14      	ldr	r7, [pc, #80]	@ (80002f0 <RPM_Task+0x80>)
    		strcpy(tx_buffer, "RPM: ");      // Copy the prefix
 800029e:	4915      	ldr	r1, [pc, #84]	@ (80002f4 <RPM_Task+0x84>)
 80002a0:	a804      	add	r0, sp, #16
    		rpm=local_pulse_count*3;
 80002a2:	603c      	str	r4, [r7, #0]
    		strcpy(tx_buffer, "RPM: ");      // Copy the prefix
 80002a4:	f004 fb20 	bl	80048e8 <strcpy>
    		itoa(rpm, num_buffer, 10);       // Convert the number to a string (base 10)
 80002a8:	002a      	movs	r2, r5
 80002aa:	a901      	add	r1, sp, #4
 80002ac:	6838      	ldr	r0, [r7, #0]
 80002ae:	f004 faa8 	bl	8004802 <itoa>
    		strcat(tx_buffer, num_buffer);   // Add the number string
 80002b2:	a901      	add	r1, sp, #4
 80002b4:	a804      	add	r0, sp, #16
 80002b6:	f004 fae5 	bl	8004884 <strcat>
    		strcat(tx_buffer, "\r\n");       // Add the newline
 80002ba:	490f      	ldr	r1, [pc, #60]	@ (80002f8 <RPM_Task+0x88>)
 80002bc:	a804      	add	r0, sp, #16
 80002be:	f004 fae1 	bl	8004884 <strcat>

    		statusUART=HAL_UART_Transmit(&huart2, (uint8_t*)tx_buffer, strlen(tx_buffer), 100);
 80002c2:	a804      	add	r0, sp, #16
 80002c4:	f7ff ff20 	bl	8000108 <strlen>
 80002c8:	2364      	movs	r3, #100	@ 0x64
 80002ca:	b282      	uxth	r2, r0
 80002cc:	a904      	add	r1, sp, #16
 80002ce:	480b      	ldr	r0, [pc, #44]	@ (80002fc <RPM_Task+0x8c>)
 80002d0:	f002 fb91 	bl	80029f6 <HAL_UART_Transmit>
 80002d4:	4b0a      	ldr	r3, [pc, #40]	@ (8000300 <RPM_Task+0x90>)
 80002d6:	7018      	strb	r0, [r3, #0]
    		last_transmit_time = osKernelGetTickCount();
 80002d8:	f002 fdb2 	bl	8002e40 <osKernelGetTickCount>
 80002dc:	0004      	movs	r4, r0

    	}



    	osDelay(10);
 80002de:	0028      	movs	r0, r5
 80002e0:	f002 fe2d 	bl	8002f3e <osDelay>
    	if (osKernelGetTickCount() - last_transmit_time >= 10000)
 80002e4:	e7cb      	b.n	800027e <RPM_Task+0xe>
 80002e6:	46c0      	nop			@ (mov r8, r8)
 80002e8:	0000270f 	.word	0x0000270f
 80002ec:	2000003c 	.word	0x2000003c
 80002f0:	20000030 	.word	0x20000030
 80002f4:	08004930 	.word	0x08004930
 80002f8:	08004936 	.word	0x08004936
 80002fc:	20000058 	.word	0x20000058
 8000300:	20000054 	.word	0x20000054

08000304 <Command_Task>:

}

/***********************UART receive*********************************************/
void Command_Task(void *pvParameters)
{
 8000304:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000306:	b08b      	sub	sp, #44	@ 0x2c
    osStatus_t queue_status;

	while(1)
	{
        // Wait forever for the first character of a message to arrive
        queue_status = osMessageQueueGet(commandQueue, &incoming_char, NULL, osWaitForever);
 8000308:	2301      	movs	r3, #1
 800030a:	4669      	mov	r1, sp
 800030c:	4f22      	ldr	r7, [pc, #136]	@ (8000398 <Command_Task+0x94>)
 800030e:	2200      	movs	r2, #0
 8000310:	6838      	ldr	r0, [r7, #0]
 8000312:	425b      	negs	r3, r3
 8000314:	3107      	adds	r1, #7
 8000316:	f002 feab 	bl	8003070 <osMessageQueueGet>
 800031a:	1e04      	subs	r4, r0, #0

        if (queue_status == osOK)
 800031c:	d1f4      	bne.n	8000308 <Command_Task+0x4>
        {
            // --- ACTION: A message has started, stop everything else ---

            // 1. Suspend the RPM_Task so it stops processing and printing
            osThreadSuspend(status_rpm);
 800031e:	4d1f      	ldr	r5, [pc, #124]	@ (800039c <Command_Task+0x98>)
 8000320:	6828      	ldr	r0, [r5, #0]
 8000322:	f002 fde8 	bl	8002ef6 <osThreadSuspend>

            // 2. Stop the Timer 1 input capture interrupt to stop reading the PWM
            HAL_TIM_IC_Stop_IT(&htim1, TIM_CHANNEL_1);
 8000326:	0021      	movs	r1, r4
 8000328:	481d      	ldr	r0, [pc, #116]	@ (80003a0 <Command_Task+0x9c>)
 800032a:	f001 fcf1 	bl	8001d10 <HAL_TIM_IC_Stop_IT>

            // 3. Turn on the LED to give a visual indicator
            BSP_LED_On(LED1);
 800032e:	0020      	movs	r0, r4
 8000330:	f000 fb68 	bl	8000a04 <BSP_LED_On>

            // --- Now, receive the rest of the message ---
            received_command[char_index++] = incoming_char;
 8000334:	466b      	mov	r3, sp
 8000336:	466a      	mov	r2, sp
 8000338:	79db      	ldrb	r3, [r3, #7]
 800033a:	3401      	adds	r4, #1
 800033c:	7213      	strb	r3, [r2, #8]

            // Loop to get the rest of the characters until a newline or buffer is full
            while (char_index < 31)
            {
                // Wait for a short time for the next character
                queue_status = osMessageQueueGet(commandQueue, &incoming_char, NULL, 100); // 100ms timeout
 800033e:	4669      	mov	r1, sp
 8000340:	2364      	movs	r3, #100	@ 0x64
 8000342:	2200      	movs	r2, #0
 8000344:	6838      	ldr	r0, [r7, #0]
 8000346:	3107      	adds	r1, #7
 8000348:	b2e6      	uxtb	r6, r4
 800034a:	f002 fe91 	bl	8003070 <osMessageQueueGet>

                if (queue_status == osOK)
 800034e:	2800      	cmp	r0, #0
 8000350:	d109      	bne.n	8000366 <Command_Task+0x62>
                {
                    if (incoming_char == '\n')
 8000352:	466b      	mov	r3, sp
 8000354:	79db      	ldrb	r3, [r3, #7]
 8000356:	2b0a      	cmp	r3, #10
 8000358:	d005      	beq.n	8000366 <Command_Task+0x62>
                    {
                        break; // End of message
                    }
                    received_command[char_index++] = incoming_char;
 800035a:	aa02      	add	r2, sp, #8
 800035c:	54a3      	strb	r3, [r4, r2]
            while (char_index < 31)
 800035e:	3401      	adds	r4, #1
 8000360:	2c1f      	cmp	r4, #31
 8000362:	d1ec      	bne.n	800033e <Command_Task+0x3a>
 8000364:	0026      	movs	r6, r4
                    break; // Timeout, message finished
                }
            }

            // Null-terminate the string
            received_command[char_index] = '\0';
 8000366:	466b      	mov	r3, sp
 8000368:	2208      	movs	r2, #8
 800036a:	189b      	adds	r3, r3, r2
 800036c:	2200      	movs	r2, #0

            // TODO: Add your code here to process the 'received_command' string
            HAL_UART_Transmit(&huart2, (uint8_t*)received_command, strlen(received_command), 100);
 800036e:	0018      	movs	r0, r3
            received_command[char_index] = '\0';
 8000370:	559a      	strb	r2, [r3, r6]
            HAL_UART_Transmit(&huart2, (uint8_t*)received_command, strlen(received_command), 100);
 8000372:	f7ff fec9 	bl	8000108 <strlen>
 8000376:	a902      	add	r1, sp, #8
 8000378:	b282      	uxth	r2, r0
 800037a:	2364      	movs	r3, #100	@ 0x64
 800037c:	4809      	ldr	r0, [pc, #36]	@ (80003a4 <Command_Task+0xa0>)
 800037e:	f002 fb3a 	bl	80029f6 <HAL_UART_Transmit>
            // Reset for the next message
            char_index = 0;
            BSP_LED_Off(LED1); // Turn LED off when done
 8000382:	2000      	movs	r0, #0
 8000384:	f000 fb56 	bl	8000a34 <BSP_LED_Off>

            // Optional: You could add a command like "resume" to restart the tasks
             osThreadResume(status_rpm);
 8000388:	6828      	ldr	r0, [r5, #0]
 800038a:	f002 fdc6 	bl	8002f1a <osThreadResume>
             HAL_TIM_IC_Start_IT(&htim1, TIM_CHANNEL_1);
 800038e:	2100      	movs	r1, #0
 8000390:	4803      	ldr	r0, [pc, #12]	@ (80003a0 <Command_Task+0x9c>)
 8000392:	f001 fc35 	bl	8001c00 <HAL_TIM_IC_Start_IT>
 8000396:	e7b7      	b.n	8000308 <Command_Task+0x4>
 8000398:	20000034 	.word	0x20000034
 800039c:	20000050 	.word	0x20000050
 80003a0:	20000138 	.word	0x20000138
 80003a4:	20000058 	.word	0x20000058

080003a8 <HAL_TIM_IC_CaptureCallback>:
{
 80003a8:	b507      	push	{r0, r1, r2, lr}
  if(htim->Instance==TIM1)
 80003aa:	4b0a      	ldr	r3, [pc, #40]	@ (80003d4 <HAL_TIM_IC_CaptureCallback+0x2c>)
 80003ac:	6802      	ldr	r2, [r0, #0]
 80003ae:	429a      	cmp	r2, r3
 80003b0:	d10e      	bne.n	80003d0 <HAL_TIM_IC_CaptureCallback+0x28>
        BSP_LED_Toggle(LED1);
 80003b2:	2000      	movs	r0, #0
 80003b4:	f000 fb56 	bl	8000a64 <BSP_LED_Toggle>
        uint8_t pulse_event = 1;
 80003b8:	466b      	mov	r3, sp
 80003ba:	1dd9      	adds	r1, r3, #7
 80003bc:	2301      	movs	r3, #1
 80003be:	700b      	strb	r3, [r1, #0]
        PulseQueue_Status = osMessageQueuePut (pulseQueue, &pulse_event,0U,0U);
 80003c0:	2300      	movs	r3, #0
 80003c2:	4805      	ldr	r0, [pc, #20]	@ (80003d8 <HAL_TIM_IC_CaptureCallback+0x30>)
 80003c4:	001a      	movs	r2, r3
 80003c6:	6800      	ldr	r0, [r0, #0]
 80003c8:	f002 fe1a 	bl	8003000 <osMessageQueuePut>
 80003cc:	4b03      	ldr	r3, [pc, #12]	@ (80003dc <HAL_TIM_IC_CaptureCallback+0x34>)
 80003ce:	6018      	str	r0, [r3, #0]
 }
 80003d0:	bd07      	pop	{r0, r1, r2, pc}
 80003d2:	46c0      	nop			@ (mov r8, r8)
 80003d4:	40012c00 	.word	0x40012c00
 80003d8:	2000003c 	.word	0x2000003c
 80003dc:	20000044 	.word	0x20000044

080003e0 <HAL_UART_RxCpltCallback>:
    if(huart->Instance ==USART2)
 80003e0:	4b0d      	ldr	r3, [pc, #52]	@ (8000418 <HAL_UART_RxCpltCallback+0x38>)
 80003e2:	6802      	ldr	r2, [r0, #0]
{
 80003e4:	b510      	push	{r4, lr}
    if(huart->Instance ==USART2)
 80003e6:	429a      	cmp	r2, r3
 80003e8:	d115      	bne.n	8000416 <HAL_UART_RxCpltCallback+0x36>
    	CommandQueue_Status=osMessageQueuePut(commandQueue, &rx_char, 0U, 0U);
 80003ea:	2300      	movs	r3, #0
 80003ec:	4c0b      	ldr	r4, [pc, #44]	@ (800041c <HAL_UART_RxCpltCallback+0x3c>)
 80003ee:	480c      	ldr	r0, [pc, #48]	@ (8000420 <HAL_UART_RxCpltCallback+0x40>)
 80003f0:	001a      	movs	r2, r3
 80003f2:	0021      	movs	r1, r4
 80003f4:	6800      	ldr	r0, [r0, #0]
 80003f6:	f002 fe03 	bl	8003000 <osMessageQueuePut>
 80003fa:	4b0a      	ldr	r3, [pc, #40]	@ (8000424 <HAL_UART_RxCpltCallback+0x44>)
    	HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_7);
 80003fc:	2180      	movs	r1, #128	@ 0x80
    	CommandQueue_Status=osMessageQueuePut(commandQueue, &rx_char, 0U, 0U);
 80003fe:	6018      	str	r0, [r3, #0]
    	HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_7);
 8000400:	20a0      	movs	r0, #160	@ 0xa0
 8000402:	05c0      	lsls	r0, r0, #23
 8000404:	f000 fd5e 	bl	8000ec4 <HAL_GPIO_TogglePin>
        UART_rx_status = HAL_UART_Receive_IT(&huart2, &rx_char, 1);
 8000408:	2201      	movs	r2, #1
 800040a:	0021      	movs	r1, r4
 800040c:	4806      	ldr	r0, [pc, #24]	@ (8000428 <HAL_UART_RxCpltCallback+0x48>)
 800040e:	f002 fc8f 	bl	8002d30 <HAL_UART_Receive_IT>
 8000412:	4b06      	ldr	r3, [pc, #24]	@ (800042c <HAL_UART_RxCpltCallback+0x4c>)
 8000414:	7018      	strb	r0, [r3, #0]
}
 8000416:	bd10      	pop	{r4, pc}
 8000418:	40004400 	.word	0x40004400
 800041c:	20000038 	.word	0x20000038
 8000420:	20000034 	.word	0x20000034
 8000424:	20000040 	.word	0x20000040
 8000428:	20000058 	.word	0x20000058
 800042c:	20000048 	.word	0x20000048

08000430 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000430:	b530      	push	{r4, r5, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000432:	2414      	movs	r4, #20
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_1);
 8000434:	2501      	movs	r5, #1
{
 8000436:	b08d      	sub	sp, #52	@ 0x34
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000438:	0022      	movs	r2, r4
 800043a:	2100      	movs	r1, #0
 800043c:	a807      	add	r0, sp, #28
 800043e:	f004 fa19 	bl	8004874 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000442:	0022      	movs	r2, r4
 8000444:	2100      	movs	r1, #0
 8000446:	4668      	mov	r0, sp
 8000448:	f004 fa14 	bl	8004874 <memset>
  __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_1);
 800044c:	4a0c      	ldr	r2, [pc, #48]	@ (8000480 <SystemClock_Config+0x50>)
 800044e:	3c0d      	subs	r4, #13
 8000450:	6813      	ldr	r3, [r2, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000452:	a805      	add	r0, sp, #20
  __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_1);
 8000454:	43a3      	bics	r3, r4
 8000456:	432b      	orrs	r3, r5
 8000458:	6013      	str	r3, [r2, #0]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800045a:	2380      	movs	r3, #128	@ 0x80
 800045c:	025b      	lsls	r3, r3, #9
 800045e:	9306      	str	r3, [sp, #24]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000460:	9505      	str	r5, [sp, #20]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000462:	f000 fd37 	bl	8000ed4 <HAL_RCC_OscConfig>
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8000466:	2300      	movs	r3, #0
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000468:	0029      	movs	r1, r5
 800046a:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800046c:	9400      	str	r4, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
 800046e:	9501      	str	r5, [sp, #4]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8000470:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
 8000472:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
 8000474:	9304      	str	r3, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000476:	f000 fe87 	bl	8001188 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
}
 800047a:	b00d      	add	sp, #52	@ 0x34
 800047c:	bd30      	pop	{r4, r5, pc}
 800047e:	46c0      	nop			@ (mov r8, r8)
 8000480:	40022000 	.word	0x40022000

08000484 <main>:
{
 8000484:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000486:	b0a1      	sub	sp, #132	@ 0x84
  HAL_Init();
 8000488:	f000 fb56 	bl	8000b38 <HAL_Init>
  pulseQueue = osMessageQueueNew(512, sizeof(uint8_t), NULL);
 800048c:	2080      	movs	r0, #128	@ 0x80
 800048e:	2200      	movs	r2, #0
 8000490:	2101      	movs	r1, #1
 8000492:	0080      	lsls	r0, r0, #2
 8000494:	f002 fd74 	bl	8002f80 <osMessageQueueNew>
 8000498:	4b77      	ldr	r3, [pc, #476]	@ (8000678 <main+0x1f4>)
  commandQueue = osMessageQueueNew(32, sizeof(uint8_t), NULL);
 800049a:	2200      	movs	r2, #0
 800049c:	2101      	movs	r1, #1
  pulseQueue = osMessageQueueNew(512, sizeof(uint8_t), NULL);
 800049e:	6018      	str	r0, [r3, #0]
  commandQueue = osMessageQueueNew(32, sizeof(uint8_t), NULL);
 80004a0:	2020      	movs	r0, #32
 80004a2:	f002 fd6d 	bl	8002f80 <osMessageQueueNew>
 80004a6:	4b75      	ldr	r3, [pc, #468]	@ (800067c <main+0x1f8>)
  rpm_task.cb_mem=NULL;
 80004a8:	2400      	movs	r4, #0
  commandQueue = osMessageQueueNew(32, sizeof(uint8_t), NULL);
 80004aa:	6018      	str	r0, [r3, #0]
  SystemClock_Config();
 80004ac:	f7ff ffc0 	bl	8000430 <SystemClock_Config>
  rpm_task.priority =  osPriorityNormal;
 80004b0:	2318      	movs	r3, #24
  rpm_task.stack_size=256;
 80004b2:	2280      	movs	r2, #128	@ 0x80
  rpm_task.name ="RPM_Task";
 80004b4:	4972      	ldr	r1, [pc, #456]	@ (8000680 <main+0x1fc>)
  rpm_task.stack_size=256;
 80004b6:	0052      	lsls	r2, r2, #1
  rpm_task.priority =  osPriorityNormal;
 80004b8:	9314      	str	r3, [sp, #80]	@ 0x50
  update_task.priority=  osPriorityNormal;
 80004ba:	931d      	str	r3, [sp, #116]	@ 0x74
  update_task.name="updateRPM";
 80004bc:	4b71      	ldr	r3, [pc, #452]	@ (8000684 <main+0x200>)
  rpm_task.stack_size=256;
 80004be:	9213      	str	r2, [sp, #76]	@ 0x4c
  rpm_task.name ="RPM_Task";
 80004c0:	910e      	str	r1, [sp, #56]	@ 0x38
  update_task.stack_size=256;
 80004c2:	921c      	str	r2, [sp, #112]	@ 0x70
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80004c4:	0021      	movs	r1, r4
 80004c6:	3aec      	subs	r2, #236	@ 0xec
 80004c8:	a807      	add	r0, sp, #28
  update_task.name="updateRPM";
 80004ca:	9317      	str	r3, [sp, #92]	@ 0x5c
  rpm_task.cb_mem=NULL;
 80004cc:	9410      	str	r4, [sp, #64]	@ 0x40
  rpm_task.cb_size=0;
 80004ce:	9411      	str	r4, [sp, #68]	@ 0x44
  rpm_task.stack_mem=NULL;
 80004d0:	9412      	str	r4, [sp, #72]	@ 0x48
  update_task.cb_mem=NULL;
 80004d2:	9419      	str	r4, [sp, #100]	@ 0x64
  update_task.stack_mem=NULL;
 80004d4:	941b      	str	r4, [sp, #108]	@ 0x6c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80004d6:	f004 f9cd 	bl	8004874 <memset>
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80004da:	2104      	movs	r1, #4
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80004dc:	2601      	movs	r6, #1

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 80004de:	25a0      	movs	r5, #160	@ 0xa0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80004e0:	4b69      	ldr	r3, [pc, #420]	@ (8000688 <main+0x204>)
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 80004e2:	05ed      	lsls	r5, r5, #23
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80004e4:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 80004e6:	0028      	movs	r0, r5
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80004e8:	430a      	orrs	r2, r1
 80004ea:	635a      	str	r2, [r3, #52]	@ 0x34
 80004ec:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80004ee:	270c      	movs	r7, #12
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80004f0:	400a      	ands	r2, r1
 80004f2:	9201      	str	r2, [sp, #4]
 80004f4:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80004f6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80004f8:	311c      	adds	r1, #28
 80004fa:	430a      	orrs	r2, r1
 80004fc:	635a      	str	r2, [r3, #52]	@ 0x34
 80004fe:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8000500:	400a      	ands	r2, r1
 8000502:	9202      	str	r2, [sp, #8]
 8000504:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000506:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 8000508:	3180      	adds	r1, #128	@ 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800050a:	4332      	orrs	r2, r6
 800050c:	635a      	str	r2, [r3, #52]	@ 0x34
 800050e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 8000510:	0022      	movs	r2, r4
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000512:	4033      	ands	r3, r6
 8000514:	9303      	str	r3, [sp, #12]
 8000516:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_RESET);
 8000518:	f000 fcce 	bl	8000eb8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 800051c:	2380      	movs	r3, #128	@ 0x80
 800051e:	019b      	lsls	r3, r3, #6
 8000520:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000522:	4b5a      	ldr	r3, [pc, #360]	@ (800068c <main+0x208>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000524:	a907      	add	r1, sp, #28
 8000526:	485a      	ldr	r0, [pc, #360]	@ (8000690 <main+0x20c>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000528:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800052a:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800052c:	f000 fc0a 	bl	8000d44 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA5 PA7 */
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 8000530:	23a0      	movs	r3, #160	@ 0xa0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000532:	0028      	movs	r0, r5
 8000534:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 8000536:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000538:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800053a:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800053c:	940a      	str	r4, [sp, #40]	@ 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800053e:	f000 fc01 	bl	8000d44 <HAL_GPIO_Init>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000542:	003a      	movs	r2, r7
 8000544:	0021      	movs	r1, r4
 8000546:	a804      	add	r0, sp, #16
 8000548:	f004 f994 	bl	8004874 <memset>
  TIM_IC_InitTypeDef sConfigIC = {0};
 800054c:	2210      	movs	r2, #16
 800054e:	0021      	movs	r1, r4
 8000550:	a807      	add	r0, sp, #28
 8000552:	f004 f98f 	bl	8004874 <memset>
  htim1.Instance = TIM1;
 8000556:	4d4f      	ldr	r5, [pc, #316]	@ (8000694 <main+0x210>)
 8000558:	4b4f      	ldr	r3, [pc, #316]	@ (8000698 <main+0x214>)
  if (HAL_TIM_IC_Init(&htim1) != HAL_OK)
 800055a:	0028      	movs	r0, r5
  htim1.Instance = TIM1;
 800055c:	602b      	str	r3, [r5, #0]
  htim1.Init.Period = 65535;
 800055e:	4b4f      	ldr	r3, [pc, #316]	@ (800069c <main+0x218>)
  htim1.Init.Prescaler = 0;
 8000560:	606c      	str	r4, [r5, #4]
  htim1.Init.Period = 65535;
 8000562:	60eb      	str	r3, [r5, #12]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000564:	60ac      	str	r4, [r5, #8]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000566:	612c      	str	r4, [r5, #16]
  htim1.Init.RepetitionCounter = 0;
 8000568:	616c      	str	r4, [r5, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800056a:	61ac      	str	r4, [r5, #24]
  if (HAL_TIM_IC_Init(&htim1) != HAL_OK)
 800056c:	f001 f980 	bl	8001870 <HAL_TIM_IC_Init>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000570:	a904      	add	r1, sp, #16
 8000572:	0028      	movs	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8000574:	9404      	str	r4, [sp, #16]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8000576:	9405      	str	r4, [sp, #20]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000578:	9406      	str	r4, [sp, #24]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800057a:	f001 fc15 	bl	8001da8 <HAL_TIMEx_MasterConfigSynchronization>
  if (HAL_TIM_IC_ConfigChannel(&htim1, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 800057e:	0022      	movs	r2, r4
 8000580:	a907      	add	r1, sp, #28
 8000582:	0028      	movs	r0, r5
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 8000584:	9407      	str	r4, [sp, #28]
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 8000586:	9608      	str	r6, [sp, #32]
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
 8000588:	9409      	str	r4, [sp, #36]	@ 0x24
  sConfigIC.ICFilter = 0;
 800058a:	940a      	str	r4, [sp, #40]	@ 0x28
  if (HAL_TIM_IC_ConfigChannel(&htim1, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 800058c:	f001 fa80 	bl	8001a90 <HAL_TIM_IC_ConfigChannel>
  HAL_TIM_IC_Start_IT(&htim1, TIM_CHANNEL_1);  // Start the input capture with interrupt
 8000590:	0021      	movs	r1, r4
 8000592:	0028      	movs	r0, r5
 8000594:	f001 fb34 	bl	8001c00 <HAL_TIM_IC_Start_IT>
  HAL_NVIC_SetPriority(TIM1_CC_IRQn, 5, 0);  // Set priority (you can adjust this)
 8000598:	0022      	movs	r2, r4
 800059a:	2105      	movs	r1, #5
 800059c:	200e      	movs	r0, #14
 800059e:	f000 fae9 	bl	8000b74 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
 80005a2:	200e      	movs	r0, #14
 80005a4:	f000 fb10 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80005a8:	003a      	movs	r2, r7
 80005aa:	0021      	movs	r1, r4
 80005ac:	a804      	add	r0, sp, #16
 80005ae:	f004 f961 	bl	8004874 <memset>
  TIM_OC_InitTypeDef sConfigOC = {0};
 80005b2:	221c      	movs	r2, #28
 80005b4:	0021      	movs	r1, r4
 80005b6:	a807      	add	r0, sp, #28
 80005b8:	f004 f95c 	bl	8004874 <memset>
  htim3.Instance = TIM3;
 80005bc:	4d38      	ldr	r5, [pc, #224]	@ (80006a0 <main+0x21c>)
 80005be:	4b39      	ldr	r3, [pc, #228]	@ (80006a4 <main+0x220>)
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 80005c0:	0028      	movs	r0, r5
  htim3.Instance = TIM3;
 80005c2:	602b      	str	r3, [r5, #0]
  htim3.Init.Prescaler = 47;
 80005c4:	232f      	movs	r3, #47	@ 0x2f
 80005c6:	606b      	str	r3, [r5, #4]
  htim3.Init.Period = 49;
 80005c8:	3302      	adds	r3, #2
 80005ca:	60eb      	str	r3, [r5, #12]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80005cc:	60ac      	str	r4, [r5, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80005ce:	612c      	str	r4, [r5, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80005d0:	61ac      	str	r4, [r5, #24]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 80005d2:	f001 f923 	bl	800181c <HAL_TIM_PWM_Init>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80005d6:	a904      	add	r1, sp, #16
 80005d8:	0028      	movs	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80005da:	9404      	str	r4, [sp, #16]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80005dc:	9406      	str	r4, [sp, #24]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80005de:	f001 fbe3 	bl	8001da8 <HAL_TIMEx_MasterConfigSynchronization>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80005e2:	2360      	movs	r3, #96	@ 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80005e4:	0022      	movs	r2, r4
 80005e6:	a907      	add	r1, sp, #28
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80005e8:	9307      	str	r3, [sp, #28]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80005ea:	0028      	movs	r0, r5
  sConfigOC.Pulse = 20;
 80005ec:	3b4c      	subs	r3, #76	@ 0x4c
 80005ee:	9308      	str	r3, [sp, #32]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80005f0:	9409      	str	r4, [sp, #36]	@ 0x24
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80005f2:	940b      	str	r4, [sp, #44]	@ 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80005f4:	f001 f9a2 	bl	800193c <HAL_TIM_PWM_ConfigChannel>
  HAL_TIM_MspPostInit(&htim3);
 80005f8:	0028      	movs	r0, r5
 80005fa:	f000 f8d3 	bl	80007a4 <HAL_TIM_MspPostInit>
  huart2.Instance = USART2;
 80005fe:	4d2a      	ldr	r5, [pc, #168]	@ (80006a8 <main+0x224>)
 8000600:	4b2a      	ldr	r3, [pc, #168]	@ (80006ac <main+0x228>)
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000602:	0028      	movs	r0, r5
  huart2.Instance = USART2;
 8000604:	602b      	str	r3, [r5, #0]
  huart2.Init.BaudRate = 115200;
 8000606:	23e1      	movs	r3, #225	@ 0xe1
 8000608:	025b      	lsls	r3, r3, #9
 800060a:	606b      	str	r3, [r5, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800060c:	60ac      	str	r4, [r5, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800060e:	60ec      	str	r4, [r5, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000610:	612c      	str	r4, [r5, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000612:	616f      	str	r7, [r5, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000614:	61ac      	str	r4, [r5, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000616:	61ec      	str	r4, [r5, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000618:	622c      	str	r4, [r5, #32]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800061a:	626c      	str	r4, [r5, #36]	@ 0x24
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800061c:	62ac      	str	r4, [r5, #40]	@ 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800061e:	f002 fab9 	bl	8002b94 <HAL_UART_Init>
  HAL_UART_Receive_IT(&huart2, &rx_char, 1);
 8000622:	0032      	movs	r2, r6
 8000624:	0028      	movs	r0, r5
 8000626:	4922      	ldr	r1, [pc, #136]	@ (80006b0 <main+0x22c>)
 8000628:	f002 fb82 	bl	8002d30 <HAL_UART_Receive_IT>
  HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 800062c:	0022      	movs	r2, r4
 800062e:	2105      	movs	r1, #5
 8000630:	201c      	movs	r0, #28
 8000632:	f000 fa9f 	bl	8000b74 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART2_IRQn);
 8000636:	201c      	movs	r0, #28
 8000638:	f000 fac6 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
  osKernelInitialize();
 800063c:	f002 fbc6 	bl	8002dcc <osKernelInitialize>
  MX_FREERTOS_Init();
 8000640:	f7ff fe06 	bl	8000250 <MX_FREERTOS_Init>
  BSP_LED_Init(LED_GREEN);
 8000644:	0020      	movs	r0, r4
 8000646:	f000 f99f 	bl	8000988 <BSP_LED_Init>
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 800064a:	0031      	movs	r1, r6
 800064c:	0020      	movs	r0, r4
 800064e:	f000 fa1d 	bl	8000a8c <BSP_PB_Init>
  status_rpm=osThreadNew(RPM_Task, NULL,&rpm_task);
 8000652:	0021      	movs	r1, r4
 8000654:	aa0e      	add	r2, sp, #56	@ 0x38
 8000656:	4817      	ldr	r0, [pc, #92]	@ (80006b4 <main+0x230>)
 8000658:	f002 fbfd 	bl	8002e56 <osThreadNew>
 800065c:	4b16      	ldr	r3, [pc, #88]	@ (80006b8 <main+0x234>)
  status_update=osThreadNew(Command_Task, NULL, &update_task);
 800065e:	0021      	movs	r1, r4
  status_rpm=osThreadNew(RPM_Task, NULL,&rpm_task);
 8000660:	6018      	str	r0, [r3, #0]
  status_update=osThreadNew(Command_Task, NULL, &update_task);
 8000662:	aa17      	add	r2, sp, #92	@ 0x5c
 8000664:	4815      	ldr	r0, [pc, #84]	@ (80006bc <main+0x238>)
 8000666:	f002 fbf6 	bl	8002e56 <osThreadNew>
 800066a:	4b15      	ldr	r3, [pc, #84]	@ (80006c0 <main+0x23c>)
 800066c:	6018      	str	r0, [r3, #0]
  osKernelStart();
 800066e:	f002 fbc5 	bl	8002dfc <osKernelStart>
}
 8000672:	0020      	movs	r0, r4
 8000674:	b021      	add	sp, #132	@ 0x84
 8000676:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000678:	2000003c 	.word	0x2000003c
 800067c:	20000034 	.word	0x20000034
 8000680:	08004939 	.word	0x08004939
 8000684:	08004942 	.word	0x08004942
 8000688:	40021000 	.word	0x40021000
 800068c:	10110000 	.word	0x10110000
 8000690:	50000800 	.word	0x50000800
 8000694:	20000138 	.word	0x20000138
 8000698:	40012c00 	.word	0x40012c00
 800069c:	0000ffff 	.word	0x0000ffff
 80006a0:	200000ec 	.word	0x200000ec
 80006a4:	40000400 	.word	0x40000400
 80006a8:	20000058 	.word	0x20000058
 80006ac:	40004400 	.word	0x40004400
 80006b0:	20000038 	.word	0x20000038
 80006b4:	08000271 	.word	0x08000271
 80006b8:	20000050 	.word	0x20000050
 80006bc:	08000305 	.word	0x08000305
 80006c0:	2000004c 	.word	0x2000004c

080006c4 <HAL_TIM_PeriodElapsedCallback>:
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */
  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM14)
 80006c4:	4b03      	ldr	r3, [pc, #12]	@ (80006d4 <HAL_TIM_PeriodElapsedCallback+0x10>)
 80006c6:	6802      	ldr	r2, [r0, #0]
{
 80006c8:	b510      	push	{r4, lr}
  if (htim->Instance == TIM14)
 80006ca:	429a      	cmp	r2, r3
 80006cc:	d101      	bne.n	80006d2 <HAL_TIM_PeriodElapsedCallback+0xe>
  {
    HAL_IncTick();
 80006ce:	f000 fa3f 	bl	8000b50 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */
  /* USER CODE END Callback 1 */
}
 80006d2:	bd10      	pop	{r4, pc}
 80006d4:	40002000 	.word	0x40002000

080006d8 <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                    /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80006d8:	b507      	push	{r0, r1, r2, lr}

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006da:	2101      	movs	r1, #1
 80006dc:	4b0b      	ldr	r3, [pc, #44]	@ (800070c <HAL_MspInit+0x34>)
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 80006de:	2002      	movs	r0, #2
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006e0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 80006e2:	4240      	negs	r0, r0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006e4:	430a      	orrs	r2, r1
 80006e6:	641a      	str	r2, [r3, #64]	@ 0x40
 80006e8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80006ea:	400a      	ands	r2, r1
  __HAL_RCC_PWR_CLK_ENABLE();
 80006ec:	2180      	movs	r1, #128	@ 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006ee:	9200      	str	r2, [sp, #0]
 80006f0:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80006f2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80006f4:	0549      	lsls	r1, r1, #21
 80006f6:	430a      	orrs	r2, r1
 80006f8:	63da      	str	r2, [r3, #60]	@ 0x3c
 80006fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 80006fc:	2200      	movs	r2, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 80006fe:	400b      	ands	r3, r1
 8000700:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8000702:	2103      	movs	r1, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8000704:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8000706:	f000 fa35 	bl	8000b74 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800070a:	bd07      	pop	{r0, r1, r2, pc}
 800070c:	40021000 	.word	0x40021000

08000710 <HAL_TIM_IC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param htim_ic: TIM_IC handle pointer
  * @retval None
  */
void HAL_TIM_IC_MspInit(TIM_HandleTypeDef* htim_ic)
{
 8000710:	b510      	push	{r4, lr}
 8000712:	0004      	movs	r4, r0
 8000714:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000716:	2214      	movs	r2, #20
 8000718:	2100      	movs	r1, #0
 800071a:	a803      	add	r0, sp, #12
 800071c:	f004 f8aa 	bl	8004874 <memset>
  if(htim_ic->Instance==TIM1)
 8000720:	4b14      	ldr	r3, [pc, #80]	@ (8000774 <HAL_TIM_IC_MspInit+0x64>)
 8000722:	6822      	ldr	r2, [r4, #0]
 8000724:	429a      	cmp	r2, r3
 8000726:	d123      	bne.n	8000770 <HAL_TIM_IC_MspInit+0x60>
  {
    /* USER CODE BEGIN TIM1_MspInit 0 */

    /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8000728:	2180      	movs	r1, #128	@ 0x80
 800072a:	4b13      	ldr	r3, [pc, #76]	@ (8000778 <HAL_TIM_IC_MspInit+0x68>)
 800072c:	0109      	lsls	r1, r1, #4
 800072e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_TIM1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000730:	20a0      	movs	r0, #160	@ 0xa0
    __HAL_RCC_TIM1_CLK_ENABLE();
 8000732:	430a      	orrs	r2, r1
 8000734:	641a      	str	r2, [r3, #64]	@ 0x40
 8000736:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000738:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_TIM1_CLK_ENABLE();
 800073a:	400a      	ands	r2, r1
 800073c:	9201      	str	r2, [sp, #4]
 800073e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000740:	2201      	movs	r2, #1
 8000742:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8000744:	4311      	orrs	r1, r2
 8000746:	6359      	str	r1, [r3, #52]	@ 0x34
 8000748:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800074a:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800074c:	4013      	ands	r3, r2
 800074e:	9302      	str	r3, [sp, #8]
 8000750:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000752:	2302      	movs	r3, #2
 8000754:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_TIM1;
 8000756:	3303      	adds	r3, #3
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8000758:	9203      	str	r2, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF5_TIM1;
 800075a:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800075c:	f000 faf2 	bl	8000d44 <HAL_GPIO_Init>

    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 8000760:	2200      	movs	r2, #0
 8000762:	200e      	movs	r0, #14
 8000764:	0011      	movs	r1, r2
 8000766:	f000 fa05 	bl	8000b74 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
 800076a:	200e      	movs	r0, #14
 800076c:	f000 fa2c 	bl	8000bc8 <HAL_NVIC_EnableIRQ>

    /* USER CODE END TIM1_MspInit 1 */

  }

}
 8000770:	b008      	add	sp, #32
 8000772:	bd10      	pop	{r4, pc}
 8000774:	40012c00 	.word	0x40012c00
 8000778:	40021000 	.word	0x40021000

0800077c <HAL_TIM_PWM_MspInit>:
  * @param htim_pwm: TIM_PWM handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
  if(htim_pwm->Instance==TIM3)
 800077c:	4b07      	ldr	r3, [pc, #28]	@ (800079c <HAL_TIM_PWM_MspInit+0x20>)
 800077e:	6802      	ldr	r2, [r0, #0]
{
 8000780:	b082      	sub	sp, #8
  if(htim_pwm->Instance==TIM3)
 8000782:	429a      	cmp	r2, r3
 8000784:	d108      	bne.n	8000798 <HAL_TIM_PWM_MspInit+0x1c>
  {
    /* USER CODE BEGIN TIM3_MspInit 0 */

    /* USER CODE END TIM3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 8000786:	2102      	movs	r1, #2
 8000788:	4b05      	ldr	r3, [pc, #20]	@ (80007a0 <HAL_TIM_PWM_MspInit+0x24>)
 800078a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800078c:	430a      	orrs	r2, r1
 800078e:	63da      	str	r2, [r3, #60]	@ 0x3c
 8000790:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8000792:	400b      	ands	r3, r1
 8000794:	9301      	str	r3, [sp, #4]
 8000796:	9b01      	ldr	r3, [sp, #4]

    /* USER CODE END TIM3_MspInit 1 */

  }

}
 8000798:	b002      	add	sp, #8
 800079a:	4770      	bx	lr
 800079c:	40000400 	.word	0x40000400
 80007a0:	40021000 	.word	0x40021000

080007a4 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 80007a4:	b510      	push	{r4, lr}
 80007a6:	0004      	movs	r4, r0
 80007a8:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80007aa:	2214      	movs	r2, #20
 80007ac:	2100      	movs	r1, #0
 80007ae:	a801      	add	r0, sp, #4
 80007b0:	f004 f860 	bl	8004874 <memset>
  if(htim->Instance==TIM3)
 80007b4:	4b0c      	ldr	r3, [pc, #48]	@ (80007e8 <HAL_TIM_MspPostInit+0x44>)
 80007b6:	6822      	ldr	r2, [r4, #0]
 80007b8:	429a      	cmp	r2, r3
 80007ba:	d112      	bne.n	80007e2 <HAL_TIM_MspPostInit+0x3e>
  {
    /* USER CODE BEGIN TIM3_MspPostInit 0 */

    /* USER CODE END TIM3_MspPostInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80007bc:	2301      	movs	r3, #1
 80007be:	4a0b      	ldr	r2, [pc, #44]	@ (80007ec <HAL_TIM_MspPostInit+0x48>)
    GPIO_InitStruct.Pin = GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007c0:	20a0      	movs	r0, #160	@ 0xa0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80007c2:	6b51      	ldr	r1, [r2, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007c4:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80007c6:	4319      	orrs	r1, r3
 80007c8:	6351      	str	r1, [r2, #52]	@ 0x34
 80007ca:	6b52      	ldr	r2, [r2, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007cc:	a901      	add	r1, sp, #4
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80007ce:	401a      	ands	r2, r3
 80007d0:	9200      	str	r2, [sp, #0]
 80007d2:	9a00      	ldr	r2, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 80007d4:	2240      	movs	r2, #64	@ 0x40
 80007d6:	9201      	str	r2, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80007d8:	3a3e      	subs	r2, #62	@ 0x3e
 80007da:	9202      	str	r2, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
 80007dc:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80007de:	f000 fab1 	bl	8000d44 <HAL_GPIO_Init>
    /* USER CODE BEGIN TIM3_MspPostInit 1 */

    /* USER CODE END TIM3_MspPostInit 1 */
  }

}
 80007e2:	b006      	add	sp, #24
 80007e4:	bd10      	pop	{r4, pc}
 80007e6:	46c0      	nop			@ (mov r8, r8)
 80007e8:	40000400 	.word	0x40000400
 80007ec:	40021000 	.word	0x40021000

080007f0 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80007f0:	b510      	push	{r4, lr}
 80007f2:	0004      	movs	r4, r0
 80007f4:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80007f6:	2214      	movs	r2, #20
 80007f8:	2100      	movs	r1, #0
 80007fa:	a803      	add	r0, sp, #12
 80007fc:	f004 f83a 	bl	8004874 <memset>
  if(huart->Instance==USART2)
 8000800:	4b14      	ldr	r3, [pc, #80]	@ (8000854 <HAL_UART_MspInit+0x64>)
 8000802:	6822      	ldr	r2, [r4, #0]
 8000804:	429a      	cmp	r2, r3
 8000806:	d123      	bne.n	8000850 <HAL_UART_MspInit+0x60>
  {
    /* USER CODE BEGIN USART2_MspInit 0 */

    /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000808:	2180      	movs	r1, #128	@ 0x80
 800080a:	4b13      	ldr	r3, [pc, #76]	@ (8000858 <HAL_UART_MspInit+0x68>)
 800080c:	0289      	lsls	r1, r1, #10
 800080e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000810:	20a0      	movs	r0, #160	@ 0xa0
    __HAL_RCC_USART2_CLK_ENABLE();
 8000812:	430a      	orrs	r2, r1
 8000814:	63da      	str	r2, [r3, #60]	@ 0x3c
 8000816:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000818:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_USART2_CLK_ENABLE();
 800081a:	400a      	ands	r2, r1
 800081c:	9201      	str	r2, [sp, #4]
 800081e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000820:	2201      	movs	r2, #1
 8000822:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8000824:	4311      	orrs	r1, r2
 8000826:	6359      	str	r1, [r3, #52]	@ 0x34
 8000828:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800082a:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800082c:	4013      	ands	r3, r2
 800082e:	9302      	str	r3, [sp, #8]
 8000830:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8000832:	230c      	movs	r3, #12
 8000834:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000836:	3b0a      	subs	r3, #10
 8000838:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
 800083a:	9207      	str	r2, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800083c:	f000 fa82 	bl	8000d44 <HAL_GPIO_Init>

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 8000840:	2200      	movs	r2, #0
 8000842:	201c      	movs	r0, #28
 8000844:	0011      	movs	r1, r2
 8000846:	f000 f995 	bl	8000b74 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 800084a:	201c      	movs	r0, #28
 800084c:	f000 f9bc 	bl	8000bc8 <HAL_NVIC_EnableIRQ>

    /* USER CODE END USART2_MspInit 1 */

  }

}
 8000850:	b008      	add	sp, #32
 8000852:	bd10      	pop	{r4, pc}
 8000854:	40004400 	.word	0x40004400
 8000858:	40021000 	.word	0x40021000

0800085c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800085c:	b510      	push	{r4, lr}
 800085e:	0004      	movs	r4, r0
 8000860:	b088      	sub	sp, #32
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;

  /*Configure the TIM14 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000862:	2803      	cmp	r0, #3
 8000864:	d902      	bls.n	800086c <HAL_InitTick+0x10>
     HAL_NVIC_EnableIRQ(TIM14_IRQn);
     uwTickPrio = TickPriority;
    }
  else
  {
    return HAL_ERROR;
 8000866:	2001      	movs	r0, #1
    return HAL_TIM_Base_Start_IT(&htim14);
  }

  /* Return function status */
  return HAL_ERROR;
}
 8000868:	b008      	add	sp, #32
 800086a:	bd10      	pop	{r4, pc}
     HAL_NVIC_SetPriority(TIM14_IRQn, TickPriority ,0);
 800086c:	0001      	movs	r1, r0
 800086e:	2200      	movs	r2, #0
 8000870:	2013      	movs	r0, #19
 8000872:	f000 f97f 	bl	8000b74 <HAL_NVIC_SetPriority>
     HAL_NVIC_EnableIRQ(TIM14_IRQn);
 8000876:	2013      	movs	r0, #19
 8000878:	f000 f9a6 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
  __HAL_RCC_TIM14_CLK_ENABLE();
 800087c:	2180      	movs	r1, #128	@ 0x80
     uwTickPrio = TickPriority;
 800087e:	4b13      	ldr	r3, [pc, #76]	@ (80008cc <HAL_InitTick+0x70>)
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000880:	0209      	lsls	r1, r1, #8
     uwTickPrio = TickPriority;
 8000882:	601c      	str	r4, [r3, #0]
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000884:	4b12      	ldr	r3, [pc, #72]	@ (80008d0 <HAL_InitTick+0x74>)
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000886:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000888:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800088a:	430a      	orrs	r2, r1
 800088c:	641a      	str	r2, [r3, #64]	@ 0x40
 800088e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000890:	400b      	ands	r3, r1
 8000892:	9302      	str	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000894:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000896:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000898:	f000 fd4a 	bl	8001330 <HAL_RCC_GetClockConfig>
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 800089c:	f000 fd36 	bl	800130c <HAL_RCC_GetPCLK1Freq>
  htim14.Instance = TIM14;
 80008a0:	4c0c      	ldr	r4, [pc, #48]	@ (80008d4 <HAL_InitTick+0x78>)
 80008a2:	4b0d      	ldr	r3, [pc, #52]	@ (80008d8 <HAL_InitTick+0x7c>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80008a4:	490d      	ldr	r1, [pc, #52]	@ (80008dc <HAL_InitTick+0x80>)
  htim14.Instance = TIM14;
 80008a6:	6023      	str	r3, [r4, #0]
  htim14.Init.Period = (1000000U / 1000U) - 1U;
 80008a8:	4b0d      	ldr	r3, [pc, #52]	@ (80008e0 <HAL_InitTick+0x84>)
 80008aa:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80008ac:	f7ff fc3e 	bl	800012c <__udivsi3>
  htim14.Init.ClockDivision = 0;
 80008b0:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80008b2:	3801      	subs	r0, #1
  htim14.Init.Prescaler = uwPrescalerValue;
 80008b4:	6060      	str	r0, [r4, #4]
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 80008b6:	0020      	movs	r0, r4
  htim14.Init.ClockDivision = 0;
 80008b8:	6123      	str	r3, [r4, #16]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 80008ba:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 80008bc:	f000 ff84 	bl	80017c8 <HAL_TIM_Base_Init>
 80008c0:	2800      	cmp	r0, #0
 80008c2:	d1d0      	bne.n	8000866 <HAL_InitTick+0xa>
    return HAL_TIM_Base_Start_IT(&htim14);
 80008c4:	0020      	movs	r0, r4
 80008c6:	f000 fe61 	bl	800158c <HAL_TIM_Base_Start_IT>
 80008ca:	e7cd      	b.n	8000868 <HAL_InitTick+0xc>
 80008cc:	20000008 	.word	0x20000008
 80008d0:	40021000 	.word	0x40021000
 80008d4:	20000184 	.word	0x20000184
 80008d8:	40002000 	.word	0x40002000
 80008dc:	000f4240 	.word	0x000f4240
 80008e0:	000003e7 	.word	0x000003e7

080008e4 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80008e4:	e7fe      	b.n	80008e4 <NMI_Handler>

080008e6 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80008e6:	e7fe      	b.n	80008e6 <HardFault_Handler>

080008e8 <EXTI4_15_IRQHandler>:

/**
  * @brief This function handles EXTI line 4 to 15 interrupts.
  */
void EXTI4_15_IRQHandler(void)
{
 80008e8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EXTI4_15_IRQn 0 */

  /* USER CODE END EXTI4_15_IRQn 0 */
  BSP_PB_IRQHandler(BUTTON_USER);
 80008ea:	2000      	movs	r0, #0
 80008ec:	f000 f914 	bl	8000b18 <BSP_PB_IRQHandler>
  /* USER CODE BEGIN EXTI4_15_IRQn 1 */

  /* USER CODE END EXTI4_15_IRQn 1 */
}
 80008f0:	bd10      	pop	{r4, pc}
	...

080008f4 <TIM1_CC_IRQHandler>:

/**
  * @brief This function handles TIM1 capture compare interrupt.
  */
void TIM1_CC_IRQHandler(void)
{
 80008f4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM1_CC_IRQn 0 */

  /* USER CODE END TIM1_CC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 80008f6:	4802      	ldr	r0, [pc, #8]	@ (8000900 <TIM1_CC_IRQHandler+0xc>)
 80008f8:	f000 fe78 	bl	80015ec <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_CC_IRQn 1 */

  /* USER CODE END TIM1_CC_IRQn 1 */
}
 80008fc:	bd10      	pop	{r4, pc}
 80008fe:	46c0      	nop			@ (mov r8, r8)
 8000900:	20000138 	.word	0x20000138

08000904 <TIM14_IRQHandler>:

/**
  * @brief This function handles TIM14 global interrupt.
  */
void TIM14_IRQHandler(void)
{
 8000904:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM14_IRQn 0 */

  /* USER CODE END TIM14_IRQn 0 */
  HAL_TIM_IRQHandler(&htim14);
 8000906:	4802      	ldr	r0, [pc, #8]	@ (8000910 <TIM14_IRQHandler+0xc>)
 8000908:	f000 fe70 	bl	80015ec <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM14_IRQn 1 */

  /* USER CODE END TIM14_IRQn 1 */
}
 800090c:	bd10      	pop	{r4, pc}
 800090e:	46c0      	nop			@ (mov r8, r8)
 8000910:	20000184 	.word	0x20000184

08000914 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 interrupt.
  */
void USART2_IRQHandler(void)
{
 8000914:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8000916:	4802      	ldr	r0, [pc, #8]	@ (8000920 <USART2_IRQHandler+0xc>)
 8000918:	f001 fab8 	bl	8001e8c <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 800091c:	bd10      	pop	{r4, pc}
 800091e:	46c0      	nop			@ (mov r8, r8)
 8000920:	20000058 	.word	0x20000058

08000924 <SystemInit>:
  
  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000924:	2280      	movs	r2, #128	@ 0x80
 8000926:	4b02      	ldr	r3, [pc, #8]	@ (8000930 <SystemInit+0xc>)
 8000928:	0512      	lsls	r2, r2, #20
 800092a:	609a      	str	r2, [r3, #8]
#endif
}
 800092c:	4770      	bx	lr
 800092e:	46c0      	nop			@ (mov r8, r8)
 8000930:	e000ed00 	.word	0xe000ed00

08000934 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:


  ldr   r0, =_estack
 8000934:	480d      	ldr	r0, [pc, #52]	@ (800096c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000936:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000938:	f7ff fff4 	bl	8000924 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800093c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800093e:	e003      	b.n	8000948 <LoopCopyDataInit>

08000940 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8000940:	4b0b      	ldr	r3, [pc, #44]	@ (8000970 <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8000942:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8000944:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8000946:	3104      	adds	r1, #4

08000948 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8000948:	480a      	ldr	r0, [pc, #40]	@ (8000974 <LoopForever+0xa>)
  ldr r3, =_edata
 800094a:	4b0b      	ldr	r3, [pc, #44]	@ (8000978 <LoopForever+0xe>)
  adds r2, r0, r1
 800094c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800094e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8000950:	d3f6      	bcc.n	8000940 <CopyDataInit>
  ldr r2, =_sbss
 8000952:	4a0a      	ldr	r2, [pc, #40]	@ (800097c <LoopForever+0x12>)
  b LoopFillZerobss
 8000954:	e002      	b.n	800095c <LoopFillZerobss>

08000956 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8000956:	2300      	movs	r3, #0
  str  r3, [r2]
 8000958:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800095a:	3204      	adds	r2, #4

0800095c <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800095c:	4b08      	ldr	r3, [pc, #32]	@ (8000980 <LoopForever+0x16>)
  cmp r2, r3
 800095e:	429a      	cmp	r2, r3
  bcc FillZerobss
 8000960:	d3f9      	bcc.n	8000956 <FillZerobss>


/* Call static constructors */
  bl __libc_init_array
 8000962:	f003 ff9d 	bl	80048a0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000966:	f7ff fd8d 	bl	8000484 <main>

0800096a <LoopForever>:

LoopForever:
    b LoopForever
 800096a:	e7fe      	b.n	800096a <LoopForever>
  ldr   r0, =_estack
 800096c:	20003000 	.word	0x20003000
  ldr r3, =_sidata
 8000970:	08004a3c 	.word	0x08004a3c
  ldr r0, =_sdata
 8000974:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8000978:	20000010 	.word	0x20000010
  ldr r2, =_sbss
 800097c:	20000010 	.word	0x20000010
  ldr r3, = _ebss
 8000980:	20001d0c 	.word	0x20001d0c

08000984 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000984:	e7fe      	b.n	8000984 <ADC1_IRQHandler>
	...

08000988 <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED4
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8000988:	b530      	push	{r4, r5, lr}
 800098a:	0004      	movs	r4, r0
 800098c:	b089      	sub	sp, #36	@ 0x24
  int32_t ret = BSP_ERROR_NONE;
  GPIO_InitTypeDef  gpio_init_structure;

#if defined (USE_NUCLEO_64)
  if ((Led != LED1)
 800098e:	2801      	cmp	r0, #1
 8000990:	d82c      	bhi.n	80009ec <BSP_LED_Init+0x64>
  }
  else
  {
    /* Enable the GPIO LED Clock */
#if defined (USE_NUCLEO_64)
    if (Led == LED1)
 8000992:	4b18      	ldr	r3, [pc, #96]	@ (80009f4 <BSP_LED_Init+0x6c>)
    {
      LED1_GPIO_CLK_ENABLE();
 8000994:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
    if (Led == LED1)
 8000996:	2800      	cmp	r0, #0
 8000998:	d120      	bne.n	80009dc <BSP_LED_Init+0x54>
      LED1_GPIO_CLK_ENABLE();
 800099a:	2101      	movs	r1, #1
 800099c:	430a      	orrs	r2, r1
 800099e:	635a      	str	r2, [r3, #52]	@ 0x34
 80009a0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80009a2:	400b      	ands	r3, r1
 80009a4:	9301      	str	r3, [sp, #4]
 80009a6:	9b01      	ldr	r3, [sp, #4]
      LED4_GPIO_CLK_ENABLE();
    }
#endif /* defined (USE_NUCLEO_64) */

    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin   = LED_PIN[Led];
 80009a8:	4b13      	ldr	r3, [pc, #76]	@ (80009f8 <BSP_LED_Init+0x70>)
 80009aa:	0062      	lsls	r2, r4, #1
 80009ac:	5ad5      	ldrh	r5, [r2, r3]
    gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 80009ae:	2301      	movs	r3, #1
 80009b0:	9304      	str	r3, [sp, #16]
    gpio_init_structure.Pull  = GPIO_NOPULL;
 80009b2:	2300      	movs	r3, #0
 80009b4:	9305      	str	r3, [sp, #20]
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80009b6:	3303      	adds	r3, #3
 80009b8:	9306      	str	r3, [sp, #24]

    HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 80009ba:	4b10      	ldr	r3, [pc, #64]	@ (80009fc <BSP_LED_Init+0x74>)
 80009bc:	00a2      	lsls	r2, r4, #2
 80009be:	58d0      	ldr	r0, [r2, r3]
 80009c0:	a903      	add	r1, sp, #12
    gpio_init_structure.Pin   = LED_PIN[Led];
 80009c2:	9503      	str	r5, [sp, #12]
    HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 80009c4:	f000 f9be 	bl	8000d44 <HAL_GPIO_Init>
#if defined (USE_NUCLEO_64)
    if (Led == LED2)
 80009c8:	2c01      	cmp	r4, #1
 80009ca:	d104      	bne.n	80009d6 <BSP_LED_Init+0x4e>
    {
     HAL_GPIO_WritePin(LED_PORT [Led], (uint16_t)LED_PIN[Led], GPIO_PIN_SET);
 80009cc:	0022      	movs	r2, r4
 80009ce:	0029      	movs	r1, r5
 80009d0:	480b      	ldr	r0, [pc, #44]	@ (8000a00 <BSP_LED_Init+0x78>)
 80009d2:	f000 fa71 	bl	8000eb8 <HAL_GPIO_WritePin>
  int32_t ret = BSP_ERROR_NONE;
 80009d6:	2000      	movs	r0, #0
    }
#endif
  }
  return ret;
}
 80009d8:	b009      	add	sp, #36	@ 0x24
 80009da:	bd30      	pop	{r4, r5, pc}
      LED2_GPIO_CLK_ENABLE();
 80009dc:	2104      	movs	r1, #4
 80009de:	430a      	orrs	r2, r1
 80009e0:	635a      	str	r2, [r3, #52]	@ 0x34
 80009e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80009e4:	400b      	ands	r3, r1
 80009e6:	9302      	str	r3, [sp, #8]
 80009e8:	9b02      	ldr	r3, [sp, #8]
 80009ea:	e7dd      	b.n	80009a8 <BSP_LED_Init+0x20>
    ret = BSP_ERROR_WRONG_PARAM;
 80009ec:	2002      	movs	r0, #2
 80009ee:	4240      	negs	r0, r0
  return ret;
 80009f0:	e7f2      	b.n	80009d8 <BSP_LED_Init+0x50>
 80009f2:	46c0      	nop			@ (mov r8, r8)
 80009f4:	40021000 	.word	0x40021000
 80009f8:	08004a08 	.word	0x08004a08
 80009fc:	08004a0c 	.word	0x08004a0c
 8000a00:	50000800 	.word	0x50000800

08000a04 <BSP_LED_On>:
  *     @arg  LED2
  *     @arg  LED4
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 8000a04:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;

#if defined (USE_NUCLEO_64)
  if ((Led != LED1)
 8000a06:	2801      	cmp	r0, #1
 8000a08:	d80e      	bhi.n	8000a28 <BSP_LED_On+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
#if defined (USE_NUCLEO_64)
    if (Led == LED1)
 8000a0a:	2800      	cmp	r0, #0
 8000a0c:	d107      	bne.n	8000a1e <BSP_LED_On+0x1a>
    {
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
 8000a0e:	20a0      	movs	r0, #160	@ 0xa0
 8000a10:	2201      	movs	r2, #1
 8000a12:	2120      	movs	r1, #32
 8000a14:	05c0      	lsls	r0, r0, #23
    }
    else
    {
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 8000a16:	f000 fa4f 	bl	8000eb8 <HAL_GPIO_WritePin>
  int32_t ret = BSP_ERROR_NONE;
 8000a1a:	2000      	movs	r0, #0
     HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
#endif
  }

  return ret;
}
 8000a1c:	bd10      	pop	{r4, pc}
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 8000a1e:	2180      	movs	r1, #128	@ 0x80
 8000a20:	2200      	movs	r2, #0
 8000a22:	4803      	ldr	r0, [pc, #12]	@ (8000a30 <BSP_LED_On+0x2c>)
 8000a24:	0089      	lsls	r1, r1, #2
 8000a26:	e7f6      	b.n	8000a16 <BSP_LED_On+0x12>
    ret = BSP_ERROR_WRONG_PARAM;
 8000a28:	2002      	movs	r0, #2
 8000a2a:	4240      	negs	r0, r0
  return ret;
 8000a2c:	e7f6      	b.n	8000a1c <BSP_LED_On+0x18>
 8000a2e:	46c0      	nop			@ (mov r8, r8)
 8000a30:	50000800 	.word	0x50000800

08000a34 <BSP_LED_Off>:
  *     @arg  LED2
  *     @arg  LED4
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 8000a34:	0002      	movs	r2, r0
 8000a36:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;

#if defined (USE_NUCLEO_64)
  if ((Led != LED1)
 8000a38:	2801      	cmp	r0, #1
 8000a3a:	d80d      	bhi.n	8000a58 <BSP_LED_Off+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
#if defined (USE_NUCLEO_64)
    if (Led == LED1)
 8000a3c:	2800      	cmp	r0, #0
 8000a3e:	d106      	bne.n	8000a4e <BSP_LED_Off+0x1a>
    {
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 8000a40:	20a0      	movs	r0, #160	@ 0xa0
 8000a42:	2120      	movs	r1, #32
 8000a44:	05c0      	lsls	r0, r0, #23
    }
    else
    {
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
 8000a46:	f000 fa37 	bl	8000eb8 <HAL_GPIO_WritePin>
  int32_t ret = BSP_ERROR_NONE;
 8000a4a:	2000      	movs	r0, #0
     HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
#endif
  }

  return ret;
}
 8000a4c:	bd10      	pop	{r4, pc}
      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
 8000a4e:	2180      	movs	r1, #128	@ 0x80
 8000a50:	2201      	movs	r2, #1
 8000a52:	4803      	ldr	r0, [pc, #12]	@ (8000a60 <BSP_LED_Off+0x2c>)
 8000a54:	0089      	lsls	r1, r1, #2
 8000a56:	e7f6      	b.n	8000a46 <BSP_LED_Off+0x12>
    ret = BSP_ERROR_WRONG_PARAM;
 8000a58:	2002      	movs	r0, #2
 8000a5a:	4240      	negs	r0, r0
  return ret;
 8000a5c:	e7f6      	b.n	8000a4c <BSP_LED_Off+0x18>
 8000a5e:	46c0      	nop			@ (mov r8, r8)
 8000a60:	50000800 	.word	0x50000800

08000a64 <BSP_LED_Toggle>:
  *     @arg  LED2
  *     @arg  LED4
  * @retval BSP status
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 8000a64:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;

#if defined (USE_NUCLEO_64)
  if ((Led != LED1)
 8000a66:	2801      	cmp	r0, #1
 8000a68:	d809      	bhi.n	8000a7e <BSP_LED_Toggle+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 8000a6a:	4b06      	ldr	r3, [pc, #24]	@ (8000a84 <BSP_LED_Toggle+0x20>)
 8000a6c:	0042      	lsls	r2, r0, #1
 8000a6e:	5ad1      	ldrh	r1, [r2, r3]
 8000a70:	4b05      	ldr	r3, [pc, #20]	@ (8000a88 <BSP_LED_Toggle+0x24>)
 8000a72:	0080      	lsls	r0, r0, #2
 8000a74:	58c0      	ldr	r0, [r0, r3]
 8000a76:	f000 fa25 	bl	8000ec4 <HAL_GPIO_TogglePin>
  int32_t ret = BSP_ERROR_NONE;
 8000a7a:	2000      	movs	r0, #0
  }

  return ret;
}
 8000a7c:	bd10      	pop	{r4, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 8000a7e:	2002      	movs	r0, #2
 8000a80:	4240      	negs	r0, r0
  return ret;
 8000a82:	e7fb      	b.n	8000a7c <BSP_LED_Toggle+0x18>
 8000a84:	08004a08 	.word	0x08004a08
 8000a88:	08004a0c 	.word	0x08004a0c

08000a8c <BSP_PB_Init>:
  *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
  *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                    with interrupt generation capability
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 8000a8c:	b530      	push	{r4, r5, lr}
 8000a8e:	0005      	movs	r5, r0
  static BSP_EXTI_LineCallback ButtonCallback[BUTTONn] = {BUTTON_USER_EXTI_Callback};
  static uint32_t  BSP_BUTTON_PRIO [BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] = {BUTTON_USER_EXTI_LINE};

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
 8000a90:	2004      	movs	r0, #4
 8000a92:	4b1b      	ldr	r3, [pc, #108]	@ (8000b00 <BSP_PB_Init+0x74>)
{
 8000a94:	b087      	sub	sp, #28
  BUTTON_USER_GPIO_CLK_ENABLE();
 8000a96:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8000a98:	4302      	orrs	r2, r0
 8000a9a:	635a      	str	r2, [r3, #52]	@ 0x34
 8000a9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8000a9e:	4003      	ands	r3, r0
 8000aa0:	9300      	str	r3, [sp, #0]
 8000aa2:	9b00      	ldr	r3, [sp, #0]

  gpio_init_structure.Pin = BUTTON_PIN [Button];
 8000aa4:	2380      	movs	r3, #128	@ 0x80
 8000aa6:	019b      	lsls	r3, r3, #6
 8000aa8:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
 8000aaa:	2301      	movs	r3, #1
 8000aac:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8000aae:	18db      	adds	r3, r3, r3
 8000ab0:	9304      	str	r3, [sp, #16]

  if (ButtonMode == BUTTON_MODE_GPIO)
 8000ab2:	2900      	cmp	r1, #0
 8000ab4:	d107      	bne.n	8000ac6 <BSP_PB_Init+0x3a>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 8000ab6:	9102      	str	r1, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT [Button], &gpio_init_structure);
 8000ab8:	4812      	ldr	r0, [pc, #72]	@ (8000b04 <BSP_PB_Init+0x78>)
 8000aba:	a901      	add	r1, sp, #4
 8000abc:	f000 f942 	bl	8000d44 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 8000ac0:	2000      	movs	r0, #0
 8000ac2:	b007      	add	sp, #28
 8000ac4:	bd30      	pop	{r4, r5, pc}
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
 8000ac6:	240c      	movs	r4, #12
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 8000ac8:	4b0f      	ldr	r3, [pc, #60]	@ (8000b08 <BSP_PB_Init+0x7c>)
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
 8000aca:	436c      	muls	r4, r5
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8000acc:	a901      	add	r1, sp, #4
 8000ace:	480d      	ldr	r0, [pc, #52]	@ (8000b04 <BSP_PB_Init+0x78>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 8000ad0:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8000ad2:	f000 f937 	bl	8000d44 <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
 8000ad6:	4b0d      	ldr	r3, [pc, #52]	@ (8000b0c <BSP_PB_Init+0x80>)
 8000ad8:	490d      	ldr	r1, [pc, #52]	@ (8000b10 <BSP_PB_Init+0x84>)
 8000ada:	18e4      	adds	r4, r4, r3
 8000adc:	0020      	movs	r0, r4
 8000ade:	f000 f905 	bl	8000cec <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]);
 8000ae2:	2100      	movs	r1, #0
 8000ae4:	0020      	movs	r0, r4
 8000ae6:	4a0b      	ldr	r2, [pc, #44]	@ (8000b14 <BSP_PB_Init+0x88>)
 8000ae8:	f000 f8f2 	bl	8000cd0 <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
 8000aec:	2200      	movs	r2, #0
 8000aee:	210f      	movs	r1, #15
 8000af0:	2007      	movs	r0, #7
 8000af2:	f000 f83f 	bl	8000b74 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 8000af6:	2007      	movs	r0, #7
 8000af8:	f000 f866 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
 8000afc:	e7e0      	b.n	8000ac0 <BSP_PB_Init+0x34>
 8000afe:	46c0      	nop			@ (mov r8, r8)
 8000b00:	40021000 	.word	0x40021000
 8000b04:	50000800 	.word	0x50000800
 8000b08:	10210000 	.word	0x10210000
 8000b0c:	200001d0 	.word	0x200001d0
 8000b10:	0600000d 	.word	0x0600000d
 8000b14:	08000b2f 	.word	0x08000b2f

08000b18 <BSP_PB_IRQHandler>:
  * @param  Button Can only be BUTTON_USER
  * @retval None
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
 8000b18:	230c      	movs	r3, #12
{
 8000b1a:	b510      	push	{r4, lr}
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
 8000b1c:	4343      	muls	r3, r0
 8000b1e:	4802      	ldr	r0, [pc, #8]	@ (8000b28 <BSP_PB_IRQHandler+0x10>)
 8000b20:	1818      	adds	r0, r3, r0
 8000b22:	f000 f8eb 	bl	8000cfc <HAL_EXTI_IRQHandler>
}
 8000b26:	bd10      	pop	{r4, pc}
 8000b28:	200001d0 	.word	0x200001d0

08000b2c <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 8000b2c:	4770      	bx	lr

08000b2e <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  Key EXTI line detection callbacks.
  * @retval BSP status
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 8000b2e:	b510      	push	{r4, lr}
  BSP_PB_Callback(BUTTON_USER);
 8000b30:	2000      	movs	r0, #0
 8000b32:	f7ff fffb 	bl	8000b2c <BSP_PB_Callback>
}
 8000b36:	bd10      	pop	{r4, pc}

08000b38 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000b38:	b510      	push	{r4, lr}
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000b3a:	2003      	movs	r0, #3
 8000b3c:	f7ff fe8e 	bl	800085c <HAL_InitTick>
 8000b40:	1e04      	subs	r4, r0, #0
 8000b42:	d103      	bne.n	8000b4c <HAL_Init+0x14>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8000b44:	f7ff fdc8 	bl	80006d8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 8000b48:	0020      	movs	r0, r4
 8000b4a:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8000b4c:	2401      	movs	r4, #1
 8000b4e:	e7fb      	b.n	8000b48 <HAL_Init+0x10>

08000b50 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8000b50:	4a03      	ldr	r2, [pc, #12]	@ (8000b60 <HAL_IncTick+0x10>)
 8000b52:	4b04      	ldr	r3, [pc, #16]	@ (8000b64 <HAL_IncTick+0x14>)
 8000b54:	6811      	ldr	r1, [r2, #0]
 8000b56:	781b      	ldrb	r3, [r3, #0]
 8000b58:	185b      	adds	r3, r3, r1
 8000b5a:	6013      	str	r3, [r2, #0]
}
 8000b5c:	4770      	bx	lr
 8000b5e:	46c0      	nop			@ (mov r8, r8)
 8000b60:	200001dc 	.word	0x200001dc
 8000b64:	20000004 	.word	0x20000004

08000b68 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b68:	4b01      	ldr	r3, [pc, #4]	@ (8000b70 <HAL_GetTick+0x8>)
 8000b6a:	6818      	ldr	r0, [r3, #0]
}
 8000b6c:	4770      	bx	lr
 8000b6e:	46c0      	nop			@ (mov r8, r8)
 8000b70:	200001dc 	.word	0x200001dc

08000b74 <HAL_NVIC_SetPriority>:
  *         with stm32c0xx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000b74:	b510      	push	{r4, lr}
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000b76:	24ff      	movs	r4, #255	@ 0xff
 8000b78:	2203      	movs	r2, #3
 8000b7a:	000b      	movs	r3, r1
 8000b7c:	0021      	movs	r1, r4
 8000b7e:	4002      	ands	r2, r0
 8000b80:	00d2      	lsls	r2, r2, #3
 8000b82:	4091      	lsls	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8000b84:	019b      	lsls	r3, r3, #6
 8000b86:	4023      	ands	r3, r4
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000b88:	43c9      	mvns	r1, r1
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8000b8a:	4093      	lsls	r3, r2
  if ((int32_t)(IRQn) >= 0)
 8000b8c:	2800      	cmp	r0, #0
 8000b8e:	db0a      	blt.n	8000ba6 <HAL_NVIC_SetPriority+0x32>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000b90:	24c0      	movs	r4, #192	@ 0xc0
 8000b92:	4a0b      	ldr	r2, [pc, #44]	@ (8000bc0 <HAL_NVIC_SetPriority+0x4c>)
 8000b94:	0880      	lsrs	r0, r0, #2
 8000b96:	0080      	lsls	r0, r0, #2
 8000b98:	1880      	adds	r0, r0, r2
 8000b9a:	00a4      	lsls	r4, r4, #2
 8000b9c:	5902      	ldr	r2, [r0, r4]
 8000b9e:	400a      	ands	r2, r1
 8000ba0:	4313      	orrs	r3, r2
 8000ba2:	5103      	str	r3, [r0, r4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(SubPriority);
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
}
 8000ba4:	bd10      	pop	{r4, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000ba6:	220f      	movs	r2, #15
 8000ba8:	4010      	ands	r0, r2
 8000baa:	3808      	subs	r0, #8
 8000bac:	4a05      	ldr	r2, [pc, #20]	@ (8000bc4 <HAL_NVIC_SetPriority+0x50>)
 8000bae:	0880      	lsrs	r0, r0, #2
 8000bb0:	0080      	lsls	r0, r0, #2
 8000bb2:	1880      	adds	r0, r0, r2
 8000bb4:	69c2      	ldr	r2, [r0, #28]
 8000bb6:	4011      	ands	r1, r2
 8000bb8:	4319      	orrs	r1, r3
 8000bba:	61c1      	str	r1, [r0, #28]
 8000bbc:	e7f2      	b.n	8000ba4 <HAL_NVIC_SetPriority+0x30>
 8000bbe:	46c0      	nop			@ (mov r8, r8)
 8000bc0:	e000e100 	.word	0xe000e100
 8000bc4:	e000ed00 	.word	0xe000ed00

08000bc8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000bc8:	2800      	cmp	r0, #0
 8000bca:	db05      	blt.n	8000bd8 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000bcc:	231f      	movs	r3, #31
 8000bce:	4018      	ands	r0, r3
 8000bd0:	3b1e      	subs	r3, #30
 8000bd2:	4083      	lsls	r3, r0
 8000bd4:	4a01      	ldr	r2, [pc, #4]	@ (8000bdc <HAL_NVIC_EnableIRQ+0x14>)
 8000bd6:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000bd8:	4770      	bx	lr
 8000bda:	46c0      	nop			@ (mov r8, r8)
 8000bdc:	e000e100 	.word	0xe000e100

08000be0 <HAL_DMA_Abort>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8000be0:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the DMA peripheral handle */
  if (NULL == hdma)
 8000be2:	2800      	cmp	r0, #0
 8000be4:	d008      	beq.n	8000bf8 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
  }

  /* Check the DMA peripheral state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8000be6:	1d84      	adds	r4, r0, #6
 8000be8:	7fe3      	ldrb	r3, [r4, #31]
 8000bea:	1d41      	adds	r1, r0, #5
 8000bec:	2b02      	cmp	r3, #2
 8000bee:	d005      	beq.n	8000bfc <HAL_DMA_Abort+0x1c>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000bf0:	2304      	movs	r3, #4
 8000bf2:	63c3      	str	r3, [r0, #60]	@ 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8000bf4:	2300      	movs	r3, #0
 8000bf6:	77cb      	strb	r3, [r1, #31]
    return HAL_ERROR;
 8000bf8:	2001      	movs	r0, #1
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
  }

  return HAL_OK;
}
 8000bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000bfc:	250e      	movs	r5, #14
 8000bfe:	6802      	ldr	r2, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8000c00:	6c46      	ldr	r6, [r0, #68]	@ 0x44
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000c02:	6813      	ldr	r3, [r2, #0]
 8000c04:	43ab      	bics	r3, r5
 8000c06:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8000c08:	6833      	ldr	r3, [r6, #0]
 8000c0a:	4d10      	ldr	r5, [pc, #64]	@ (8000c4c <HAL_DMA_Abort+0x6c>)
 8000c0c:	402b      	ands	r3, r5
 8000c0e:	6033      	str	r3, [r6, #0]
    __HAL_DMA_DISABLE(hdma);
 8000c10:	2301      	movs	r3, #1
 8000c12:	6816      	ldr	r6, [r2, #0]
 8000c14:	439e      	bics	r6, r3
 8000c16:	6016      	str	r6, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, ((DMA_FLAG_GI1) << (hdma->ChannelIndex  & 0x1cU)));
 8000c18:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 8000c1a:	331b      	adds	r3, #27
 8000c1c:	401a      	ands	r2, r3
 8000c1e:	3b1b      	subs	r3, #27
 8000c20:	4093      	lsls	r3, r2
 8000c22:	4e0b      	ldr	r6, [pc, #44]	@ (8000c50 <HAL_DMA_Abort+0x70>)
 8000c24:	6877      	ldr	r7, [r6, #4]
 8000c26:	433b      	orrs	r3, r7
 8000c28:	6073      	str	r3, [r6, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8000c2a:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 8000c2c:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8000c2e:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 8000c30:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 8000c32:	2b00      	cmp	r3, #0
 8000c34:	d005      	beq.n	8000c42 <HAL_DMA_Abort+0x62>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8000c36:	681a      	ldr	r2, [r3, #0]
 8000c38:	402a      	ands	r2, r5
 8000c3a:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8000c3c:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 8000c3e:	6d82      	ldr	r2, [r0, #88]	@ 0x58
 8000c40:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8000c42:	2301      	movs	r3, #1
    __HAL_UNLOCK(hdma);
 8000c44:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_READY;
 8000c46:	77e3      	strb	r3, [r4, #31]
    __HAL_UNLOCK(hdma);
 8000c48:	77c8      	strb	r0, [r1, #31]
  return HAL_OK;
 8000c4a:	e7d6      	b.n	8000bfa <HAL_DMA_Abort+0x1a>
 8000c4c:	fffffeff 	.word	0xfffffeff
 8000c50:	40020000 	.word	0x40020000

08000c54 <HAL_DMA_Abort_IT>:
  * @param  hdma    pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8000c54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Unlocked/locked */
  __HAL_UNLOCK(hdma);
  __HAL_LOCK(hdma);
 8000c56:	2301      	movs	r3, #1
 8000c58:	1d41      	adds	r1, r0, #5
 8000c5a:	77cb      	strb	r3, [r1, #31]

  if (HAL_DMA_STATE_BUSY != hdma->State)
 8000c5c:	1d84      	adds	r4, r0, #6
 8000c5e:	7fe2      	ldrb	r2, [r4, #31]
 8000c60:	2a02      	cmp	r2, #2
 8000c62:	d003      	beq.n	8000c6c <HAL_DMA_Abort_IT+0x18>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c64:	2204      	movs	r2, #4
 8000c66:	63c2      	str	r2, [r0, #60]	@ 0x3c

    status = HAL_ERROR;
 8000c68:	0018      	movs	r0, r3
    {
      hdma->XferAbortCallback(hdma);
    }
  }
  return status;
}
 8000c6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000c6c:	260e      	movs	r6, #14
 8000c6e:	6802      	ldr	r2, [r0, #0]
 8000c70:	6815      	ldr	r5, [r2, #0]
 8000c72:	43b5      	bics	r5, r6
 8000c74:	6015      	str	r5, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 8000c76:	6815      	ldr	r5, [r2, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8000c78:	6c46      	ldr	r6, [r0, #68]	@ 0x44
    __HAL_DMA_DISABLE(hdma);
 8000c7a:	439d      	bics	r5, r3
 8000c7c:	6015      	str	r5, [r2, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8000c7e:	6832      	ldr	r2, [r6, #0]
 8000c80:	4d11      	ldr	r5, [pc, #68]	@ (8000cc8 <HAL_DMA_Abort_IT+0x74>)
 8000c82:	402a      	ands	r2, r5
 8000c84:	6032      	str	r2, [r6, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, ((DMA_FLAG_GI1) << (hdma->ChannelIndex & 0x1cU)));
 8000c86:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 8000c88:	4e10      	ldr	r6, [pc, #64]	@ (8000ccc <HAL_DMA_Abort_IT+0x78>)
 8000c8a:	0015      	movs	r5, r2
 8000c8c:	221c      	movs	r2, #28
 8000c8e:	4015      	ands	r5, r2
 8000c90:	40ab      	lsls	r3, r5
 8000c92:	6877      	ldr	r7, [r6, #4]
 8000c94:	433b      	orrs	r3, r7
 8000c96:	6073      	str	r3, [r6, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8000c98:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 8000c9a:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8000c9c:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 8000c9e:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 8000ca0:	2b00      	cmp	r3, #0
 8000ca2:	d006      	beq.n	8000cb2 <HAL_DMA_Abort_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8000ca4:	681a      	ldr	r2, [r3, #0]
 8000ca6:	4d08      	ldr	r5, [pc, #32]	@ (8000cc8 <HAL_DMA_Abort_IT+0x74>)
 8000ca8:	402a      	ands	r2, r5
 8000caa:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8000cac:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 8000cae:	6d82      	ldr	r2, [r0, #88]	@ 0x58
 8000cb0:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8000cb2:	2301      	movs	r3, #1
 8000cb4:	77e3      	strb	r3, [r4, #31]
    __HAL_UNLOCK(hdma);
 8000cb6:	2300      	movs	r3, #0
 8000cb8:	77cb      	strb	r3, [r1, #31]
    if (hdma->XferAbortCallback != NULL)
 8000cba:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8000cbc:	2b00      	cmp	r3, #0
 8000cbe:	d000      	beq.n	8000cc2 <HAL_DMA_Abort_IT+0x6e>
      hdma->XferAbortCallback(hdma);
 8000cc0:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8000cc2:	2000      	movs	r0, #0
 8000cc4:	e7d1      	b.n	8000c6a <HAL_DMA_Abort_IT+0x16>
 8000cc6:	46c0      	nop			@ (mov r8, r8)
 8000cc8:	fffffeff 	.word	0xfffffeff
 8000ccc:	40020000 	.word	0x40020000

08000cd0 <HAL_EXTI_RegisterCallback>:
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID,
                                            void (*pPendingCbfn)(void))
{
 8000cd0:	0003      	movs	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 8000cd2:	2901      	cmp	r1, #1
 8000cd4:	d007      	beq.n	8000ce6 <HAL_EXTI_RegisterCallback+0x16>
 8000cd6:	2902      	cmp	r1, #2
 8000cd8:	d003      	beq.n	8000ce2 <HAL_EXTI_RegisterCallback+0x12>
 8000cda:	2001      	movs	r0, #1
 8000cdc:	2900      	cmp	r1, #0
 8000cde:	d104      	bne.n	8000cea <HAL_EXTI_RegisterCallback+0x1a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->RisingCallback = pPendingCbfn;
 8000ce0:	605a      	str	r2, [r3, #4]
    case  HAL_EXTI_RISING_CB_ID:
      hexti->RisingCallback = pPendingCbfn;
      break;

    case  HAL_EXTI_FALLING_CB_ID:
      hexti->FallingCallback = pPendingCbfn;
 8000ce2:	609a      	str	r2, [r3, #8]
      break;
 8000ce4:	e000      	b.n	8000ce8 <HAL_EXTI_RegisterCallback+0x18>
      hexti->RisingCallback = pPendingCbfn;
 8000ce6:	6042      	str	r2, [r0, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8000ce8:	2000      	movs	r0, #0
      status = HAL_ERROR;
      break;
  }

  return status;
}
 8000cea:	4770      	bx	lr

08000cec <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
 8000cec:	0003      	movs	r3, r0
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
  {
    return HAL_ERROR;
 8000cee:	2001      	movs	r0, #1
  if (hexti == NULL)
 8000cf0:	2b00      	cmp	r3, #0
 8000cf2:	d001      	beq.n	8000cf8 <HAL_EXTI_GetHandle+0xc>
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;

    return HAL_OK;
 8000cf4:	2000      	movs	r0, #0
    hexti->Line = ExtiLine;
 8000cf6:	6019      	str	r1, [r3, #0]
  }
}
 8000cf8:	4770      	bx	lr
	...

08000cfc <HAL_EXTI_IRQHandler>:
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 8000cfc:	2201      	movs	r2, #1
 8000cfe:	231f      	movs	r3, #31
{
 8000d00:	b570      	push	{r4, r5, r6, lr}
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 8000d02:	0016      	movs	r6, r2
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8000d04:	6804      	ldr	r4, [r0, #0]
{
 8000d06:	0005      	movs	r5, r0
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 8000d08:	4023      	ands	r3, r4
 8000d0a:	409e      	lsls	r6, r3
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8000d0c:	0c24      	lsrs	r4, r4, #16
 8000d0e:	4014      	ands	r4, r2

  /* Get rising edge pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->RPR1 + (EXTI_CONFIG_OFFSET * offset));
 8000d10:	4b0a      	ldr	r3, [pc, #40]	@ (8000d3c <HAL_EXTI_IRQHandler+0x40>)
 8000d12:	0164      	lsls	r4, r4, #5
 8000d14:	18e3      	adds	r3, r4, r3
  regval = (*regaddr & maskline);
 8000d16:	681a      	ldr	r2, [r3, #0]

  if (regval != 0U)
 8000d18:	4216      	tst	r6, r2
 8000d1a:	d004      	beq.n	8000d26 <HAL_EXTI_IRQHandler+0x2a>
  {
    /* Clear pending bit */
    *regaddr = maskline;
 8000d1c:	601e      	str	r6, [r3, #0]

    /* Call rising callback */
    if (hexti->RisingCallback != NULL)
 8000d1e:	6843      	ldr	r3, [r0, #4]
 8000d20:	2b00      	cmp	r3, #0
 8000d22:	d000      	beq.n	8000d26 <HAL_EXTI_IRQHandler+0x2a>
    {
      hexti->RisingCallback();
 8000d24:	4798      	blx	r3
    }
  }

  /* Get falling edge pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->FPR1 + (EXTI_CONFIG_OFFSET * offset));
 8000d26:	4b06      	ldr	r3, [pc, #24]	@ (8000d40 <HAL_EXTI_IRQHandler+0x44>)
 8000d28:	18e4      	adds	r4, r4, r3
  regval = (*regaddr & maskline);
 8000d2a:	6823      	ldr	r3, [r4, #0]

  if (regval != 0U)
 8000d2c:	421e      	tst	r6, r3
 8000d2e:	d004      	beq.n	8000d3a <HAL_EXTI_IRQHandler+0x3e>
  {
    /* Clear pending bit */
    *regaddr = maskline;

    /* Call rising callback */
    if (hexti->FallingCallback != NULL)
 8000d30:	68ab      	ldr	r3, [r5, #8]
    *regaddr = maskline;
 8000d32:	6026      	str	r6, [r4, #0]
    if (hexti->FallingCallback != NULL)
 8000d34:	2b00      	cmp	r3, #0
 8000d36:	d000      	beq.n	8000d3a <HAL_EXTI_IRQHandler+0x3e>
    {
      hexti->FallingCallback();
 8000d38:	4798      	blx	r3
    }
  }
}
 8000d3a:	bd70      	pop	{r4, r5, r6, pc}
 8000d3c:	4002180c 	.word	0x4002180c
 8000d40:	40021810 	.word	0x40021810

08000d44 <HAL_GPIO_Init>:
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t position = 0U;
 8000d44:	2300      	movs	r3, #0
 8000d46:	469c      	mov	ip, r3
{
 8000d48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d4a:	b085      	sub	sp, #20
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 8000d4c:	680b      	ldr	r3, [r1, #0]
 8000d4e:	4664      	mov	r4, ip
 8000d50:	001a      	movs	r2, r3
 8000d52:	40e2      	lsrs	r2, r4
 8000d54:	d101      	bne.n	8000d5a <HAL_GPIO_Init+0x16>
      }
    }

    position++;
  }
}
 8000d56:	b005      	add	sp, #20
 8000d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 8000d5a:	4662      	mov	r2, ip
 8000d5c:	2601      	movs	r6, #1
 8000d5e:	4096      	lsls	r6, r2
 8000d60:	001a      	movs	r2, r3
 8000d62:	4032      	ands	r2, r6
 8000d64:	9201      	str	r2, [sp, #4]
    if (iocurrent != 0U)
 8000d66:	4233      	tst	r3, r6
 8000d68:	d100      	bne.n	8000d6c <HAL_GPIO_Init+0x28>
 8000d6a:	e084      	b.n	8000e76 <HAL_GPIO_Init+0x132>
      if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000d6c:	684f      	ldr	r7, [r1, #4]
 8000d6e:	2310      	movs	r3, #16
 8000d70:	003d      	movs	r5, r7
 8000d72:	439d      	bics	r5, r3
 8000d74:	9503      	str	r5, [sp, #12]
 8000d76:	2d02      	cmp	r5, #2
 8000d78:	d114      	bne.n	8000da4 <HAL_GPIO_Init+0x60>
        tmp = GPIOx->AFR[position >> 3U];
 8000d7a:	4663      	mov	r3, ip
 8000d7c:	08da      	lsrs	r2, r3, #3
 8000d7e:	0092      	lsls	r2, r2, #2
 8000d80:	1882      	adds	r2, r0, r2
 8000d82:	6a13      	ldr	r3, [r2, #32]
        tmp &= ~(0xFUL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos)) ;
 8000d84:	2407      	movs	r4, #7
        tmp = GPIOx->AFR[position >> 3U];
 8000d86:	001d      	movs	r5, r3
        tmp &= ~(0xFUL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos)) ;
 8000d88:	4663      	mov	r3, ip
 8000d8a:	401c      	ands	r4, r3
 8000d8c:	230f      	movs	r3, #15
 8000d8e:	00a4      	lsls	r4, r4, #2
 8000d90:	40a3      	lsls	r3, r4
 8000d92:	439d      	bics	r5, r3
 8000d94:	9502      	str	r5, [sp, #8]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 8000d96:	250f      	movs	r5, #15
 8000d98:	690b      	ldr	r3, [r1, #16]
 8000d9a:	402b      	ands	r3, r5
 8000d9c:	40a3      	lsls	r3, r4
 8000d9e:	9c02      	ldr	r4, [sp, #8]
 8000da0:	4323      	orrs	r3, r4
        GPIOx->AFR[position >> 3U] = tmp;
 8000da2:	6213      	str	r3, [r2, #32]
      tmp = GPIOx->MODER;
 8000da4:	4663      	mov	r3, ip
 8000da6:	005a      	lsls	r2, r3, #1
      tmp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
 8000da8:	2303      	movs	r3, #3
 8000daa:	4093      	lsls	r3, r2
      tmp = GPIOx->MODER;
 8000dac:	6804      	ldr	r4, [r0, #0]
      tmp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
 8000dae:	43dd      	mvns	r5, r3
 8000db0:	439c      	bics	r4, r3
      tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
 8000db2:	2303      	movs	r3, #3
 8000db4:	403b      	ands	r3, r7
 8000db6:	4093      	lsls	r3, r2
      tmp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
 8000db8:	9502      	str	r5, [sp, #8]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000dba:	9d03      	ldr	r5, [sp, #12]
      tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
 8000dbc:	4323      	orrs	r3, r4
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000dbe:	3d01      	subs	r5, #1
      GPIOx->MODER = tmp;
 8000dc0:	6003      	str	r3, [r0, #0]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000dc2:	2d01      	cmp	r5, #1
 8000dc4:	d95a      	bls.n	8000e7c <HAL_GPIO_Init+0x138>
      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 8000dc6:	2f03      	cmp	r7, #3
 8000dc8:	d055      	beq.n	8000e76 <HAL_GPIO_Init+0x132>
        tmp = GPIOx->PUPDR;
 8000dca:	68c4      	ldr	r4, [r0, #12]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
 8000dcc:	9b02      	ldr	r3, [sp, #8]
 8000dce:	401c      	ands	r4, r3
        tmp |= ((pGPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
 8000dd0:	688b      	ldr	r3, [r1, #8]
 8000dd2:	4093      	lsls	r3, r2
 8000dd4:	4323      	orrs	r3, r4
        GPIOx->PUPDR = tmp;
 8000dd6:	60c3      	str	r3, [r0, #12]
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000dd8:	2380      	movs	r3, #128	@ 0x80
 8000dda:	055b      	lsls	r3, r3, #21
 8000ddc:	421f      	tst	r7, r3
 8000dde:	d04a      	beq.n	8000e76 <HAL_GPIO_Init+0x132>
        tmp = EXTI->EXTICR[position >> 2U];
 8000de0:	4663      	mov	r3, ip
 8000de2:	089a      	lsrs	r2, r3, #2
 8000de4:	4b2d      	ldr	r3, [pc, #180]	@ (8000e9c <HAL_GPIO_Init+0x158>)
 8000de6:	0092      	lsls	r2, r2, #2
 8000de8:	18d2      	adds	r2, r2, r3
        tmp &= ~((0x0FUL) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 8000dea:	2403      	movs	r4, #3
 8000dec:	4663      	mov	r3, ip
 8000dee:	401c      	ands	r4, r3
 8000df0:	230f      	movs	r3, #15
 8000df2:	00e4      	lsls	r4, r4, #3
 8000df4:	40a3      	lsls	r3, r4
        tmp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 8000df6:	26a0      	movs	r6, #160	@ 0xa0
        tmp = EXTI->EXTICR[position >> 2U];
 8000df8:	6e15      	ldr	r5, [r2, #96]	@ 0x60
        tmp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 8000dfa:	05f6      	lsls	r6, r6, #23
        tmp &= ~((0x0FUL) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 8000dfc:	439d      	bics	r5, r3
        tmp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * EXTI_EXTICR1_EXTI1_Pos));
 8000dfe:	2300      	movs	r3, #0
 8000e00:	42b0      	cmp	r0, r6
 8000e02:	d010      	beq.n	8000e26 <HAL_GPIO_Init+0xe2>
 8000e04:	4e26      	ldr	r6, [pc, #152]	@ (8000ea0 <HAL_GPIO_Init+0x15c>)
 8000e06:	3301      	adds	r3, #1
 8000e08:	42b0      	cmp	r0, r6
 8000e0a:	d00c      	beq.n	8000e26 <HAL_GPIO_Init+0xe2>
 8000e0c:	4e25      	ldr	r6, [pc, #148]	@ (8000ea4 <HAL_GPIO_Init+0x160>)
 8000e0e:	3301      	adds	r3, #1
 8000e10:	42b0      	cmp	r0, r6
 8000e12:	d008      	beq.n	8000e26 <HAL_GPIO_Init+0xe2>
 8000e14:	4e24      	ldr	r6, [pc, #144]	@ (8000ea8 <HAL_GPIO_Init+0x164>)
 8000e16:	3301      	adds	r3, #1
 8000e18:	42b0      	cmp	r0, r6
 8000e1a:	d004      	beq.n	8000e26 <HAL_GPIO_Init+0xe2>
 8000e1c:	4b23      	ldr	r3, [pc, #140]	@ (8000eac <HAL_GPIO_Init+0x168>)
 8000e1e:	18c3      	adds	r3, r0, r3
 8000e20:	1e5e      	subs	r6, r3, #1
 8000e22:	41b3      	sbcs	r3, r6
 8000e24:	3305      	adds	r3, #5
 8000e26:	40a3      	lsls	r3, r4
 8000e28:	432b      	orrs	r3, r5
        EXTI->EXTICR[position >> 2U] = tmp;
 8000e2a:	6613      	str	r3, [r2, #96]	@ 0x60
        tmp = EXTI->IMR1;
 8000e2c:	4b20      	ldr	r3, [pc, #128]	@ (8000eb0 <HAL_GPIO_Init+0x16c>)
        tmp &= ~((uint32_t)iocurrent);
 8000e2e:	9a01      	ldr	r2, [sp, #4]
        tmp = EXTI->IMR1;
 8000e30:	6fdd      	ldr	r5, [r3, #124]	@ 0x7c
          tmp |= iocurrent;
 8000e32:	9c01      	ldr	r4, [sp, #4]
        tmp &= ~((uint32_t)iocurrent);
 8000e34:	43d2      	mvns	r2, r2
          tmp |= iocurrent;
 8000e36:	432c      	orrs	r4, r5
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000e38:	03fe      	lsls	r6, r7, #15
 8000e3a:	d401      	bmi.n	8000e40 <HAL_GPIO_Init+0xfc>
        tmp &= ~((uint32_t)iocurrent);
 8000e3c:	002c      	movs	r4, r5
 8000e3e:	4014      	ands	r4, r2
        EXTI->IMR1 = tmp;
 8000e40:	67dc      	str	r4, [r3, #124]	@ 0x7c
        tmp = EXTI->EMR1;
 8000e42:	4c1c      	ldr	r4, [pc, #112]	@ (8000eb4 <HAL_GPIO_Init+0x170>)
          tmp |= iocurrent;
 8000e44:	9d01      	ldr	r5, [sp, #4]
        tmp = EXTI->EMR1;
 8000e46:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
          tmp |= iocurrent;
 8000e48:	431d      	orrs	r5, r3
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000e4a:	03be      	lsls	r6, r7, #14
 8000e4c:	d401      	bmi.n	8000e52 <HAL_GPIO_Init+0x10e>
        tmp &= ~((uint32_t)iocurrent);
 8000e4e:	4013      	ands	r3, r2
 8000e50:	001d      	movs	r5, r3
        EXTI->EMR1 = tmp;
 8000e52:	4b12      	ldr	r3, [pc, #72]	@ (8000e9c <HAL_GPIO_Init+0x158>)
 8000e54:	67e5      	str	r5, [r4, #124]	@ 0x7c
        tmp = EXTI->RTSR1;
 8000e56:	681d      	ldr	r5, [r3, #0]
          tmp |= iocurrent;
 8000e58:	9c01      	ldr	r4, [sp, #4]
 8000e5a:	432c      	orrs	r4, r5
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000e5c:	02fe      	lsls	r6, r7, #11
 8000e5e:	d401      	bmi.n	8000e64 <HAL_GPIO_Init+0x120>
        tmp &= ~((uint32_t)iocurrent);
 8000e60:	002c      	movs	r4, r5
 8000e62:	4014      	ands	r4, r2
        EXTI->RTSR1 = tmp;
 8000e64:	601c      	str	r4, [r3, #0]
        tmp = EXTI->FTSR1;
 8000e66:	685c      	ldr	r4, [r3, #4]
          tmp |= iocurrent;
 8000e68:	9d01      	ldr	r5, [sp, #4]
 8000e6a:	4325      	orrs	r5, r4
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000e6c:	02bf      	lsls	r7, r7, #10
 8000e6e:	d401      	bmi.n	8000e74 <HAL_GPIO_Init+0x130>
        tmp &= ~((uint32_t)iocurrent);
 8000e70:	4014      	ands	r4, r2
 8000e72:	0025      	movs	r5, r4
        EXTI->FTSR1 = tmp;
 8000e74:	605d      	str	r5, [r3, #4]
    position++;
 8000e76:	2301      	movs	r3, #1
 8000e78:	449c      	add	ip, r3
 8000e7a:	e767      	b.n	8000d4c <HAL_GPIO_Init+0x8>
        tmp = GPIOx->OSPEEDR;
 8000e7c:	6884      	ldr	r4, [r0, #8]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
 8000e7e:	9b02      	ldr	r3, [sp, #8]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000e80:	4665      	mov	r5, ip
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
 8000e82:	401c      	ands	r4, r3
        tmp |= (pGPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
 8000e84:	68cb      	ldr	r3, [r1, #12]
 8000e86:	4093      	lsls	r3, r2
 8000e88:	4323      	orrs	r3, r4
        GPIOx->OSPEEDR = tmp;
 8000e8a:	6083      	str	r3, [r0, #8]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000e8c:	093b      	lsrs	r3, r7, #4
 8000e8e:	40ab      	lsls	r3, r5
        tmp = GPIOx->OTYPER;
 8000e90:	6844      	ldr	r4, [r0, #4]
        tmp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000e92:	43b4      	bics	r4, r6
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000e94:	4323      	orrs	r3, r4
        GPIOx->OTYPER = tmp;
 8000e96:	6043      	str	r3, [r0, #4]
      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 8000e98:	e797      	b.n	8000dca <HAL_GPIO_Init+0x86>
 8000e9a:	46c0      	nop			@ (mov r8, r8)
 8000e9c:	40021800 	.word	0x40021800
 8000ea0:	50000400 	.word	0x50000400
 8000ea4:	50000800 	.word	0x50000800
 8000ea8:	50000c00 	.word	0x50000c00
 8000eac:	afffec00 	.word	0xafffec00
 8000eb0:	40021804 	.word	0x40021804
 8000eb4:	40021808 	.word	0x40021808

08000eb8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8000eb8:	2a00      	cmp	r2, #0
 8000eba:	d001      	beq.n	8000ec0 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000ebc:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8000ebe:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8000ec0:	6281      	str	r1, [r0, #40]	@ 0x28
}
 8000ec2:	e7fc      	b.n	8000ebe <HAL_GPIO_WritePin+0x6>

08000ec4 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 8000ec4:	6942      	ldr	r2, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8000ec6:	0013      	movs	r3, r2
 8000ec8:	400b      	ands	r3, r1
 8000eca:	041b      	lsls	r3, r3, #16
 8000ecc:	4391      	bics	r1, r2
 8000ece:	430b      	orrs	r3, r1
 8000ed0:	6183      	str	r3, [r0, #24]
}
 8000ed2:	4770      	bx	lr

08000ed4 <HAL_RCC_OscConfig>:
            must adjust the number of CPU wait states in their application (SystemClock_Config() API)
            before calling the HAL_RCC_OscConfig() API to update the HSI48 clock division factor.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ed6:	1e05      	subs	r5, r0, #0
  uint32_t tickstart;
  uint32_t temp_sysclksrc;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8000ed8:	d101      	bne.n	8000ede <HAL_RCC_OscConfig+0xa>
  {
    return HAL_ERROR;
 8000eda:	2001      	movs	r0, #1
      }
    }
  }
#endif /* RCC_CR_HSIUSB48ON */
  return HAL_OK;
}
 8000edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000ede:	6803      	ldr	r3, [r0, #0]
 8000ee0:	07db      	lsls	r3, r3, #31
 8000ee2:	d40d      	bmi.n	8000f00 <HAL_RCC_OscConfig+0x2c>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000ee4:	682b      	ldr	r3, [r5, #0]
 8000ee6:	079b      	lsls	r3, r3, #30
 8000ee8:	d44f      	bmi.n	8000f8a <HAL_RCC_OscConfig+0xb6>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000eea:	682b      	ldr	r3, [r5, #0]
 8000eec:	071b      	lsls	r3, r3, #28
 8000eee:	d500      	bpl.n	8000ef2 <HAL_RCC_OscConfig+0x1e>
 8000ef0:	e0a4      	b.n	800103c <HAL_RCC_OscConfig+0x168>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000ef2:	2204      	movs	r2, #4
 8000ef4:	682b      	ldr	r3, [r5, #0]
 8000ef6:	4213      	tst	r3, r2
 8000ef8:	d000      	beq.n	8000efc <HAL_RCC_OscConfig+0x28>
 8000efa:	e0cf      	b.n	800109c <HAL_RCC_OscConfig+0x1c8>
  return HAL_OK;
 8000efc:	2000      	movs	r0, #0
 8000efe:	e7ed      	b.n	8000edc <HAL_RCC_OscConfig+0x8>
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000f00:	2138      	movs	r1, #56	@ 0x38
 8000f02:	4c85      	ldr	r4, [pc, #532]	@ (8001118 <HAL_RCC_OscConfig+0x244>)
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8000f04:	6843      	ldr	r3, [r0, #4]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000f06:	68a2      	ldr	r2, [r4, #8]
 8000f08:	400a      	ands	r2, r1
    if (temp_sysclksrc == RCC_CFGR_SWS_HSE)
 8000f0a:	2a08      	cmp	r2, #8
 8000f0c:	d102      	bne.n	8000f14 <HAL_RCC_OscConfig+0x40>
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8000f0e:	2b00      	cmp	r3, #0
 8000f10:	d1e8      	bne.n	8000ee4 <HAL_RCC_OscConfig+0x10>
 8000f12:	e7e2      	b.n	8000eda <HAL_RCC_OscConfig+0x6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f14:	2280      	movs	r2, #128	@ 0x80
 8000f16:	0252      	lsls	r2, r2, #9
 8000f18:	4293      	cmp	r3, r2
 8000f1a:	d111      	bne.n	8000f40 <HAL_RCC_OscConfig+0x6c>
 8000f1c:	6822      	ldr	r2, [r4, #0]
 8000f1e:	4313      	orrs	r3, r2
 8000f20:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8000f22:	f7ff fe21 	bl	8000b68 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000f26:	2780      	movs	r7, #128	@ 0x80
        tickstart = HAL_GetTick();
 8000f28:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000f2a:	02bf      	lsls	r7, r7, #10
 8000f2c:	6823      	ldr	r3, [r4, #0]
 8000f2e:	423b      	tst	r3, r7
 8000f30:	d1d8      	bne.n	8000ee4 <HAL_RCC_OscConfig+0x10>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
 8000f32:	f7ff fe19 	bl	8000b68 <HAL_GetTick>
 8000f36:	1b80      	subs	r0, r0, r6
 8000f38:	2864      	cmp	r0, #100	@ 0x64
 8000f3a:	d9f7      	bls.n	8000f2c <HAL_RCC_OscConfig+0x58>
            return HAL_TIMEOUT;
 8000f3c:	2003      	movs	r0, #3
 8000f3e:	e7cd      	b.n	8000edc <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f40:	21a0      	movs	r1, #160	@ 0xa0
 8000f42:	02c9      	lsls	r1, r1, #11
 8000f44:	428b      	cmp	r3, r1
 8000f46:	d108      	bne.n	8000f5a <HAL_RCC_OscConfig+0x86>
 8000f48:	2380      	movs	r3, #128	@ 0x80
 8000f4a:	6821      	ldr	r1, [r4, #0]
 8000f4c:	02db      	lsls	r3, r3, #11
 8000f4e:	430b      	orrs	r3, r1
 8000f50:	6023      	str	r3, [r4, #0]
 8000f52:	6823      	ldr	r3, [r4, #0]
 8000f54:	431a      	orrs	r2, r3
 8000f56:	6022      	str	r2, [r4, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8000f58:	e7e3      	b.n	8000f22 <HAL_RCC_OscConfig+0x4e>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000f5a:	6822      	ldr	r2, [r4, #0]
 8000f5c:	496f      	ldr	r1, [pc, #444]	@ (800111c <HAL_RCC_OscConfig+0x248>)
 8000f5e:	400a      	ands	r2, r1
 8000f60:	6022      	str	r2, [r4, #0]
 8000f62:	6822      	ldr	r2, [r4, #0]
 8000f64:	496e      	ldr	r1, [pc, #440]	@ (8001120 <HAL_RCC_OscConfig+0x24c>)
 8000f66:	400a      	ands	r2, r1
 8000f68:	6022      	str	r2, [r4, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8000f6a:	2b00      	cmp	r3, #0
 8000f6c:	d1d9      	bne.n	8000f22 <HAL_RCC_OscConfig+0x4e>
        tickstart = HAL_GetTick();
 8000f6e:	f7ff fdfb 	bl	8000b68 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8000f72:	2780      	movs	r7, #128	@ 0x80
        tickstart = HAL_GetTick();
 8000f74:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8000f76:	02bf      	lsls	r7, r7, #10
 8000f78:	6823      	ldr	r3, [r4, #0]
 8000f7a:	423b      	tst	r3, r7
 8000f7c:	d0b2      	beq.n	8000ee4 <HAL_RCC_OscConfig+0x10>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
 8000f7e:	f7ff fdf3 	bl	8000b68 <HAL_GetTick>
 8000f82:	1b80      	subs	r0, r0, r6
 8000f84:	2864      	cmp	r0, #100	@ 0x64
 8000f86:	d9f7      	bls.n	8000f78 <HAL_RCC_OscConfig+0xa4>
 8000f88:	e7d8      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000f8a:	2238      	movs	r2, #56	@ 0x38
 8000f8c:	4c62      	ldr	r4, [pc, #392]	@ (8001118 <HAL_RCC_OscConfig+0x244>)
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8000f8e:	68eb      	ldr	r3, [r5, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000f90:	68a1      	ldr	r1, [r4, #8]
    if (temp_sysclksrc == RCC_CFGR_SWS_HSI)
 8000f92:	4211      	tst	r1, r2
 8000f94:	d11c      	bne.n	8000fd0 <HAL_RCC_OscConfig+0xfc>
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8000f96:	2b00      	cmp	r3, #0
 8000f98:	d09f      	beq.n	8000eda <HAL_RCC_OscConfig+0x6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000f9a:	6862      	ldr	r2, [r4, #4]
 8000f9c:	696b      	ldr	r3, [r5, #20]
 8000f9e:	4961      	ldr	r1, [pc, #388]	@ (8001124 <HAL_RCC_OscConfig+0x250>)
 8000fa0:	021b      	lsls	r3, r3, #8
 8000fa2:	400a      	ands	r2, r1
 8000fa4:	4313      	orrs	r3, r2
 8000fa6:	6063      	str	r3, [r4, #4]
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000fa8:	6823      	ldr	r3, [r4, #0]
 8000faa:	4a5f      	ldr	r2, [pc, #380]	@ (8001128 <HAL_RCC_OscConfig+0x254>)
          SystemCoreClock = (HSI_VALUE / (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos)));
 8000fac:	495f      	ldr	r1, [pc, #380]	@ (800112c <HAL_RCC_OscConfig+0x258>)
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000fae:	4013      	ands	r3, r2
 8000fb0:	692a      	ldr	r2, [r5, #16]
 8000fb2:	4313      	orrs	r3, r2
 8000fb4:	6023      	str	r3, [r4, #0]
          SystemCoreClock = (HSI_VALUE / (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos)));
 8000fb6:	6823      	ldr	r3, [r4, #0]
 8000fb8:	4a5d      	ldr	r2, [pc, #372]	@ (8001130 <HAL_RCC_OscConfig+0x25c>)
 8000fba:	049b      	lsls	r3, r3, #18
 8000fbc:	0f5b      	lsrs	r3, r3, #29
 8000fbe:	40da      	lsrs	r2, r3
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8000fc0:	4b5c      	ldr	r3, [pc, #368]	@ (8001134 <HAL_RCC_OscConfig+0x260>)
          SystemCoreClock = (HSI_VALUE / (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos)));
 8000fc2:	600a      	str	r2, [r1, #0]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8000fc4:	6818      	ldr	r0, [r3, #0]
 8000fc6:	f7ff fc49 	bl	800085c <HAL_InitTick>
 8000fca:	2800      	cmp	r0, #0
 8000fcc:	d08d      	beq.n	8000eea <HAL_RCC_OscConfig+0x16>
 8000fce:	e784      	b.n	8000eda <HAL_RCC_OscConfig+0x6>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000fd0:	2b00      	cmp	r3, #0
 8000fd2:	d020      	beq.n	8001016 <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000fd4:	6823      	ldr	r3, [r4, #0]
 8000fd6:	4a54      	ldr	r2, [pc, #336]	@ (8001128 <HAL_RCC_OscConfig+0x254>)
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000fd8:	2780      	movs	r7, #128	@ 0x80
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000fda:	4013      	ands	r3, r2
 8000fdc:	692a      	ldr	r2, [r5, #16]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000fde:	00ff      	lsls	r7, r7, #3
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000fe0:	4313      	orrs	r3, r2
 8000fe2:	6023      	str	r3, [r4, #0]
        __HAL_RCC_HSI_ENABLE();
 8000fe4:	2380      	movs	r3, #128	@ 0x80
 8000fe6:	6822      	ldr	r2, [r4, #0]
 8000fe8:	005b      	lsls	r3, r3, #1
 8000fea:	4313      	orrs	r3, r2
 8000fec:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8000fee:	f7ff fdbb 	bl	8000b68 <HAL_GetTick>
 8000ff2:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000ff4:	6823      	ldr	r3, [r4, #0]
 8000ff6:	423b      	tst	r3, r7
 8000ff8:	d007      	beq.n	800100a <HAL_RCC_OscConfig+0x136>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000ffa:	6862      	ldr	r2, [r4, #4]
 8000ffc:	696b      	ldr	r3, [r5, #20]
 8000ffe:	4949      	ldr	r1, [pc, #292]	@ (8001124 <HAL_RCC_OscConfig+0x250>)
 8001000:	021b      	lsls	r3, r3, #8
 8001002:	400a      	ands	r2, r1
 8001004:	4313      	orrs	r3, r2
 8001006:	6063      	str	r3, [r4, #4]
 8001008:	e76f      	b.n	8000eea <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
 800100a:	f7ff fdad 	bl	8000b68 <HAL_GetTick>
 800100e:	1b80      	subs	r0, r0, r6
 8001010:	2802      	cmp	r0, #2
 8001012:	d9ef      	bls.n	8000ff4 <HAL_RCC_OscConfig+0x120>
 8001014:	e792      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
        __HAL_RCC_HSI_DISABLE();
 8001016:	6823      	ldr	r3, [r4, #0]
 8001018:	4a47      	ldr	r2, [pc, #284]	@ (8001138 <HAL_RCC_OscConfig+0x264>)
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800101a:	2780      	movs	r7, #128	@ 0x80
        __HAL_RCC_HSI_DISABLE();
 800101c:	4013      	ands	r3, r2
 800101e:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8001020:	f7ff fda2 	bl	8000b68 <HAL_GetTick>
 8001024:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8001026:	00ff      	lsls	r7, r7, #3
 8001028:	6823      	ldr	r3, [r4, #0]
 800102a:	423b      	tst	r3, r7
 800102c:	d100      	bne.n	8001030 <HAL_RCC_OscConfig+0x15c>
 800102e:	e75c      	b.n	8000eea <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
 8001030:	f7ff fd9a 	bl	8000b68 <HAL_GetTick>
 8001034:	1b80      	subs	r0, r0, r6
 8001036:	2802      	cmp	r0, #2
 8001038:	d9f6      	bls.n	8001028 <HAL_RCC_OscConfig+0x154>
 800103a:	e77f      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 800103c:	2138      	movs	r1, #56	@ 0x38
 800103e:	4c36      	ldr	r4, [pc, #216]	@ (8001118 <HAL_RCC_OscConfig+0x244>)
      if (RCC_OscInitStruct->LSIState == RCC_LSI_OFF)
 8001040:	69aa      	ldr	r2, [r5, #24]
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8001042:	68a3      	ldr	r3, [r4, #8]
 8001044:	400b      	ands	r3, r1
 8001046:	2b18      	cmp	r3, #24
 8001048:	d103      	bne.n	8001052 <HAL_RCC_OscConfig+0x17e>
      if (RCC_OscInitStruct->LSIState == RCC_LSI_OFF)
 800104a:	2a00      	cmp	r2, #0
 800104c:	d000      	beq.n	8001050 <HAL_RCC_OscConfig+0x17c>
 800104e:	e750      	b.n	8000ef2 <HAL_RCC_OscConfig+0x1e>
 8001050:	e743      	b.n	8000eda <HAL_RCC_OscConfig+0x6>
      if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001052:	2301      	movs	r3, #1
 8001054:	2a00      	cmp	r2, #0
 8001056:	d010      	beq.n	800107a <HAL_RCC_OscConfig+0x1a6>
        __HAL_RCC_LSI_ENABLE();
 8001058:	6e22      	ldr	r2, [r4, #96]	@ 0x60
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) == 0U)
 800105a:	2702      	movs	r7, #2
        __HAL_RCC_LSI_ENABLE();
 800105c:	4313      	orrs	r3, r2
 800105e:	6623      	str	r3, [r4, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8001060:	f7ff fd82 	bl	8000b68 <HAL_GetTick>
 8001064:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) == 0U)
 8001066:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 8001068:	423b      	tst	r3, r7
 800106a:	d000      	beq.n	800106e <HAL_RCC_OscConfig+0x19a>
 800106c:	e741      	b.n	8000ef2 <HAL_RCC_OscConfig+0x1e>
          if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
 800106e:	f7ff fd7b 	bl	8000b68 <HAL_GetTick>
 8001072:	1b80      	subs	r0, r0, r6
 8001074:	2802      	cmp	r0, #2
 8001076:	d9f6      	bls.n	8001066 <HAL_RCC_OscConfig+0x192>
 8001078:	e760      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
        __HAL_RCC_LSI_DISABLE();
 800107a:	6e22      	ldr	r2, [r4, #96]	@ 0x60
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) != 0U)
 800107c:	2702      	movs	r7, #2
        __HAL_RCC_LSI_DISABLE();
 800107e:	439a      	bics	r2, r3
 8001080:	6622      	str	r2, [r4, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8001082:	f7ff fd71 	bl	8000b68 <HAL_GetTick>
 8001086:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) != 0U)
 8001088:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 800108a:	423b      	tst	r3, r7
 800108c:	d100      	bne.n	8001090 <HAL_RCC_OscConfig+0x1bc>
 800108e:	e730      	b.n	8000ef2 <HAL_RCC_OscConfig+0x1e>
          if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
 8001090:	f7ff fd6a 	bl	8000b68 <HAL_GetTick>
 8001094:	1b80      	subs	r0, r0, r6
 8001096:	2802      	cmp	r0, #2
 8001098:	d9f6      	bls.n	8001088 <HAL_RCC_OscConfig+0x1b4>
 800109a:	e74f      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 800109c:	2138      	movs	r1, #56	@ 0x38
 800109e:	4c1e      	ldr	r4, [pc, #120]	@ (8001118 <HAL_RCC_OscConfig+0x244>)
      if (RCC_OscInitStruct->LSEState == RCC_LSE_OFF)
 80010a0:	68a8      	ldr	r0, [r5, #8]
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 80010a2:	68a3      	ldr	r3, [r4, #8]
 80010a4:	400b      	ands	r3, r1
 80010a6:	2b20      	cmp	r3, #32
 80010a8:	d103      	bne.n	80010b2 <HAL_RCC_OscConfig+0x1de>
      if (RCC_OscInitStruct->LSEState == RCC_LSE_OFF)
 80010aa:	4243      	negs	r3, r0
 80010ac:	4158      	adcs	r0, r3
 80010ae:	b2c0      	uxtb	r0, r0
 80010b0:	e714      	b.n	8000edc <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010b2:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80010b4:	2801      	cmp	r0, #1
 80010b6:	d110      	bne.n	80010da <HAL_RCC_OscConfig+0x206>
 80010b8:	4303      	orrs	r3, r0
 80010ba:	65e3      	str	r3, [r4, #92]	@ 0x5c
        tickstart = HAL_GetTick();
 80010bc:	f7ff fd54 	bl	8000b68 <HAL_GetTick>
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == 0U)
 80010c0:	2602      	movs	r6, #2
        tickstart = HAL_GetTick();
 80010c2:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == 0U)
 80010c4:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80010c6:	4233      	tst	r3, r6
 80010c8:	d000      	beq.n	80010cc <HAL_RCC_OscConfig+0x1f8>
 80010ca:	e717      	b.n	8000efc <HAL_RCC_OscConfig+0x28>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80010cc:	f7ff fd4c 	bl	8000b68 <HAL_GetTick>
 80010d0:	4b1a      	ldr	r3, [pc, #104]	@ (800113c <HAL_RCC_OscConfig+0x268>)
 80010d2:	1b40      	subs	r0, r0, r5
 80010d4:	4298      	cmp	r0, r3
 80010d6:	d9f5      	bls.n	80010c4 <HAL_RCC_OscConfig+0x1f0>
 80010d8:	e730      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80010da:	2805      	cmp	r0, #5
 80010dc:	d105      	bne.n	80010ea <HAL_RCC_OscConfig+0x216>
 80010de:	4313      	orrs	r3, r2
 80010e0:	65e3      	str	r3, [r4, #92]	@ 0x5c
 80010e2:	2301      	movs	r3, #1
 80010e4:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 80010e6:	4313      	orrs	r3, r2
 80010e8:	e7e7      	b.n	80010ba <HAL_RCC_OscConfig+0x1e6>
 80010ea:	2101      	movs	r1, #1
 80010ec:	438b      	bics	r3, r1
 80010ee:	65e3      	str	r3, [r4, #92]	@ 0x5c
 80010f0:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80010f2:	4393      	bics	r3, r2
 80010f4:	65e3      	str	r3, [r4, #92]	@ 0x5c
      if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80010f6:	2800      	cmp	r0, #0
 80010f8:	d1e0      	bne.n	80010bc <HAL_RCC_OscConfig+0x1e8>
        tickstart = HAL_GetTick();
 80010fa:	f7ff fd35 	bl	8000b68 <HAL_GetTick>
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) != 0U)
 80010fe:	2602      	movs	r6, #2
        tickstart = HAL_GetTick();
 8001100:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) != 0U)
 8001102:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8001104:	4233      	tst	r3, r6
 8001106:	d100      	bne.n	800110a <HAL_RCC_OscConfig+0x236>
 8001108:	e6f8      	b.n	8000efc <HAL_RCC_OscConfig+0x28>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800110a:	f7ff fd2d 	bl	8000b68 <HAL_GetTick>
 800110e:	4b0b      	ldr	r3, [pc, #44]	@ (800113c <HAL_RCC_OscConfig+0x268>)
 8001110:	1b40      	subs	r0, r0, r5
 8001112:	4298      	cmp	r0, r3
 8001114:	d9f5      	bls.n	8001102 <HAL_RCC_OscConfig+0x22e>
 8001116:	e711      	b.n	8000f3c <HAL_RCC_OscConfig+0x68>
 8001118:	40021000 	.word	0x40021000
 800111c:	fffeffff 	.word	0xfffeffff
 8001120:	fffbffff 	.word	0xfffbffff
 8001124:	ffff80ff 	.word	0xffff80ff
 8001128:	ffffc7ff 	.word	0xffffc7ff
 800112c:	20000000 	.word	0x20000000
 8001130:	02dc6c00 	.word	0x02dc6c00
 8001134:	20000008 	.word	0x20000008
 8001138:	fffffeff 	.word	0xfffffeff
 800113c:	00001388 	.word	0x00001388

08001140 <HAL_RCC_GetSysClockFreq>:
  uint32_t sysclockfreq;
#if defined(RCC_CR_SYSDIV)
  uint32_t sysclockdiv = (uint32_t)(((RCC->CR & RCC_CR_SYSDIV) >> RCC_CR_SYSDIV_Pos) + 1U);
#endif /* RCC_CR_SYSDIV */

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8001140:	2238      	movs	r2, #56	@ 0x38
 8001142:	4b0f      	ldr	r3, [pc, #60]	@ (8001180 <HAL_RCC_GetSysClockFreq+0x40>)
 8001144:	6899      	ldr	r1, [r3, #8]
 8001146:	4211      	tst	r1, r2
 8001148:	d105      	bne.n	8001156 <HAL_RCC_GetSysClockFreq+0x16>
  {
    /* HSISYS can be derived for HSI48 */
    hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 800114a:	681b      	ldr	r3, [r3, #0]

    /* HSI used as system clock source */
    sysclockfreq = (HSI_VALUE / hsidiv);
 800114c:	480d      	ldr	r0, [pc, #52]	@ (8001184 <HAL_RCC_GetSysClockFreq+0x44>)
    hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 800114e:	049b      	lsls	r3, r3, #18
 8001150:	0f5b      	lsrs	r3, r3, #29
    sysclockfreq = (HSI_VALUE / hsidiv);
 8001152:	40d8      	lsrs	r0, r3
  }
#if defined(RCC_CR_SYSDIV)
  sysclockfreq = sysclockfreq / sysclockdiv;
#endif /* RCC_CR_SYSDIV */
  return sysclockfreq;
}
 8001154:	4770      	bx	lr
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8001156:	6899      	ldr	r1, [r3, #8]
 8001158:	4011      	ands	r1, r2
 800115a:	2908      	cmp	r1, #8
 800115c:	d00b      	beq.n	8001176 <HAL_RCC_GetSysClockFreq+0x36>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 800115e:	6899      	ldr	r1, [r3, #8]
 8001160:	4011      	ands	r1, r2
 8001162:	2920      	cmp	r1, #32
 8001164:	d009      	beq.n	800117a <HAL_RCC_GetSysClockFreq+0x3a>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8001166:	689b      	ldr	r3, [r3, #8]
    sysclockfreq = 0U;
 8001168:	2000      	movs	r0, #0
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 800116a:	4013      	ands	r3, r2
 800116c:	2b18      	cmp	r3, #24
 800116e:	d1f1      	bne.n	8001154 <HAL_RCC_GetSysClockFreq+0x14>
    sysclockfreq = LSI_VALUE;
 8001170:	20fa      	movs	r0, #250	@ 0xfa
 8001172:	01c0      	lsls	r0, r0, #7
 8001174:	e7ee      	b.n	8001154 <HAL_RCC_GetSysClockFreq+0x14>
    sysclockfreq = HSE_VALUE;
 8001176:	4803      	ldr	r0, [pc, #12]	@ (8001184 <HAL_RCC_GetSysClockFreq+0x44>)
 8001178:	e7ec      	b.n	8001154 <HAL_RCC_GetSysClockFreq+0x14>
    sysclockfreq = LSE_VALUE;
 800117a:	2080      	movs	r0, #128	@ 0x80
 800117c:	0200      	lsls	r0, r0, #8
 800117e:	e7e9      	b.n	8001154 <HAL_RCC_GetSysClockFreq+0x14>
 8001180:	40021000 	.word	0x40021000
 8001184:	02dc6c00 	.word	0x02dc6c00

08001188 <HAL_RCC_ClockConfig>:
{
 8001188:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800118a:	0004      	movs	r4, r0
 800118c:	000d      	movs	r5, r1
  if (RCC_ClkInitStruct == NULL)
 800118e:	2800      	cmp	r0, #0
 8001190:	d101      	bne.n	8001196 <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 8001192:	2001      	movs	r0, #1
}
 8001194:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001196:	2707      	movs	r7, #7
 8001198:	4e48      	ldr	r6, [pc, #288]	@ (80012bc <HAL_RCC_ClockConfig+0x134>)
 800119a:	6833      	ldr	r3, [r6, #0]
 800119c:	403b      	ands	r3, r7
 800119e:	428b      	cmp	r3, r1
 80011a0:	d32a      	bcc.n	80011f8 <HAL_RCC_ClockConfig+0x70>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80011a2:	6822      	ldr	r2, [r4, #0]
 80011a4:	0793      	lsls	r3, r2, #30
 80011a6:	d43b      	bmi.n	8001220 <HAL_RCC_ClockConfig+0x98>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80011a8:	07d2      	lsls	r2, r2, #31
 80011aa:	d44a      	bmi.n	8001242 <HAL_RCC_ClockConfig+0xba>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80011ac:	2707      	movs	r7, #7
 80011ae:	6833      	ldr	r3, [r6, #0]
 80011b0:	403b      	ands	r3, r7
 80011b2:	42ab      	cmp	r3, r5
 80011b4:	d90a      	bls.n	80011cc <HAL_RCC_ClockConfig+0x44>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80011b6:	6833      	ldr	r3, [r6, #0]
 80011b8:	43bb      	bics	r3, r7
 80011ba:	432b      	orrs	r3, r5
 80011bc:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 80011be:	f7ff fcd3 	bl	8000b68 <HAL_GetTick>
 80011c2:	9001      	str	r0, [sp, #4]
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80011c4:	6833      	ldr	r3, [r6, #0]
 80011c6:	403b      	ands	r3, r7
 80011c8:	42ab      	cmp	r3, r5
 80011ca:	d167      	bne.n	800129c <HAL_RCC_ClockConfig+0x114>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80011cc:	6823      	ldr	r3, [r4, #0]
 80011ce:	4d3c      	ldr	r5, [pc, #240]	@ (80012c0 <HAL_RCC_ClockConfig+0x138>)
 80011d0:	075b      	lsls	r3, r3, #29
 80011d2:	d46b      	bmi.n	80012ac <HAL_RCC_ClockConfig+0x124>
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80011d4:	f7ff ffb4 	bl	8001140 <HAL_RCC_GetSysClockFreq>
 80011d8:	68ab      	ldr	r3, [r5, #8]
 80011da:	493a      	ldr	r1, [pc, #232]	@ (80012c4 <HAL_RCC_ClockConfig+0x13c>)
                                                                  >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 80011dc:	051b      	lsls	r3, r3, #20
 80011de:	0f1b      	lsrs	r3, r3, #28
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80011e0:	009b      	lsls	r3, r3, #2
                                                                  >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 80011e2:	585b      	ldr	r3, [r3, r1]
 80011e4:	211f      	movs	r1, #31
 80011e6:	400b      	ands	r3, r1
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80011e8:	40d8      	lsrs	r0, r3
 80011ea:	4a37      	ldr	r2, [pc, #220]	@ (80012c8 <HAL_RCC_ClockConfig+0x140>)
  return HAL_InitTick(uwTickPrio);
 80011ec:	4b37      	ldr	r3, [pc, #220]	@ (80012cc <HAL_RCC_ClockConfig+0x144>)
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80011ee:	6010      	str	r0, [r2, #0]
  return HAL_InitTick(uwTickPrio);
 80011f0:	6818      	ldr	r0, [r3, #0]
 80011f2:	f7ff fb33 	bl	800085c <HAL_InitTick>
 80011f6:	e7cd      	b.n	8001194 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80011f8:	6833      	ldr	r3, [r6, #0]
 80011fa:	43bb      	bics	r3, r7
 80011fc:	430b      	orrs	r3, r1
 80011fe:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8001200:	f7ff fcb2 	bl	8000b68 <HAL_GetTick>
 8001204:	9001      	str	r0, [sp, #4]
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001206:	6833      	ldr	r3, [r6, #0]
 8001208:	403b      	ands	r3, r7
 800120a:	42ab      	cmp	r3, r5
 800120c:	d0c9      	beq.n	80011a2 <HAL_RCC_ClockConfig+0x1a>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800120e:	f7ff fcab 	bl	8000b68 <HAL_GetTick>
 8001212:	9b01      	ldr	r3, [sp, #4]
 8001214:	1ac0      	subs	r0, r0, r3
 8001216:	4b2e      	ldr	r3, [pc, #184]	@ (80012d0 <HAL_RCC_ClockConfig+0x148>)
 8001218:	4298      	cmp	r0, r3
 800121a:	d9f4      	bls.n	8001206 <HAL_RCC_ClockConfig+0x7e>
        return HAL_TIMEOUT;
 800121c:	2003      	movs	r0, #3
 800121e:	e7b9      	b.n	8001194 <HAL_RCC_ClockConfig+0xc>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001220:	4927      	ldr	r1, [pc, #156]	@ (80012c0 <HAL_RCC_ClockConfig+0x138>)
 8001222:	0753      	lsls	r3, r2, #29
 8001224:	d506      	bpl.n	8001234 <HAL_RCC_ClockConfig+0xac>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 8001226:	6888      	ldr	r0, [r1, #8]
 8001228:	4b2a      	ldr	r3, [pc, #168]	@ (80012d4 <HAL_RCC_ClockConfig+0x14c>)
 800122a:	4018      	ands	r0, r3
 800122c:	23b0      	movs	r3, #176	@ 0xb0
 800122e:	011b      	lsls	r3, r3, #4
 8001230:	4303      	orrs	r3, r0
 8001232:	608b      	str	r3, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001234:	688b      	ldr	r3, [r1, #8]
 8001236:	4828      	ldr	r0, [pc, #160]	@ (80012d8 <HAL_RCC_ClockConfig+0x150>)
 8001238:	4003      	ands	r3, r0
 800123a:	68e0      	ldr	r0, [r4, #12]
 800123c:	4303      	orrs	r3, r0
 800123e:	608b      	str	r3, [r1, #8]
 8001240:	e7b2      	b.n	80011a8 <HAL_RCC_ClockConfig+0x20>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001242:	6862      	ldr	r2, [r4, #4]
 8001244:	4f1e      	ldr	r7, [pc, #120]	@ (80012c0 <HAL_RCC_ClockConfig+0x138>)
 8001246:	2a01      	cmp	r2, #1
 8001248:	d119      	bne.n	800127e <HAL_RCC_ClockConfig+0xf6>
      if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800124a:	683b      	ldr	r3, [r7, #0]
 800124c:	039b      	lsls	r3, r3, #14
 800124e:	d5a0      	bpl.n	8001192 <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001250:	2107      	movs	r1, #7
 8001252:	68bb      	ldr	r3, [r7, #8]
 8001254:	438b      	bics	r3, r1
 8001256:	4313      	orrs	r3, r2
 8001258:	60bb      	str	r3, [r7, #8]
    tickstart = HAL_GetTick();
 800125a:	f7ff fc85 	bl	8000b68 <HAL_GetTick>
 800125e:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001260:	2338      	movs	r3, #56	@ 0x38
 8001262:	68ba      	ldr	r2, [r7, #8]
 8001264:	401a      	ands	r2, r3
 8001266:	6863      	ldr	r3, [r4, #4]
 8001268:	00db      	lsls	r3, r3, #3
 800126a:	429a      	cmp	r2, r3
 800126c:	d09e      	beq.n	80011ac <HAL_RCC_ClockConfig+0x24>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800126e:	f7ff fc7b 	bl	8000b68 <HAL_GetTick>
 8001272:	9b01      	ldr	r3, [sp, #4]
 8001274:	1ac0      	subs	r0, r0, r3
 8001276:	4b16      	ldr	r3, [pc, #88]	@ (80012d0 <HAL_RCC_ClockConfig+0x148>)
 8001278:	4298      	cmp	r0, r3
 800127a:	d9f1      	bls.n	8001260 <HAL_RCC_ClockConfig+0xd8>
 800127c:	e7ce      	b.n	800121c <HAL_RCC_ClockConfig+0x94>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800127e:	2a00      	cmp	r2, #0
 8001280:	d103      	bne.n	800128a <HAL_RCC_ClockConfig+0x102>
      if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8001282:	683b      	ldr	r3, [r7, #0]
 8001284:	055b      	lsls	r3, r3, #21
 8001286:	d4e3      	bmi.n	8001250 <HAL_RCC_ClockConfig+0xc8>
 8001288:	e783      	b.n	8001192 <HAL_RCC_ClockConfig+0xa>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_LSI)
 800128a:	2302      	movs	r3, #2
 800128c:	2a03      	cmp	r2, #3
 800128e:	d103      	bne.n	8001298 <HAL_RCC_ClockConfig+0x110>
      if (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) == 0U)
 8001290:	6e39      	ldr	r1, [r7, #96]	@ 0x60
      if (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == 0U)
 8001292:	4219      	tst	r1, r3
 8001294:	d1dc      	bne.n	8001250 <HAL_RCC_ClockConfig+0xc8>
 8001296:	e77c      	b.n	8001192 <HAL_RCC_ClockConfig+0xa>
 8001298:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 800129a:	e7fa      	b.n	8001292 <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
 800129c:	f7ff fc64 	bl	8000b68 <HAL_GetTick>
 80012a0:	9b01      	ldr	r3, [sp, #4]
 80012a2:	1ac0      	subs	r0, r0, r3
 80012a4:	4b0a      	ldr	r3, [pc, #40]	@ (80012d0 <HAL_RCC_ClockConfig+0x148>)
 80012a6:	4298      	cmp	r0, r3
 80012a8:	d98c      	bls.n	80011c4 <HAL_RCC_ClockConfig+0x3c>
 80012aa:	e7b7      	b.n	800121c <HAL_RCC_ClockConfig+0x94>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 80012ac:	68ab      	ldr	r3, [r5, #8]
 80012ae:	4a0b      	ldr	r2, [pc, #44]	@ (80012dc <HAL_RCC_ClockConfig+0x154>)
 80012b0:	4013      	ands	r3, r2
 80012b2:	6922      	ldr	r2, [r4, #16]
 80012b4:	4313      	orrs	r3, r2
 80012b6:	60ab      	str	r3, [r5, #8]
 80012b8:	e78c      	b.n	80011d4 <HAL_RCC_ClockConfig+0x4c>
 80012ba:	46c0      	nop			@ (mov r8, r8)
 80012bc:	40022000 	.word	0x40022000
 80012c0:	40021000 	.word	0x40021000
 80012c4:	080049c8 	.word	0x080049c8
 80012c8:	20000000 	.word	0x20000000
 80012cc:	20000008 	.word	0x20000008
 80012d0:	00001388 	.word	0x00001388
 80012d4:	ffff84ff 	.word	0xffff84ff
 80012d8:	fffff0ff 	.word	0xfffff0ff
 80012dc:	ffff8fff 	.word	0xffff8fff

080012e0 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80012e0:	b510      	push	{r4, lr}
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80012e2:	f7ff ff2d 	bl	8001140 <HAL_RCC_GetSysClockFreq>
 80012e6:	4b06      	ldr	r3, [pc, #24]	@ (8001300 <HAL_RCC_GetHCLKFreq+0x20>)
 80012e8:	4a06      	ldr	r2, [pc, #24]	@ (8001304 <HAL_RCC_GetHCLKFreq+0x24>)
 80012ea:	689b      	ldr	r3, [r3, #8]
                                                                  >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 80012ec:	051b      	lsls	r3, r3, #20
 80012ee:	0f1b      	lsrs	r3, r3, #28
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80012f0:	009b      	lsls	r3, r3, #2
                                                                  >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 80012f2:	589b      	ldr	r3, [r3, r2]
 80012f4:	221f      	movs	r2, #31
 80012f6:	4013      	ands	r3, r2
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) \
 80012f8:	40d8      	lsrs	r0, r3
 80012fa:	4b03      	ldr	r3, [pc, #12]	@ (8001308 <HAL_RCC_GetHCLKFreq+0x28>)
 80012fc:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 80012fe:	bd10      	pop	{r4, pc}
 8001300:	40021000 	.word	0x40021000
 8001304:	080049c8 	.word	0x080049c8
 8001308:	20000000 	.word	0x20000000

0800130c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800130c:	b510      	push	{r4, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_Pos]) & 0x1FU));
 800130e:	f7ff ffe7 	bl	80012e0 <HAL_RCC_GetHCLKFreq>
 8001312:	4b05      	ldr	r3, [pc, #20]	@ (8001328 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8001314:	4a05      	ldr	r2, [pc, #20]	@ (800132c <HAL_RCC_GetPCLK1Freq+0x20>)
 8001316:	689b      	ldr	r3, [r3, #8]
 8001318:	045b      	lsls	r3, r3, #17
 800131a:	0f5b      	lsrs	r3, r3, #29
 800131c:	009b      	lsls	r3, r3, #2
 800131e:	589b      	ldr	r3, [r3, r2]
 8001320:	221f      	movs	r2, #31
 8001322:	4013      	ands	r3, r2
 8001324:	40d8      	lsrs	r0, r3
}
 8001326:	bd10      	pop	{r4, pc}
 8001328:	40021000 	.word	0x40021000
 800132c:	080049a8 	.word	0x080049a8

08001330 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8001330:	2207      	movs	r2, #7

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001332:	4b0b      	ldr	r3, [pc, #44]	@ (8001360 <HAL_RCC_GetClockConfig+0x30>)
{
 8001334:	b530      	push	{r4, r5, lr}
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8001336:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001338:	689c      	ldr	r4, [r3, #8]
#else
  RCC_ClkInitStruct->SYSCLKDivider = RCC_SYSCLK_DIV1;
#endif /* RCC_CR_SYSDIV */

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 800133a:	25f0      	movs	r5, #240	@ 0xf0
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800133c:	4014      	ands	r4, r2
 800133e:	6044      	str	r4, [r0, #4]
  RCC_ClkInitStruct->SYSCLKDivider = RCC_SYSCLK_DIV1;
 8001340:	2400      	movs	r4, #0
 8001342:	6084      	str	r4, [r0, #8]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8001344:	689c      	ldr	r4, [r3, #8]
 8001346:	012d      	lsls	r5, r5, #4
 8001348:	402c      	ands	r4, r5
 800134a:	60c4      	str	r4, [r0, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);
 800134c:	24e0      	movs	r4, #224	@ 0xe0
 800134e:	689b      	ldr	r3, [r3, #8]
 8001350:	01e4      	lsls	r4, r4, #7
 8001352:	4023      	ands	r3, r4
 8001354:	6103      	str	r3, [r0, #16]


  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001356:	4b03      	ldr	r3, [pc, #12]	@ (8001364 <HAL_RCC_GetClockConfig+0x34>)
 8001358:	681b      	ldr	r3, [r3, #0]
 800135a:	4013      	ands	r3, r2
 800135c:	600b      	str	r3, [r1, #0]
}
 800135e:	bd30      	pop	{r4, r5, pc}
 8001360:	40021000 	.word	0x40021000
 8001364:	40022000 	.word	0x40022000

08001368 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8001368:	b570      	push	{r4, r5, r6, lr}

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800136a:	2401      	movs	r4, #1
  tmpccer = TIMx->CCER;
 800136c:	6a03      	ldr	r3, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800136e:	6a02      	ldr	r2, [r0, #32]
 8001370:	43a2      	bics	r2, r4
 8001372:	6202      	str	r2, [r0, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8001374:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8001376:	4a12      	ldr	r2, [pc, #72]	@ (80013c0 <TIM_OC1_SetConfig+0x58>)
  tmpccmrx = TIMx->CCMR1;
 8001378:	6985      	ldr	r5, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800137a:	4015      	ands	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800137c:	680a      	ldr	r2, [r1, #0]
 800137e:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8001380:	2202      	movs	r2, #2
 8001382:	4393      	bics	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8001384:	688a      	ldr	r2, [r1, #8]
 8001386:	4313      	orrs	r3, r2

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8001388:	4a0e      	ldr	r2, [pc, #56]	@ (80013c4 <TIM_OC1_SetConfig+0x5c>)
 800138a:	4290      	cmp	r0, r2
 800138c:	d005      	beq.n	800139a <TIM_OC1_SetConfig+0x32>
 800138e:	4a0e      	ldr	r2, [pc, #56]	@ (80013c8 <TIM_OC1_SetConfig+0x60>)
 8001390:	4290      	cmp	r0, r2
 8001392:	d002      	beq.n	800139a <TIM_OC1_SetConfig+0x32>
 8001394:	4a0d      	ldr	r2, [pc, #52]	@ (80013cc <TIM_OC1_SetConfig+0x64>)
 8001396:	4290      	cmp	r0, r2
 8001398:	d10b      	bne.n	80013b2 <TIM_OC1_SetConfig+0x4a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 800139a:	2208      	movs	r2, #8
 800139c:	4393      	bics	r3, r2
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800139e:	68ca      	ldr	r2, [r1, #12]
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 80013a0:	698e      	ldr	r6, [r1, #24]
    tmpccer |= OC_Config->OCNPolarity;
 80013a2:	4313      	orrs	r3, r2
    tmpccer &= ~TIM_CCER_CC1NE;
 80013a4:	2204      	movs	r2, #4
 80013a6:	4393      	bics	r3, r2
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80013a8:	4a09      	ldr	r2, [pc, #36]	@ (80013d0 <TIM_OC1_SetConfig+0x68>)
 80013aa:	4022      	ands	r2, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 80013ac:	694c      	ldr	r4, [r1, #20]
 80013ae:	4334      	orrs	r4, r6
 80013b0:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 80013b2:	684a      	ldr	r2, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80013b4:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 80013b6:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 80013b8:	6342      	str	r2, [r0, #52]	@ 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80013ba:	6203      	str	r3, [r0, #32]
}
 80013bc:	bd70      	pop	{r4, r5, r6, pc}
 80013be:	46c0      	nop			@ (mov r8, r8)
 80013c0:	fffeff8c 	.word	0xfffeff8c
 80013c4:	40012c00 	.word	0x40012c00
 80013c8:	40014400 	.word	0x40014400
 80013cc:	40014800 	.word	0x40014800
 80013d0:	fffffcff 	.word	0xfffffcff

080013d4 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 80013d4:	b570      	push	{r4, r5, r6, lr}

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80013d6:	4a17      	ldr	r2, [pc, #92]	@ (8001434 <TIM_OC3_SetConfig+0x60>)
  tmpccer = TIMx->CCER;
 80013d8:	6a05      	ldr	r5, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80013da:	6a03      	ldr	r3, [r0, #32]
 80013dc:	4013      	ands	r3, r2
 80013de:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80013e0:	6842      	ldr	r2, [r0, #4]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 80013e2:	4b15      	ldr	r3, [pc, #84]	@ (8001438 <TIM_OC3_SetConfig+0x64>)
  tmpccmrx = TIMx->CCMR2;
 80013e4:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 80013e6:	401c      	ands	r4, r3
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80013e8:	680b      	ldr	r3, [r1, #0]
 80013ea:	431c      	orrs	r4, r3

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 80013ec:	4b13      	ldr	r3, [pc, #76]	@ (800143c <TIM_OC3_SetConfig+0x68>)
 80013ee:	401d      	ands	r5, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80013f0:	688b      	ldr	r3, [r1, #8]
 80013f2:	021b      	lsls	r3, r3, #8
 80013f4:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 80013f6:	4d12      	ldr	r5, [pc, #72]	@ (8001440 <TIM_OC3_SetConfig+0x6c>)
 80013f8:	42a8      	cmp	r0, r5
 80013fa:	d10e      	bne.n	800141a <TIM_OC3_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 80013fc:	4d11      	ldr	r5, [pc, #68]	@ (8001444 <TIM_OC3_SetConfig+0x70>)
 80013fe:	401d      	ands	r5, r3
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8001400:	68cb      	ldr	r3, [r1, #12]
 8001402:	021b      	lsls	r3, r3, #8
 8001404:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8001406:	4d10      	ldr	r5, [pc, #64]	@ (8001448 <TIM_OC3_SetConfig+0x74>)
 8001408:	402b      	ands	r3, r5
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800140a:	4d10      	ldr	r5, [pc, #64]	@ (800144c <TIM_OC3_SetConfig+0x78>)
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800140c:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800140e:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8001410:	694a      	ldr	r2, [r1, #20]
 8001412:	4332      	orrs	r2, r6
 8001414:	0112      	lsls	r2, r2, #4
 8001416:	432a      	orrs	r2, r5
 8001418:	e005      	b.n	8001426 <TIM_OC3_SetConfig+0x52>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800141a:	4d0d      	ldr	r5, [pc, #52]	@ (8001450 <TIM_OC3_SetConfig+0x7c>)
 800141c:	42a8      	cmp	r0, r5
 800141e:	d0f4      	beq.n	800140a <TIM_OC3_SetConfig+0x36>
 8001420:	4d0c      	ldr	r5, [pc, #48]	@ (8001454 <TIM_OC3_SetConfig+0x80>)
 8001422:	42a8      	cmp	r0, r5
 8001424:	d0f1      	beq.n	800140a <TIM_OC3_SetConfig+0x36>
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001426:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8001428:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 800142a:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 800142c:	63c2      	str	r2, [r0, #60]	@ 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800142e:	6203      	str	r3, [r0, #32]
}
 8001430:	bd70      	pop	{r4, r5, r6, pc}
 8001432:	46c0      	nop			@ (mov r8, r8)
 8001434:	fffffeff 	.word	0xfffffeff
 8001438:	fffeff8c 	.word	0xfffeff8c
 800143c:	fffffdff 	.word	0xfffffdff
 8001440:	40012c00 	.word	0x40012c00
 8001444:	fffff7ff 	.word	0xfffff7ff
 8001448:	fffffbff 	.word	0xfffffbff
 800144c:	ffffcfff 	.word	0xffffcfff
 8001450:	40014400 	.word	0x40014400
 8001454:	40014800 	.word	0x40014800

08001458 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8001458:	b530      	push	{r4, r5, lr}

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800145a:	4a12      	ldr	r2, [pc, #72]	@ (80014a4 <TIM_OC4_SetConfig+0x4c>)
  tmpccer = TIMx->CCER;
 800145c:	6a04      	ldr	r4, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800145e:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8001460:	4d11      	ldr	r5, [pc, #68]	@ (80014a8 <TIM_OC4_SetConfig+0x50>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001462:	4013      	ands	r3, r2
 8001464:	6203      	str	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8001466:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8001468:	69c2      	ldr	r2, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800146a:	402a      	ands	r2, r5

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800146c:	680d      	ldr	r5, [r1, #0]
 800146e:	022d      	lsls	r5, r5, #8
 8001470:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8001472:	4a0e      	ldr	r2, [pc, #56]	@ (80014ac <TIM_OC4_SetConfig+0x54>)
 8001474:	4014      	ands	r4, r2
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8001476:	688a      	ldr	r2, [r1, #8]
 8001478:	0312      	lsls	r2, r2, #12
 800147a:	4322      	orrs	r2, r4

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800147c:	4c0c      	ldr	r4, [pc, #48]	@ (80014b0 <TIM_OC4_SetConfig+0x58>)
 800147e:	42a0      	cmp	r0, r4
 8001480:	d005      	beq.n	800148e <TIM_OC4_SetConfig+0x36>
 8001482:	4c0c      	ldr	r4, [pc, #48]	@ (80014b4 <TIM_OC4_SetConfig+0x5c>)
 8001484:	42a0      	cmp	r0, r4
 8001486:	d002      	beq.n	800148e <TIM_OC4_SetConfig+0x36>
 8001488:	4c0b      	ldr	r4, [pc, #44]	@ (80014b8 <TIM_OC4_SetConfig+0x60>)
 800148a:	42a0      	cmp	r0, r4
 800148c:	d104      	bne.n	8001498 <TIM_OC4_SetConfig+0x40>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 800148e:	4c0b      	ldr	r4, [pc, #44]	@ (80014bc <TIM_OC4_SetConfig+0x64>)
 8001490:	401c      	ands	r4, r3

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8001492:	694b      	ldr	r3, [r1, #20]
 8001494:	019b      	lsls	r3, r3, #6
 8001496:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001498:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800149a:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 800149c:	61c5      	str	r5, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 800149e:	6403      	str	r3, [r0, #64]	@ 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80014a0:	6202      	str	r2, [r0, #32]
}
 80014a2:	bd30      	pop	{r4, r5, pc}
 80014a4:	ffffefff 	.word	0xffffefff
 80014a8:	feff8cff 	.word	0xfeff8cff
 80014ac:	ffffdfff 	.word	0xffffdfff
 80014b0:	40012c00 	.word	0x40012c00
 80014b4:	40014400 	.word	0x40014400
 80014b8:	40014800 	.word	0x40014800
 80014bc:	ffffbfff 	.word	0xffffbfff

080014c0 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 80014c0:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80014c2:	6a06      	ldr	r6, [r0, #32]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80014c4:	4c10      	ldr	r4, [pc, #64]	@ (8001508 <TIM_OC5_SetConfig+0x48>)
 80014c6:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80014c8:	4a10      	ldr	r2, [pc, #64]	@ (800150c <TIM_OC5_SetConfig+0x4c>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80014ca:	4023      	ands	r3, r4
 80014cc:	6203      	str	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 80014ce:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR3;
 80014d0:	6d45      	ldr	r5, [r0, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80014d2:	4015      	ands	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80014d4:	680a      	ldr	r2, [r1, #0]
 80014d6:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 80014d8:	4a0d      	ldr	r2, [pc, #52]	@ (8001510 <TIM_OC5_SetConfig+0x50>)
 80014da:	4016      	ands	r6, r2
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80014dc:	688a      	ldr	r2, [r1, #8]
 80014de:	0412      	lsls	r2, r2, #16
 80014e0:	4332      	orrs	r2, r6

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80014e2:	4e0c      	ldr	r6, [pc, #48]	@ (8001514 <TIM_OC5_SetConfig+0x54>)
 80014e4:	42b0      	cmp	r0, r6
 80014e6:	d005      	beq.n	80014f4 <TIM_OC5_SetConfig+0x34>
 80014e8:	4e0b      	ldr	r6, [pc, #44]	@ (8001518 <TIM_OC5_SetConfig+0x58>)
 80014ea:	42b0      	cmp	r0, r6
 80014ec:	d002      	beq.n	80014f4 <TIM_OC5_SetConfig+0x34>
 80014ee:	4e0b      	ldr	r6, [pc, #44]	@ (800151c <TIM_OC5_SetConfig+0x5c>)
 80014f0:	42b0      	cmp	r0, r6
 80014f2:	d103      	bne.n	80014fc <TIM_OC5_SetConfig+0x3c>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 80014f4:	401c      	ands	r4, r3
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 80014f6:	694b      	ldr	r3, [r1, #20]
 80014f8:	021b      	lsls	r3, r3, #8
 80014fa:	4323      	orrs	r3, r4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80014fc:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 80014fe:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR3 = tmpccmrx;
 8001500:	6545      	str	r5, [r0, #84]	@ 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 8001502:	6583      	str	r3, [r0, #88]	@ 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001504:	6202      	str	r2, [r0, #32]
}
 8001506:	bd70      	pop	{r4, r5, r6, pc}
 8001508:	fffeffff 	.word	0xfffeffff
 800150c:	fffeff8f 	.word	0xfffeff8f
 8001510:	fffdffff 	.word	0xfffdffff
 8001514:	40012c00 	.word	0x40012c00
 8001518:	40014400 	.word	0x40014400
 800151c:	40014800 	.word	0x40014800

08001520 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 8001520:	b530      	push	{r4, r5, lr}

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8001522:	4a12      	ldr	r2, [pc, #72]	@ (800156c <TIM_OC6_SetConfig+0x4c>)
  tmpccer = TIMx->CCER;
 8001524:	6a04      	ldr	r4, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8001526:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8001528:	4d11      	ldr	r5, [pc, #68]	@ (8001570 <TIM_OC6_SetConfig+0x50>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800152a:	4013      	ands	r3, r2
 800152c:	6203      	str	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 800152e:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR3;
 8001530:	6d42      	ldr	r2, [r0, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8001532:	402a      	ands	r2, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8001534:	680d      	ldr	r5, [r1, #0]
 8001536:	022d      	lsls	r5, r5, #8
 8001538:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800153a:	4a0e      	ldr	r2, [pc, #56]	@ (8001574 <TIM_OC6_SetConfig+0x54>)
 800153c:	4014      	ands	r4, r2
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800153e:	688a      	ldr	r2, [r1, #8]
 8001540:	0512      	lsls	r2, r2, #20
 8001542:	4322      	orrs	r2, r4

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8001544:	4c0c      	ldr	r4, [pc, #48]	@ (8001578 <TIM_OC6_SetConfig+0x58>)
 8001546:	42a0      	cmp	r0, r4
 8001548:	d005      	beq.n	8001556 <TIM_OC6_SetConfig+0x36>
 800154a:	4c0c      	ldr	r4, [pc, #48]	@ (800157c <TIM_OC6_SetConfig+0x5c>)
 800154c:	42a0      	cmp	r0, r4
 800154e:	d002      	beq.n	8001556 <TIM_OC6_SetConfig+0x36>
 8001550:	4c0b      	ldr	r4, [pc, #44]	@ (8001580 <TIM_OC6_SetConfig+0x60>)
 8001552:	42a0      	cmp	r0, r4
 8001554:	d104      	bne.n	8001560 <TIM_OC6_SetConfig+0x40>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8001556:	4c0b      	ldr	r4, [pc, #44]	@ (8001584 <TIM_OC6_SetConfig+0x64>)
 8001558:	401c      	ands	r4, r3
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800155a:	694b      	ldr	r3, [r1, #20]
 800155c:	029b      	lsls	r3, r3, #10
 800155e:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8001560:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8001562:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR3 = tmpccmrx;
 8001564:	6545      	str	r5, [r0, #84]	@ 0x54
  TIMx->CCR6 = OC_Config->Pulse;
 8001566:	65c3      	str	r3, [r0, #92]	@ 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8001568:	6202      	str	r2, [r0, #32]
}
 800156a:	bd30      	pop	{r4, r5, pc}
 800156c:	ffefffff 	.word	0xffefffff
 8001570:	feff8fff 	.word	0xfeff8fff
 8001574:	ffdfffff 	.word	0xffdfffff
 8001578:	40012c00 	.word	0x40012c00
 800157c:	40014400 	.word	0x40014400
 8001580:	40014800 	.word	0x40014800
 8001584:	fffbffff 	.word	0xfffbffff

08001588 <HAL_TIM_Base_MspInit>:
}
 8001588:	4770      	bx	lr
	...

0800158c <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 800158c:	0001      	movs	r1, r0
{
 800158e:	0003      	movs	r3, r0
    return HAL_ERROR;
 8001590:	2001      	movs	r0, #1
{
 8001592:	b510      	push	{r4, lr}
  if (htim->State != HAL_TIM_STATE_READY)
 8001594:	313d      	adds	r1, #61	@ 0x3d
 8001596:	780c      	ldrb	r4, [r1, #0]
 8001598:	b2e2      	uxtb	r2, r4
 800159a:	4284      	cmp	r4, r0
 800159c:	d118      	bne.n	80015d0 <HAL_TIM_Base_Start_IT+0x44>
  htim->State = HAL_TIM_STATE_BUSY;
 800159e:	1800      	adds	r0, r0, r0
 80015a0:	7008      	strb	r0, [r1, #0]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80015a2:	681b      	ldr	r3, [r3, #0]
 80015a4:	68d9      	ldr	r1, [r3, #12]
 80015a6:	4311      	orrs	r1, r2
 80015a8:	60d9      	str	r1, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80015aa:	490b      	ldr	r1, [pc, #44]	@ (80015d8 <HAL_TIM_Base_Start_IT+0x4c>)
 80015ac:	428b      	cmp	r3, r1
 80015ae:	d002      	beq.n	80015b6 <HAL_TIM_Base_Start_IT+0x2a>
 80015b0:	490a      	ldr	r1, [pc, #40]	@ (80015dc <HAL_TIM_Base_Start_IT+0x50>)
 80015b2:	428b      	cmp	r3, r1
 80015b4:	d10d      	bne.n	80015d2 <HAL_TIM_Base_Start_IT+0x46>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80015b6:	689a      	ldr	r2, [r3, #8]
 80015b8:	4909      	ldr	r1, [pc, #36]	@ (80015e0 <HAL_TIM_Base_Start_IT+0x54>)
 80015ba:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80015bc:	2a06      	cmp	r2, #6
 80015be:	d006      	beq.n	80015ce <HAL_TIM_Base_Start_IT+0x42>
 80015c0:	3907      	subs	r1, #7
 80015c2:	428a      	cmp	r2, r1
 80015c4:	d003      	beq.n	80015ce <HAL_TIM_Base_Start_IT+0x42>
      __HAL_TIM_ENABLE(htim);
 80015c6:	2201      	movs	r2, #1
 80015c8:	6819      	ldr	r1, [r3, #0]
 80015ca:	430a      	orrs	r2, r1
 80015cc:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80015ce:	2000      	movs	r0, #0
}
 80015d0:	bd10      	pop	{r4, pc}
    __HAL_TIM_ENABLE(htim);
 80015d2:	6819      	ldr	r1, [r3, #0]
 80015d4:	e7f9      	b.n	80015ca <HAL_TIM_Base_Start_IT+0x3e>
 80015d6:	46c0      	nop			@ (mov r8, r8)
 80015d8:	40012c00 	.word	0x40012c00
 80015dc:	40000400 	.word	0x40000400
 80015e0:	00010007 	.word	0x00010007

080015e4 <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
 80015e4:	4770      	bx	lr

080015e6 <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
 80015e6:	4770      	bx	lr

080015e8 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
 80015e8:	4770      	bx	lr
	...

080015ec <HAL_TIM_IRQHandler>:
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 80015ec:	2202      	movs	r2, #2
  uint32_t itsource = htim->Instance->DIER;
 80015ee:	6803      	ldr	r3, [r0, #0]
{
 80015f0:	b570      	push	{r4, r5, r6, lr}
  uint32_t itsource = htim->Instance->DIER;
 80015f2:	68dd      	ldr	r5, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 80015f4:	691e      	ldr	r6, [r3, #16]
{
 80015f6:	0004      	movs	r4, r0
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 80015f8:	4216      	tst	r6, r2
 80015fa:	d00d      	beq.n	8001618 <HAL_TIM_IRQHandler+0x2c>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 80015fc:	4215      	tst	r5, r2
 80015fe:	d00b      	beq.n	8001618 <HAL_TIM_IRQHandler+0x2c>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8001600:	3a05      	subs	r2, #5
 8001602:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001604:	3204      	adds	r2, #4
 8001606:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001608:	699b      	ldr	r3, [r3, #24]
 800160a:	079b      	lsls	r3, r3, #30
 800160c:	d100      	bne.n	8001610 <HAL_TIM_IRQHandler+0x24>
 800160e:	e07c      	b.n	800170a <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 8001610:	f7fe feca 	bl	80003a8 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001614:	2300      	movs	r3, #0
 8001616:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8001618:	2304      	movs	r3, #4
 800161a:	421e      	tst	r6, r3
 800161c:	d012      	beq.n	8001644 <HAL_TIM_IRQHandler+0x58>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 800161e:	421d      	tst	r5, r3
 8001620:	d010      	beq.n	8001644 <HAL_TIM_IRQHandler+0x58>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8001622:	2205      	movs	r2, #5
 8001624:	6823      	ldr	r3, [r4, #0]
 8001626:	4252      	negs	r2, r2
 8001628:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800162a:	3207      	adds	r2, #7
 800162c:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800162e:	699a      	ldr	r2, [r3, #24]
 8001630:	23c0      	movs	r3, #192	@ 0xc0
 8001632:	009b      	lsls	r3, r3, #2
        HAL_TIM_IC_CaptureCallback(htim);
 8001634:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001636:	421a      	tst	r2, r3
 8001638:	d100      	bne.n	800163c <HAL_TIM_IRQHandler+0x50>
 800163a:	e06c      	b.n	8001716 <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 800163c:	f7fe feb4 	bl	80003a8 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001640:	2300      	movs	r3, #0
 8001642:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8001644:	2308      	movs	r3, #8
 8001646:	421e      	tst	r6, r3
 8001648:	d00f      	beq.n	800166a <HAL_TIM_IRQHandler+0x7e>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 800164a:	421d      	tst	r5, r3
 800164c:	d00d      	beq.n	800166a <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 800164e:	2209      	movs	r2, #9
 8001650:	6823      	ldr	r3, [r4, #0]
 8001652:	4252      	negs	r2, r2
 8001654:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001656:	320d      	adds	r2, #13
 8001658:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800165a:	69db      	ldr	r3, [r3, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 800165c:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800165e:	079b      	lsls	r3, r3, #30
 8001660:	d05f      	beq.n	8001722 <HAL_TIM_IRQHandler+0x136>
        HAL_TIM_IC_CaptureCallback(htim);
 8001662:	f7fe fea1 	bl	80003a8 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001666:	2300      	movs	r3, #0
 8001668:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 800166a:	2310      	movs	r3, #16
 800166c:	421e      	tst	r6, r3
 800166e:	d011      	beq.n	8001694 <HAL_TIM_IRQHandler+0xa8>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8001670:	421d      	tst	r5, r3
 8001672:	d00f      	beq.n	8001694 <HAL_TIM_IRQHandler+0xa8>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8001674:	2211      	movs	r2, #17
 8001676:	6823      	ldr	r3, [r4, #0]
 8001678:	4252      	negs	r2, r2
 800167a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800167c:	3219      	adds	r2, #25
 800167e:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001680:	69da      	ldr	r2, [r3, #28]
 8001682:	23c0      	movs	r3, #192	@ 0xc0
 8001684:	009b      	lsls	r3, r3, #2
        HAL_TIM_IC_CaptureCallback(htim);
 8001686:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001688:	421a      	tst	r2, r3
 800168a:	d050      	beq.n	800172e <HAL_TIM_IRQHandler+0x142>
        HAL_TIM_IC_CaptureCallback(htim);
 800168c:	f7fe fe8c 	bl	80003a8 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001690:	2300      	movs	r3, #0
 8001692:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8001694:	2301      	movs	r3, #1
 8001696:	421e      	tst	r6, r3
 8001698:	d008      	beq.n	80016ac <HAL_TIM_IRQHandler+0xc0>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 800169a:	421d      	tst	r5, r3
 800169c:	d006      	beq.n	80016ac <HAL_TIM_IRQHandler+0xc0>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 800169e:	2202      	movs	r2, #2
 80016a0:	6823      	ldr	r3, [r4, #0]
 80016a2:	4252      	negs	r2, r2
      HAL_TIM_PeriodElapsedCallback(htim);
 80016a4:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 80016a6:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80016a8:	f7ff f80c 	bl	80006c4 <HAL_TIM_PeriodElapsedCallback>
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 80016ac:	2382      	movs	r3, #130	@ 0x82
 80016ae:	019b      	lsls	r3, r3, #6
 80016b0:	421e      	tst	r6, r3
 80016b2:	d007      	beq.n	80016c4 <HAL_TIM_IRQHandler+0xd8>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 80016b4:	062b      	lsls	r3, r5, #24
 80016b6:	d505      	bpl.n	80016c4 <HAL_TIM_IRQHandler+0xd8>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 80016b8:	6823      	ldr	r3, [r4, #0]
 80016ba:	4a20      	ldr	r2, [pc, #128]	@ (800173c <HAL_TIM_IRQHandler+0x150>)
      HAL_TIMEx_BreakCallback(htim);
 80016bc:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 80016be:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80016c0:	f000 fba3 	bl	8001e0a <HAL_TIMEx_BreakCallback>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 80016c4:	05f3      	lsls	r3, r6, #23
 80016c6:	d507      	bpl.n	80016d8 <HAL_TIM_IRQHandler+0xec>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 80016c8:	062b      	lsls	r3, r5, #24
 80016ca:	d505      	bpl.n	80016d8 <HAL_TIM_IRQHandler+0xec>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80016cc:	6823      	ldr	r3, [r4, #0]
 80016ce:	4a1c      	ldr	r2, [pc, #112]	@ (8001740 <HAL_TIM_IRQHandler+0x154>)
      HAL_TIMEx_Break2Callback(htim);
 80016d0:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80016d2:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 80016d4:	f000 fb9a 	bl	8001e0c <HAL_TIMEx_Break2Callback>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 80016d8:	2340      	movs	r3, #64	@ 0x40
 80016da:	421e      	tst	r6, r3
 80016dc:	d008      	beq.n	80016f0 <HAL_TIM_IRQHandler+0x104>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 80016de:	421d      	tst	r5, r3
 80016e0:	d006      	beq.n	80016f0 <HAL_TIM_IRQHandler+0x104>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 80016e2:	2241      	movs	r2, #65	@ 0x41
 80016e4:	6823      	ldr	r3, [r4, #0]
 80016e6:	4252      	negs	r2, r2
      HAL_TIM_TriggerCallback(htim);
 80016e8:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 80016ea:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80016ec:	f7ff ff7c 	bl	80015e8 <HAL_TIM_TriggerCallback>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 80016f0:	2320      	movs	r3, #32
 80016f2:	421e      	tst	r6, r3
 80016f4:	d008      	beq.n	8001708 <HAL_TIM_IRQHandler+0x11c>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 80016f6:	421d      	tst	r5, r3
 80016f8:	d006      	beq.n	8001708 <HAL_TIM_IRQHandler+0x11c>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 80016fa:	2221      	movs	r2, #33	@ 0x21
 80016fc:	6823      	ldr	r3, [r4, #0]
 80016fe:	4252      	negs	r2, r2
      HAL_TIMEx_CommutCallback(htim);
 8001700:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8001702:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8001704:	f000 fb80 	bl	8001e08 <HAL_TIMEx_CommutCallback>
}
 8001708:	bd70      	pop	{r4, r5, r6, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800170a:	f7ff ff6b 	bl	80015e4 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800170e:	0020      	movs	r0, r4
 8001710:	f7ff ff69 	bl	80015e6 <HAL_TIM_PWM_PulseFinishedCallback>
 8001714:	e77e      	b.n	8001614 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001716:	f7ff ff65 	bl	80015e4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800171a:	0020      	movs	r0, r4
 800171c:	f7ff ff63 	bl	80015e6 <HAL_TIM_PWM_PulseFinishedCallback>
 8001720:	e78e      	b.n	8001640 <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001722:	f7ff ff5f 	bl	80015e4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001726:	0020      	movs	r0, r4
 8001728:	f7ff ff5d 	bl	80015e6 <HAL_TIM_PWM_PulseFinishedCallback>
 800172c:	e79b      	b.n	8001666 <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800172e:	f7ff ff59 	bl	80015e4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001732:	0020      	movs	r0, r4
 8001734:	f7ff ff57 	bl	80015e6 <HAL_TIM_PWM_PulseFinishedCallback>
 8001738:	e7aa      	b.n	8001690 <HAL_TIM_IRQHandler+0xa4>
 800173a:	46c0      	nop			@ (mov r8, r8)
 800173c:	ffffdf7f 	.word	0xffffdf7f
 8001740:	fffffeff 	.word	0xfffffeff

08001744 <TIM_Base_SetConfig>:
{
 8001744:	b510      	push	{r4, lr}
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001746:	4c1a      	ldr	r4, [pc, #104]	@ (80017b0 <TIM_Base_SetConfig+0x6c>)
  tmpcr1 = TIMx->CR1;
 8001748:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800174a:	42a0      	cmp	r0, r4
 800174c:	d00a      	beq.n	8001764 <TIM_Base_SetConfig+0x20>
 800174e:	4a19      	ldr	r2, [pc, #100]	@ (80017b4 <TIM_Base_SetConfig+0x70>)
 8001750:	4290      	cmp	r0, r2
 8001752:	d007      	beq.n	8001764 <TIM_Base_SetConfig+0x20>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001754:	4a18      	ldr	r2, [pc, #96]	@ (80017b8 <TIM_Base_SetConfig+0x74>)
 8001756:	4290      	cmp	r0, r2
 8001758:	d109      	bne.n	800176e <TIM_Base_SetConfig+0x2a>
    tmpcr1 &= ~TIM_CR1_CKD;
 800175a:	4a18      	ldr	r2, [pc, #96]	@ (80017bc <TIM_Base_SetConfig+0x78>)
 800175c:	401a      	ands	r2, r3
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800175e:	68cb      	ldr	r3, [r1, #12]
 8001760:	4313      	orrs	r3, r2
 8001762:	e00a      	b.n	800177a <TIM_Base_SetConfig+0x36>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001764:	2270      	movs	r2, #112	@ 0x70
 8001766:	4393      	bics	r3, r2
    tmpcr1 |= Structure->CounterMode;
 8001768:	684a      	ldr	r2, [r1, #4]
 800176a:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800176c:	e7f5      	b.n	800175a <TIM_Base_SetConfig+0x16>
 800176e:	4a14      	ldr	r2, [pc, #80]	@ (80017c0 <TIM_Base_SetConfig+0x7c>)
 8001770:	4290      	cmp	r0, r2
 8001772:	d0f2      	beq.n	800175a <TIM_Base_SetConfig+0x16>
 8001774:	4a13      	ldr	r2, [pc, #76]	@ (80017c4 <TIM_Base_SetConfig+0x80>)
 8001776:	4290      	cmp	r0, r2
 8001778:	d0ef      	beq.n	800175a <TIM_Base_SetConfig+0x16>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800177a:	2280      	movs	r2, #128	@ 0x80
 800177c:	4393      	bics	r3, r2
 800177e:	694a      	ldr	r2, [r1, #20]
 8001780:	4313      	orrs	r3, r2
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001782:	688a      	ldr	r2, [r1, #8]
 8001784:	62c2      	str	r2, [r0, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8001786:	680a      	ldr	r2, [r1, #0]
 8001788:	6282      	str	r2, [r0, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800178a:	42a0      	cmp	r0, r4
 800178c:	d005      	beq.n	800179a <TIM_Base_SetConfig+0x56>
 800178e:	4a0c      	ldr	r2, [pc, #48]	@ (80017c0 <TIM_Base_SetConfig+0x7c>)
 8001790:	4290      	cmp	r0, r2
 8001792:	d002      	beq.n	800179a <TIM_Base_SetConfig+0x56>
 8001794:	4a0b      	ldr	r2, [pc, #44]	@ (80017c4 <TIM_Base_SetConfig+0x80>)
 8001796:	4290      	cmp	r0, r2
 8001798:	d101      	bne.n	800179e <TIM_Base_SetConfig+0x5a>
    TIMx->RCR = Structure->RepetitionCounter;
 800179a:	690a      	ldr	r2, [r1, #16]
 800179c:	6302      	str	r2, [r0, #48]	@ 0x30
  SET_BIT(TIMx->CR1, TIM_CR1_URS);
 800179e:	2204      	movs	r2, #4
 80017a0:	6801      	ldr	r1, [r0, #0]
 80017a2:	430a      	orrs	r2, r1
 80017a4:	6002      	str	r2, [r0, #0]
  TIMx->EGR = TIM_EGR_UG;
 80017a6:	2201      	movs	r2, #1
 80017a8:	6142      	str	r2, [r0, #20]
  TIMx->CR1 = tmpcr1;
 80017aa:	6003      	str	r3, [r0, #0]
}
 80017ac:	bd10      	pop	{r4, pc}
 80017ae:	46c0      	nop			@ (mov r8, r8)
 80017b0:	40012c00 	.word	0x40012c00
 80017b4:	40000400 	.word	0x40000400
 80017b8:	40002000 	.word	0x40002000
 80017bc:	fffffcff 	.word	0xfffffcff
 80017c0:	40014400 	.word	0x40014400
 80017c4:	40014800 	.word	0x40014800

080017c8 <HAL_TIM_Base_Init>:
{
 80017c8:	b570      	push	{r4, r5, r6, lr}
 80017ca:	0004      	movs	r4, r0
    return HAL_ERROR;
 80017cc:	2001      	movs	r0, #1
  if (htim == NULL)
 80017ce:	2c00      	cmp	r4, #0
 80017d0:	d023      	beq.n	800181a <HAL_TIM_Base_Init+0x52>
  if (htim->State == HAL_TIM_STATE_RESET)
 80017d2:	0025      	movs	r5, r4
 80017d4:	353d      	adds	r5, #61	@ 0x3d
 80017d6:	782b      	ldrb	r3, [r5, #0]
 80017d8:	b2da      	uxtb	r2, r3
 80017da:	2b00      	cmp	r3, #0
 80017dc:	d105      	bne.n	80017ea <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 80017de:	0023      	movs	r3, r4
 80017e0:	333c      	adds	r3, #60	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 80017e2:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 80017e4:	701a      	strb	r2, [r3, #0]
    HAL_TIM_Base_MspInit(htim);
 80017e6:	f7ff fecf 	bl	8001588 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 80017ea:	2302      	movs	r3, #2
 80017ec:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80017ee:	6820      	ldr	r0, [r4, #0]
 80017f0:	1d21      	adds	r1, r4, #4
 80017f2:	f7ff ffa7 	bl	8001744 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80017f6:	0022      	movs	r2, r4
 80017f8:	2301      	movs	r3, #1
  return HAL_OK;
 80017fa:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80017fc:	3248      	adds	r2, #72	@ 0x48
 80017fe:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001800:	3447      	adds	r4, #71	@ 0x47
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001802:	3a0a      	subs	r2, #10
 8001804:	7013      	strb	r3, [r2, #0]
 8001806:	7053      	strb	r3, [r2, #1]
 8001808:	7093      	strb	r3, [r2, #2]
 800180a:	70d3      	strb	r3, [r2, #3]
 800180c:	7113      	strb	r3, [r2, #4]
 800180e:	7153      	strb	r3, [r2, #5]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001810:	7193      	strb	r3, [r2, #6]
 8001812:	71d3      	strb	r3, [r2, #7]
 8001814:	7213      	strb	r3, [r2, #8]
 8001816:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 8001818:	702b      	strb	r3, [r5, #0]
}
 800181a:	bd70      	pop	{r4, r5, r6, pc}

0800181c <HAL_TIM_PWM_Init>:
{
 800181c:	b570      	push	{r4, r5, r6, lr}
 800181e:	0004      	movs	r4, r0
    return HAL_ERROR;
 8001820:	2001      	movs	r0, #1
  if (htim == NULL)
 8001822:	2c00      	cmp	r4, #0
 8001824:	d023      	beq.n	800186e <HAL_TIM_PWM_Init+0x52>
  if (htim->State == HAL_TIM_STATE_RESET)
 8001826:	0025      	movs	r5, r4
 8001828:	353d      	adds	r5, #61	@ 0x3d
 800182a:	782b      	ldrb	r3, [r5, #0]
 800182c:	b2da      	uxtb	r2, r3
 800182e:	2b00      	cmp	r3, #0
 8001830:	d105      	bne.n	800183e <HAL_TIM_PWM_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8001832:	0023      	movs	r3, r4
 8001834:	333c      	adds	r3, #60	@ 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8001836:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 8001838:	701a      	strb	r2, [r3, #0]
    HAL_TIM_PWM_MspInit(htim);
 800183a:	f7fe ff9f 	bl	800077c <HAL_TIM_PWM_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 800183e:	2302      	movs	r3, #2
 8001840:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001842:	6820      	ldr	r0, [r4, #0]
 8001844:	1d21      	adds	r1, r4, #4
 8001846:	f7ff ff7d 	bl	8001744 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800184a:	0022      	movs	r2, r4
 800184c:	2301      	movs	r3, #1
  return HAL_OK;
 800184e:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001850:	3248      	adds	r2, #72	@ 0x48
 8001852:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001854:	3447      	adds	r4, #71	@ 0x47
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001856:	3a0a      	subs	r2, #10
 8001858:	7013      	strb	r3, [r2, #0]
 800185a:	7053      	strb	r3, [r2, #1]
 800185c:	7093      	strb	r3, [r2, #2]
 800185e:	70d3      	strb	r3, [r2, #3]
 8001860:	7113      	strb	r3, [r2, #4]
 8001862:	7153      	strb	r3, [r2, #5]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001864:	7193      	strb	r3, [r2, #6]
 8001866:	71d3      	strb	r3, [r2, #7]
 8001868:	7213      	strb	r3, [r2, #8]
 800186a:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 800186c:	702b      	strb	r3, [r5, #0]
}
 800186e:	bd70      	pop	{r4, r5, r6, pc}

08001870 <HAL_TIM_IC_Init>:
{
 8001870:	b570      	push	{r4, r5, r6, lr}
 8001872:	0004      	movs	r4, r0
    return HAL_ERROR;
 8001874:	2001      	movs	r0, #1
  if (htim == NULL)
 8001876:	2c00      	cmp	r4, #0
 8001878:	d023      	beq.n	80018c2 <HAL_TIM_IC_Init+0x52>
  if (htim->State == HAL_TIM_STATE_RESET)
 800187a:	0025      	movs	r5, r4
 800187c:	353d      	adds	r5, #61	@ 0x3d
 800187e:	782b      	ldrb	r3, [r5, #0]
 8001880:	b2da      	uxtb	r2, r3
 8001882:	2b00      	cmp	r3, #0
 8001884:	d105      	bne.n	8001892 <HAL_TIM_IC_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8001886:	0023      	movs	r3, r4
 8001888:	333c      	adds	r3, #60	@ 0x3c
    HAL_TIM_IC_MspInit(htim);
 800188a:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 800188c:	701a      	strb	r2, [r3, #0]
    HAL_TIM_IC_MspInit(htim);
 800188e:	f7fe ff3f 	bl	8000710 <HAL_TIM_IC_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 8001892:	2302      	movs	r3, #2
 8001894:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001896:	6820      	ldr	r0, [r4, #0]
 8001898:	1d21      	adds	r1, r4, #4
 800189a:	f7ff ff53 	bl	8001744 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800189e:	0022      	movs	r2, r4
 80018a0:	2301      	movs	r3, #1
  return HAL_OK;
 80018a2:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80018a4:	3248      	adds	r2, #72	@ 0x48
 80018a6:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80018a8:	3447      	adds	r4, #71	@ 0x47
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80018aa:	3a0a      	subs	r2, #10
 80018ac:	7013      	strb	r3, [r2, #0]
 80018ae:	7053      	strb	r3, [r2, #1]
 80018b0:	7093      	strb	r3, [r2, #2]
 80018b2:	70d3      	strb	r3, [r2, #3]
 80018b4:	7113      	strb	r3, [r2, #4]
 80018b6:	7153      	strb	r3, [r2, #5]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80018b8:	7193      	strb	r3, [r2, #6]
 80018ba:	71d3      	strb	r3, [r2, #7]
 80018bc:	7213      	strb	r3, [r2, #8]
 80018be:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 80018c0:	702b      	strb	r3, [r5, #0]
}
 80018c2:	bd70      	pop	{r4, r5, r6, pc}

080018c4 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80018c4:	2210      	movs	r2, #16
{
 80018c6:	b570      	push	{r4, r5, r6, lr}
  tmpccer = TIMx->CCER;
 80018c8:	6a05      	ldr	r5, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80018ca:	6a03      	ldr	r3, [r0, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80018cc:	4c16      	ldr	r4, [pc, #88]	@ (8001928 <TIM_OC2_SetConfig+0x64>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80018ce:	4393      	bics	r3, r2
 80018d0:	6203      	str	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 80018d2:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 80018d4:	6983      	ldr	r3, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80018d6:	4023      	ands	r3, r4
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80018d8:	680c      	ldr	r4, [r1, #0]
 80018da:	0224      	lsls	r4, r4, #8
 80018dc:	431c      	orrs	r4, r3
  tmpccer &= ~TIM_CCER_CC2P;
 80018de:	2320      	movs	r3, #32
 80018e0:	439d      	bics	r5, r3
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80018e2:	688b      	ldr	r3, [r1, #8]
 80018e4:	011b      	lsls	r3, r3, #4
 80018e6:	432b      	orrs	r3, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80018e8:	4d10      	ldr	r5, [pc, #64]	@ (800192c <TIM_OC2_SetConfig+0x68>)
 80018ea:	42a8      	cmp	r0, r5
 80018ec:	d10f      	bne.n	800190e <TIM_OC2_SetConfig+0x4a>
    tmpccer &= ~TIM_CCER_CC2NP;
 80018ee:	2580      	movs	r5, #128	@ 0x80
 80018f0:	43ab      	bics	r3, r5
 80018f2:	001e      	movs	r6, r3
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80018f4:	68cb      	ldr	r3, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NE;
 80018f6:	3d40      	subs	r5, #64	@ 0x40
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80018f8:	011b      	lsls	r3, r3, #4
 80018fa:	4333      	orrs	r3, r6
    tmpccer &= ~TIM_CCER_CC2NE;
 80018fc:	43ab      	bics	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 80018fe:	4d0c      	ldr	r5, [pc, #48]	@ (8001930 <TIM_OC2_SetConfig+0x6c>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8001900:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8001902:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8001904:	694a      	ldr	r2, [r1, #20]
 8001906:	4332      	orrs	r2, r6
 8001908:	0092      	lsls	r2, r2, #2
 800190a:	432a      	orrs	r2, r5
 800190c:	e005      	b.n	800191a <TIM_OC2_SetConfig+0x56>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800190e:	4d09      	ldr	r5, [pc, #36]	@ (8001934 <TIM_OC2_SetConfig+0x70>)
 8001910:	42a8      	cmp	r0, r5
 8001912:	d0f4      	beq.n	80018fe <TIM_OC2_SetConfig+0x3a>
 8001914:	4d08      	ldr	r5, [pc, #32]	@ (8001938 <TIM_OC2_SetConfig+0x74>)
 8001916:	42a8      	cmp	r0, r5
 8001918:	d0f1      	beq.n	80018fe <TIM_OC2_SetConfig+0x3a>
  TIMx->CR2 = tmpcr2;
 800191a:	6042      	str	r2, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 800191c:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 800191e:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8001920:	6382      	str	r2, [r0, #56]	@ 0x38
  TIMx->CCER = tmpccer;
 8001922:	6203      	str	r3, [r0, #32]
}
 8001924:	bd70      	pop	{r4, r5, r6, pc}
 8001926:	46c0      	nop			@ (mov r8, r8)
 8001928:	feff8cff 	.word	0xfeff8cff
 800192c:	40012c00 	.word	0x40012c00
 8001930:	fffff3ff 	.word	0xfffff3ff
 8001934:	40014400 	.word	0x40014400
 8001938:	40014800 	.word	0x40014800

0800193c <HAL_TIM_PWM_ConfigChannel>:
{
 800193c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800193e:	0007      	movs	r7, r0
 8001940:	373c      	adds	r7, #60	@ 0x3c
{
 8001942:	0015      	movs	r5, r2
  __HAL_LOCK(htim);
 8001944:	783a      	ldrb	r2, [r7, #0]
{
 8001946:	0003      	movs	r3, r0
 8001948:	000c      	movs	r4, r1
  __HAL_LOCK(htim);
 800194a:	2002      	movs	r0, #2
 800194c:	2a01      	cmp	r2, #1
 800194e:	d00c      	beq.n	800196a <HAL_TIM_PWM_ConfigChannel+0x2e>
 8001950:	3801      	subs	r0, #1
 8001952:	7038      	strb	r0, [r7, #0]
  switch (Channel)
 8001954:	2d0c      	cmp	r5, #12
 8001956:	d051      	beq.n	80019fc <HAL_TIM_PWM_ConfigChannel+0xc0>
 8001958:	d808      	bhi.n	800196c <HAL_TIM_PWM_ConfigChannel+0x30>
 800195a:	2d04      	cmp	r5, #4
 800195c:	d02d      	beq.n	80019ba <HAL_TIM_PWM_ConfigChannel+0x7e>
 800195e:	2d08      	cmp	r5, #8
 8001960:	d03c      	beq.n	80019dc <HAL_TIM_PWM_ConfigChannel+0xa0>
 8001962:	2d00      	cmp	r5, #0
 8001964:	d017      	beq.n	8001996 <HAL_TIM_PWM_ConfigChannel+0x5a>
  __HAL_UNLOCK(htim);
 8001966:	2300      	movs	r3, #0
 8001968:	703b      	strb	r3, [r7, #0]
}
 800196a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (Channel)
 800196c:	2d10      	cmp	r5, #16
 800196e:	d058      	beq.n	8001a22 <HAL_TIM_PWM_ConfigChannel+0xe6>
 8001970:	2d14      	cmp	r5, #20
 8001972:	d1f8      	bne.n	8001966 <HAL_TIM_PWM_ConfigChannel+0x2a>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8001974:	681d      	ldr	r5, [r3, #0]
 8001976:	0028      	movs	r0, r5
 8001978:	f7ff fdd2 	bl	8001520 <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800197c:	2380      	movs	r3, #128	@ 0x80
 800197e:	6d6a      	ldr	r2, [r5, #84]	@ 0x54
 8001980:	011b      	lsls	r3, r3, #4
 8001982:	4313      	orrs	r3, r2
 8001984:	656b      	str	r3, [r5, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8001986:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
 8001988:	4a2e      	ldr	r2, [pc, #184]	@ (8001a44 <HAL_TIM_PWM_ConfigChannel+0x108>)
 800198a:	4013      	ands	r3, r2
 800198c:	656b      	str	r3, [r5, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800198e:	6923      	ldr	r3, [r4, #16]
 8001990:	6d6a      	ldr	r2, [r5, #84]	@ 0x54
 8001992:	021b      	lsls	r3, r3, #8
 8001994:	e053      	b.n	8001a3e <HAL_TIM_PWM_ConfigChannel+0x102>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8001996:	681d      	ldr	r5, [r3, #0]
 8001998:	0028      	movs	r0, r5
 800199a:	f7ff fce5 	bl	8001368 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800199e:	2308      	movs	r3, #8
 80019a0:	69aa      	ldr	r2, [r5, #24]
 80019a2:	4313      	orrs	r3, r2
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80019a4:	2204      	movs	r2, #4
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80019a6:	61ab      	str	r3, [r5, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80019a8:	69ab      	ldr	r3, [r5, #24]
 80019aa:	4393      	bics	r3, r2
 80019ac:	61ab      	str	r3, [r5, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80019ae:	69ab      	ldr	r3, [r5, #24]
 80019b0:	6922      	ldr	r2, [r4, #16]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80019b2:	4313      	orrs	r3, r2
 80019b4:	61ab      	str	r3, [r5, #24]
  HAL_StatusTypeDef status = HAL_OK;
 80019b6:	2000      	movs	r0, #0
 80019b8:	e7d5      	b.n	8001966 <HAL_TIM_PWM_ConfigChannel+0x2a>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80019ba:	681d      	ldr	r5, [r3, #0]
 80019bc:	0028      	movs	r0, r5
 80019be:	f7ff ff81 	bl	80018c4 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80019c2:	2380      	movs	r3, #128	@ 0x80
 80019c4:	69aa      	ldr	r2, [r5, #24]
 80019c6:	011b      	lsls	r3, r3, #4
 80019c8:	4313      	orrs	r3, r2
 80019ca:	61ab      	str	r3, [r5, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80019cc:	69ab      	ldr	r3, [r5, #24]
 80019ce:	4a1d      	ldr	r2, [pc, #116]	@ (8001a44 <HAL_TIM_PWM_ConfigChannel+0x108>)
 80019d0:	4013      	ands	r3, r2
 80019d2:	61ab      	str	r3, [r5, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80019d4:	6923      	ldr	r3, [r4, #16]
 80019d6:	69aa      	ldr	r2, [r5, #24]
 80019d8:	021b      	lsls	r3, r3, #8
 80019da:	e7ea      	b.n	80019b2 <HAL_TIM_PWM_ConfigChannel+0x76>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80019dc:	681e      	ldr	r6, [r3, #0]
 80019de:	0030      	movs	r0, r6
 80019e0:	f7ff fcf8 	bl	80013d4 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80019e4:	2204      	movs	r2, #4
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80019e6:	69f3      	ldr	r3, [r6, #28]
 80019e8:	431d      	orrs	r5, r3
 80019ea:	61f5      	str	r5, [r6, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80019ec:	69f3      	ldr	r3, [r6, #28]
 80019ee:	4393      	bics	r3, r2
 80019f0:	61f3      	str	r3, [r6, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80019f2:	69f3      	ldr	r3, [r6, #28]
 80019f4:	6922      	ldr	r2, [r4, #16]
 80019f6:	4313      	orrs	r3, r2
 80019f8:	61f3      	str	r3, [r6, #28]
      break;
 80019fa:	e7dc      	b.n	80019b6 <HAL_TIM_PWM_ConfigChannel+0x7a>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80019fc:	681d      	ldr	r5, [r3, #0]
 80019fe:	0028      	movs	r0, r5
 8001a00:	f7ff fd2a 	bl	8001458 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8001a04:	2380      	movs	r3, #128	@ 0x80
 8001a06:	69ea      	ldr	r2, [r5, #28]
 8001a08:	011b      	lsls	r3, r3, #4
 8001a0a:	4313      	orrs	r3, r2
 8001a0c:	61eb      	str	r3, [r5, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8001a0e:	69eb      	ldr	r3, [r5, #28]
 8001a10:	4a0c      	ldr	r2, [pc, #48]	@ (8001a44 <HAL_TIM_PWM_ConfigChannel+0x108>)
 8001a12:	4013      	ands	r3, r2
 8001a14:	61eb      	str	r3, [r5, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8001a16:	6923      	ldr	r3, [r4, #16]
 8001a18:	69ea      	ldr	r2, [r5, #28]
 8001a1a:	021b      	lsls	r3, r3, #8
 8001a1c:	4313      	orrs	r3, r2
 8001a1e:	61eb      	str	r3, [r5, #28]
      break;
 8001a20:	e7c9      	b.n	80019b6 <HAL_TIM_PWM_ConfigChannel+0x7a>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8001a22:	681d      	ldr	r5, [r3, #0]
 8001a24:	0028      	movs	r0, r5
 8001a26:	f7ff fd4b 	bl	80014c0 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8001a2a:	2308      	movs	r3, #8
 8001a2c:	6d6a      	ldr	r2, [r5, #84]	@ 0x54
 8001a2e:	4313      	orrs	r3, r2
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8001a30:	2204      	movs	r2, #4
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8001a32:	656b      	str	r3, [r5, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8001a34:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
 8001a36:	4393      	bics	r3, r2
 8001a38:	656b      	str	r3, [r5, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8001a3a:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
 8001a3c:	6922      	ldr	r2, [r4, #16]
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8001a3e:	4313      	orrs	r3, r2
 8001a40:	656b      	str	r3, [r5, #84]	@ 0x54
      break;
 8001a42:	e7b8      	b.n	80019b6 <HAL_TIM_PWM_ConfigChannel+0x7a>
 8001a44:	fffffbff 	.word	0xfffffbff

08001a48 <TIM_TI1_SetConfig>:
  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */
void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                       uint32_t TIM_ICFilter)
{
 8001a48:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001a4a:	2601      	movs	r6, #1
  tmpccer = TIMx->CCER;
 8001a4c:	6a04      	ldr	r4, [r0, #32]
{
 8001a4e:	0015      	movs	r5, r2
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001a50:	6a02      	ldr	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;

  /* Select the Input */
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8001a52:	4f0d      	ldr	r7, [pc, #52]	@ (8001a88 <TIM_TI1_SetConfig+0x40>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001a54:	43b2      	bics	r2, r6
 8001a56:	6202      	str	r2, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8001a58:	6982      	ldr	r2, [r0, #24]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8001a5a:	42b8      	cmp	r0, r7
 8001a5c:	d010      	beq.n	8001a80 <TIM_TI1_SetConfig+0x38>
 8001a5e:	4f0b      	ldr	r7, [pc, #44]	@ (8001a8c <TIM_TI1_SetConfig+0x44>)
 8001a60:	42b8      	cmp	r0, r7
 8001a62:	d00d      	beq.n	8001a80 <TIM_TI1_SetConfig+0x38>
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
    tmpccmr1 |= TIM_ICSelection;
  }
  else
  {
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 8001a64:	4332      	orrs	r2, r6
  }

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8001a66:	25f0      	movs	r5, #240	@ 0xf0
 8001a68:	43aa      	bics	r2, r5
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8001a6a:	011b      	lsls	r3, r3, #4
 8001a6c:	350f      	adds	r5, #15
 8001a6e:	402b      	ands	r3, r5
 8001a70:	4313      	orrs	r3, r2

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8001a72:	220a      	movs	r2, #10
 8001a74:	4394      	bics	r4, r2
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8001a76:	4011      	ands	r1, r2
 8001a78:	4321      	orrs	r1, r4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8001a7a:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8001a7c:	6201      	str	r1, [r0, #32]
}
 8001a7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
 8001a80:	2603      	movs	r6, #3
 8001a82:	43b2      	bics	r2, r6
    tmpccmr1 |= TIM_ICSelection;
 8001a84:	432a      	orrs	r2, r5
 8001a86:	e7ee      	b.n	8001a66 <TIM_TI1_SetConfig+0x1e>
 8001a88:	40012c00 	.word	0x40012c00
 8001a8c:	40000400 	.word	0x40000400

08001a90 <HAL_TIM_IC_ConfigChannel>:
  __HAL_LOCK(htim);
 8001a90:	0003      	movs	r3, r0
{
 8001a92:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 8001a94:	333c      	adds	r3, #60	@ 0x3c
{
 8001a96:	9001      	str	r0, [sp, #4]
 8001a98:	000c      	movs	r4, r1
  __HAL_LOCK(htim);
 8001a9a:	7819      	ldrb	r1, [r3, #0]
 8001a9c:	2002      	movs	r0, #2
 8001a9e:	2901      	cmp	r1, #1
 8001aa0:	d00c      	beq.n	8001abc <HAL_TIM_IC_ConfigChannel+0x2c>
 8001aa2:	3801      	subs	r0, #1
 8001aa4:	7018      	strb	r0, [r3, #0]
  if (Channel == TIM_CHANNEL_1)
 8001aa6:	2a08      	cmp	r2, #8
 8001aa8:	d067      	beq.n	8001b7a <HAL_TIM_IC_ConfigChannel+0xea>
 8001aaa:	d808      	bhi.n	8001abe <HAL_TIM_IC_ConfigChannel+0x2e>
 8001aac:	2a00      	cmp	r2, #0
 8001aae:	d02d      	beq.n	8001b0c <HAL_TIM_IC_ConfigChannel+0x7c>
 8001ab0:	2a04      	cmp	r2, #4
 8001ab2:	d03d      	beq.n	8001b30 <HAL_TIM_IC_ConfigChannel+0xa0>
  __HAL_UNLOCK(htim);
 8001ab4:	2300      	movs	r3, #0
 8001ab6:	9d01      	ldr	r5, [sp, #4]
 8001ab8:	353c      	adds	r5, #60	@ 0x3c
 8001aba:	702b      	strb	r3, [r5, #0]
}
 8001abc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8001abe:	2a0c      	cmp	r2, #12
 8001ac0:	d1f8      	bne.n	8001ab4 <HAL_TIM_IC_ConfigChannel+0x24>
    TIM_TI4_SetConfig(htim->Instance,
 8001ac2:	9b01      	ldr	r3, [sp, #4]
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 4: Reset the CC4E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001ac4:	4d40      	ldr	r5, [pc, #256]	@ (8001bc8 <HAL_TIM_IC_ConfigChannel+0x138>)
    TIM_TI4_SetConfig(htim->Instance,
 8001ac6:	681b      	ldr	r3, [r3, #0]
                      sConfig->ICPolarity,
 8001ac8:	6822      	ldr	r2, [r4, #0]
  tmpccer = TIMx->CCER;
 8001aca:	6a1e      	ldr	r6, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001acc:	6a1f      	ldr	r7, [r3, #32]
                      sConfig->ICSelection,
 8001ace:	6860      	ldr	r0, [r4, #4]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001ad0:	402f      	ands	r7, r5
                      sConfig->ICFilter);
 8001ad2:	68e1      	ldr	r1, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001ad4:	621f      	str	r7, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8001ad6:	69df      	ldr	r7, [r3, #28]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 8001ad8:	4d3c      	ldr	r5, [pc, #240]	@ (8001bcc <HAL_TIM_IC_ConfigChannel+0x13c>)
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8001ada:	0200      	lsls	r0, r0, #8
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 8001adc:	402f      	ands	r7, r5
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8001ade:	4338      	orrs	r0, r7

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8001ae0:	4f3b      	ldr	r7, [pc, #236]	@ (8001bd0 <HAL_TIM_IC_ConfigChannel+0x140>)
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8001ae2:	0709      	lsls	r1, r1, #28
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8001ae4:	4038      	ands	r0, r7
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8001ae6:	0c09      	lsrs	r1, r1, #16
 8001ae8:	4301      	orrs	r1, r0

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8001aea:	483a      	ldr	r0, [pc, #232]	@ (8001bd4 <HAL_TIM_IC_ConfigChannel+0x144>)
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8001aec:	0312      	lsls	r2, r2, #12
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8001aee:	4006      	ands	r6, r0
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8001af0:	20a0      	movs	r0, #160	@ 0xa0
 8001af2:	0200      	lsls	r0, r0, #8
 8001af4:	4002      	ands	r2, r0
 8001af6:	4332      	orrs	r2, r6

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8001af8:	61d9      	str	r1, [r3, #28]
  TIMx->CCER = tmpccer ;
 8001afa:	621a      	str	r2, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 8001afc:	69da      	ldr	r2, [r3, #28]
 8001afe:	4936      	ldr	r1, [pc, #216]	@ (8001bd8 <HAL_TIM_IC_ConfigChannel+0x148>)
 8001b00:	400a      	ands	r2, r1
 8001b02:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8001b04:	68a2      	ldr	r2, [r4, #8]
 8001b06:	69d9      	ldr	r1, [r3, #28]
 8001b08:	0212      	lsls	r2, r2, #8
 8001b0a:	e05a      	b.n	8001bc2 <HAL_TIM_IC_ConfigChannel+0x132>
    TIM_TI1_SetConfig(htim->Instance,
 8001b0c:	9b01      	ldr	r3, [sp, #4]
 8001b0e:	6862      	ldr	r2, [r4, #4]
 8001b10:	681e      	ldr	r6, [r3, #0]
 8001b12:	6821      	ldr	r1, [r4, #0]
 8001b14:	68e3      	ldr	r3, [r4, #12]
 8001b16:	0030      	movs	r0, r6
 8001b18:	f7ff ff96 	bl	8001a48 <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8001b1c:	220c      	movs	r2, #12
 8001b1e:	69b3      	ldr	r3, [r6, #24]
 8001b20:	4393      	bics	r3, r2
 8001b22:	61b3      	str	r3, [r6, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8001b24:	69b3      	ldr	r3, [r6, #24]
 8001b26:	68a2      	ldr	r2, [r4, #8]
 8001b28:	4313      	orrs	r3, r2
 8001b2a:	61b3      	str	r3, [r6, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8001b2c:	2000      	movs	r0, #0
 8001b2e:	e7c1      	b.n	8001ab4 <HAL_TIM_IC_ConfigChannel+0x24>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001b30:	2510      	movs	r5, #16
    TIM_TI2_SetConfig(htim->Instance,
 8001b32:	9b01      	ldr	r3, [sp, #4]
                      sConfig->ICPolarity,
 8001b34:	6822      	ldr	r2, [r4, #0]
    TIM_TI2_SetConfig(htim->Instance,
 8001b36:	681b      	ldr	r3, [r3, #0]
                      sConfig->ICSelection,
 8001b38:	6860      	ldr	r0, [r4, #4]
  tmpccer = TIMx->CCER;
 8001b3a:	6a1e      	ldr	r6, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001b3c:	6a1f      	ldr	r7, [r3, #32]
                      sConfig->ICFilter);
 8001b3e:	68e1      	ldr	r1, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001b40:	43af      	bics	r7, r5
 8001b42:	621f      	str	r7, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8001b44:	699f      	ldr	r7, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 8001b46:	4d21      	ldr	r5, [pc, #132]	@ (8001bcc <HAL_TIM_IC_ConfigChannel+0x13c>)
  tmpccmr1 |= (TIM_ICSelection << 8U);
 8001b48:	0200      	lsls	r0, r0, #8
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 8001b4a:	402f      	ands	r7, r5
  tmpccmr1 |= (TIM_ICSelection << 8U);
 8001b4c:	4338      	orrs	r0, r7
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8001b4e:	4f20      	ldr	r7, [pc, #128]	@ (8001bd0 <HAL_TIM_IC_ConfigChannel+0x140>)
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 8001b50:	0709      	lsls	r1, r1, #28
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8001b52:	4038      	ands	r0, r7
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 8001b54:	0c09      	lsrs	r1, r1, #16
 8001b56:	4301      	orrs	r1, r0
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8001b58:	20a0      	movs	r0, #160	@ 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8001b5a:	0112      	lsls	r2, r2, #4
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8001b5c:	4386      	bics	r6, r0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8001b5e:	4002      	ands	r2, r0
 8001b60:	4332      	orrs	r2, r6
  TIMx->CCMR1 = tmpccmr1 ;
 8001b62:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8001b64:	621a      	str	r2, [r3, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 8001b66:	699a      	ldr	r2, [r3, #24]
 8001b68:	491b      	ldr	r1, [pc, #108]	@ (8001bd8 <HAL_TIM_IC_ConfigChannel+0x148>)
 8001b6a:	400a      	ands	r2, r1
 8001b6c:	619a      	str	r2, [r3, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 8001b6e:	68a2      	ldr	r2, [r4, #8]
 8001b70:	6999      	ldr	r1, [r3, #24]
 8001b72:	0212      	lsls	r2, r2, #8
 8001b74:	430a      	orrs	r2, r1
 8001b76:	619a      	str	r2, [r3, #24]
 8001b78:	e7d8      	b.n	8001b2c <HAL_TIM_IC_ConfigChannel+0x9c>
    TIM_TI3_SetConfig(htim->Instance,
 8001b7a:	9b01      	ldr	r3, [sp, #4]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8001b7c:	4d17      	ldr	r5, [pc, #92]	@ (8001bdc <HAL_TIM_IC_ConfigChannel+0x14c>)
    TIM_TI3_SetConfig(htim->Instance,
 8001b7e:	681b      	ldr	r3, [r3, #0]
                      sConfig->ICPolarity,
 8001b80:	6822      	ldr	r2, [r4, #0]
  tmpccer = TIMx->CCER;
 8001b82:	6a1e      	ldr	r6, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8001b84:	6a1f      	ldr	r7, [r3, #32]
                      sConfig->ICSelection,
 8001b86:	6860      	ldr	r0, [r4, #4]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8001b88:	402f      	ands	r7, r5
                      sConfig->ICFilter);
 8001b8a:	68e1      	ldr	r1, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8001b8c:	621f      	str	r7, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8001b8e:	69df      	ldr	r7, [r3, #28]
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 8001b90:	3505      	adds	r5, #5
 8001b92:	35ff      	adds	r5, #255	@ 0xff
 8001b94:	43af      	bics	r7, r5
  tmpccmr2 |= TIM_ICSelection;
 8001b96:	4338      	orrs	r0, r7
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8001b98:	27f0      	movs	r7, #240	@ 0xf0
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8001b9a:	0109      	lsls	r1, r1, #4
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8001b9c:	43b8      	bics	r0, r7
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8001b9e:	370f      	adds	r7, #15
 8001ba0:	4039      	ands	r1, r7
 8001ba2:	4301      	orrs	r1, r0
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8001ba4:	480e      	ldr	r0, [pc, #56]	@ (8001be0 <HAL_TIM_IC_ConfigChannel+0x150>)
  TIMx->CCMR2 = tmpccmr2;
 8001ba6:	61d9      	str	r1, [r3, #28]
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8001ba8:	4030      	ands	r0, r6
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8001baa:	26a0      	movs	r6, #160	@ 0xa0
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8001bac:	210c      	movs	r1, #12
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8001bae:	0212      	lsls	r2, r2, #8
 8001bb0:	0136      	lsls	r6, r6, #4
 8001bb2:	4032      	ands	r2, r6
 8001bb4:	4302      	orrs	r2, r0
  TIMx->CCER = tmpccer;
 8001bb6:	621a      	str	r2, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8001bb8:	69da      	ldr	r2, [r3, #28]
 8001bba:	438a      	bics	r2, r1
 8001bbc:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 8001bbe:	69da      	ldr	r2, [r3, #28]
 8001bc0:	68a1      	ldr	r1, [r4, #8]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8001bc2:	430a      	orrs	r2, r1
 8001bc4:	61da      	str	r2, [r3, #28]
 8001bc6:	e7b1      	b.n	8001b2c <HAL_TIM_IC_ConfigChannel+0x9c>
 8001bc8:	ffffefff 	.word	0xffffefff
 8001bcc:	fffffcff 	.word	0xfffffcff
 8001bd0:	ffff0fff 	.word	0xffff0fff
 8001bd4:	ffff5fff 	.word	0xffff5fff
 8001bd8:	fffff3ff 	.word	0xfffff3ff
 8001bdc:	fffffeff 	.word	0xfffffeff
 8001be0:	fffff5ff 	.word	0xfffff5ff

08001be4 <TIM_CCxChannelCmd>:

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8001be4:	231f      	movs	r3, #31
{
 8001be6:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8001be8:	2401      	movs	r4, #1
 8001bea:	4019      	ands	r1, r3
 8001bec:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8001bee:	408a      	lsls	r2, r1
  TIMx->CCER &= ~tmp;
 8001bf0:	6a03      	ldr	r3, [r0, #32]
 8001bf2:	43a3      	bics	r3, r4
 8001bf4:	6203      	str	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8001bf6:	6a03      	ldr	r3, [r0, #32]
 8001bf8:	431a      	orrs	r2, r3
 8001bfa:	6202      	str	r2, [r0, #32]
}
 8001bfc:	bd10      	pop	{r4, pc}
	...

08001c00 <HAL_TIM_IC_Start_IT>:
{
 8001c00:	b510      	push	{r4, lr}
 8001c02:	2908      	cmp	r1, #8
 8001c04:	d02f      	beq.n	8001c66 <HAL_TIM_IC_Start_IT+0x66>
 8001c06:	d806      	bhi.n	8001c16 <HAL_TIM_IC_Start_IT+0x16>
 8001c08:	2900      	cmp	r1, #0
 8001c0a:	d00b      	beq.n	8001c24 <HAL_TIM_IC_Start_IT+0x24>
 8001c0c:	2904      	cmp	r1, #4
 8001c0e:	d023      	beq.n	8001c58 <HAL_TIM_IC_Start_IT+0x58>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c10:	0003      	movs	r3, r0
 8001c12:	3343      	adds	r3, #67	@ 0x43
 8001c14:	e030      	b.n	8001c78 <HAL_TIM_IC_Start_IT+0x78>
 8001c16:	290c      	cmp	r1, #12
 8001c18:	d02c      	beq.n	8001c74 <HAL_TIM_IC_Start_IT+0x74>
 8001c1a:	2910      	cmp	r1, #16
 8001c1c:	d1f8      	bne.n	8001c10 <HAL_TIM_IC_Start_IT+0x10>
 8001c1e:	0003      	movs	r3, r0
 8001c20:	3342      	adds	r3, #66	@ 0x42
 8001c22:	e029      	b.n	8001c78 <HAL_TIM_IC_Start_IT+0x78>
 8001c24:	0003      	movs	r3, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c26:	0002      	movs	r2, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c28:	333e      	adds	r3, #62	@ 0x3e
 8001c2a:	781b      	ldrb	r3, [r3, #0]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c2c:	3244      	adds	r2, #68	@ 0x44
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c2e:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c30:	7812      	ldrb	r2, [r2, #0]
 8001c32:	b2d2      	uxtb	r2, r2
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
 8001c34:	2b01      	cmp	r3, #1
 8001c36:	d12d      	bne.n	8001c94 <HAL_TIM_IC_Start_IT+0x94>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
 8001c38:	2a01      	cmp	r2, #1
 8001c3a:	d12b      	bne.n	8001c94 <HAL_TIM_IC_Start_IT+0x94>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c3c:	3301      	adds	r3, #1
 8001c3e:	2908      	cmp	r1, #8
 8001c40:	d054      	beq.n	8001cec <HAL_TIM_IC_Start_IT+0xec>
 8001c42:	d81e      	bhi.n	8001c82 <HAL_TIM_IC_Start_IT+0x82>
 8001c44:	2900      	cmp	r1, #0
 8001c46:	d027      	beq.n	8001c98 <HAL_TIM_IC_Start_IT+0x98>
 8001c48:	2904      	cmp	r1, #4
 8001c4a:	d046      	beq.n	8001cda <HAL_TIM_IC_Start_IT+0xda>
 8001c4c:	0002      	movs	r2, r0
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c4e:	3047      	adds	r0, #71	@ 0x47
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c50:	3243      	adds	r2, #67	@ 0x43
 8001c52:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c54:	7003      	strb	r3, [r0, #0]
  switch (Channel)
 8001c56:	e01d      	b.n	8001c94 <HAL_TIM_IC_Start_IT+0x94>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c58:	0003      	movs	r3, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c5a:	0002      	movs	r2, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c5c:	333f      	adds	r3, #63	@ 0x3f
 8001c5e:	781b      	ldrb	r3, [r3, #0]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c60:	3245      	adds	r2, #69	@ 0x45
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c62:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c64:	e7e4      	b.n	8001c30 <HAL_TIM_IC_Start_IT+0x30>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c66:	0003      	movs	r3, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c68:	0002      	movs	r2, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c6a:	3340      	adds	r3, #64	@ 0x40
 8001c6c:	781b      	ldrb	r3, [r3, #0]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c6e:	3246      	adds	r2, #70	@ 0x46
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c70:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c72:	e7dd      	b.n	8001c30 <HAL_TIM_IC_Start_IT+0x30>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c74:	0003      	movs	r3, r0
 8001c76:	3341      	adds	r3, #65	@ 0x41
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c78:	0002      	movs	r2, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c7a:	781b      	ldrb	r3, [r3, #0]
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c7c:	3247      	adds	r2, #71	@ 0x47
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8001c7e:	b2db      	uxtb	r3, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8001c80:	e7d6      	b.n	8001c30 <HAL_TIM_IC_Start_IT+0x30>
 8001c82:	0002      	movs	r2, r0
 8001c84:	3247      	adds	r2, #71	@ 0x47
 8001c86:	290c      	cmp	r1, #12
 8001c88:	d033      	beq.n	8001cf2 <HAL_TIM_IC_Start_IT+0xf2>
 8001c8a:	2910      	cmp	r1, #16
 8001c8c:	d1de      	bne.n	8001c4c <HAL_TIM_IC_Start_IT+0x4c>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c8e:	3042      	adds	r0, #66	@ 0x42
 8001c90:	7003      	strb	r3, [r0, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c92:	7013      	strb	r3, [r2, #0]
{
 8001c94:	2001      	movs	r0, #1
 8001c96:	e01f      	b.n	8001cd8 <HAL_TIM_IC_Start_IT+0xd8>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c98:	0002      	movs	r2, r0
 8001c9a:	323e      	adds	r2, #62	@ 0x3e
 8001c9c:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001c9e:	7193      	strb	r3, [r2, #6]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8001ca0:	6804      	ldr	r4, [r0, #0]
 8001ca2:	68e2      	ldr	r2, [r4, #12]
 8001ca4:	4313      	orrs	r3, r2
 8001ca6:	60e3      	str	r3, [r4, #12]
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8001ca8:	6804      	ldr	r4, [r0, #0]
 8001caa:	2201      	movs	r2, #1
 8001cac:	0020      	movs	r0, r4
 8001cae:	f7ff ff99 	bl	8001be4 <TIM_CCxChannelCmd>
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8001cb2:	4b14      	ldr	r3, [pc, #80]	@ (8001d04 <HAL_TIM_IC_Start_IT+0x104>)
 8001cb4:	429c      	cmp	r4, r3
 8001cb6:	d002      	beq.n	8001cbe <HAL_TIM_IC_Start_IT+0xbe>
 8001cb8:	4b13      	ldr	r3, [pc, #76]	@ (8001d08 <HAL_TIM_IC_Start_IT+0x108>)
 8001cba:	429c      	cmp	r4, r3
 8001cbc:	d107      	bne.n	8001cce <HAL_TIM_IC_Start_IT+0xce>
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001cbe:	68a3      	ldr	r3, [r4, #8]
 8001cc0:	4a12      	ldr	r2, [pc, #72]	@ (8001d0c <HAL_TIM_IC_Start_IT+0x10c>)
 8001cc2:	4013      	ands	r3, r2
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8001cc4:	2b06      	cmp	r3, #6
 8001cc6:	d006      	beq.n	8001cd6 <HAL_TIM_IC_Start_IT+0xd6>
 8001cc8:	3a07      	subs	r2, #7
 8001cca:	4293      	cmp	r3, r2
 8001ccc:	d003      	beq.n	8001cd6 <HAL_TIM_IC_Start_IT+0xd6>
        __HAL_TIM_ENABLE(htim);
 8001cce:	2301      	movs	r3, #1
 8001cd0:	6822      	ldr	r2, [r4, #0]
 8001cd2:	4313      	orrs	r3, r2
 8001cd4:	6023      	str	r3, [r4, #0]
{
 8001cd6:	2000      	movs	r0, #0
}
 8001cd8:	bd10      	pop	{r4, pc}
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001cda:	0002      	movs	r2, r0
 8001cdc:	323f      	adds	r2, #63	@ 0x3f
 8001cde:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001ce0:	7193      	strb	r3, [r2, #6]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8001ce2:	6802      	ldr	r2, [r0, #0]
 8001ce4:	68d3      	ldr	r3, [r2, #12]
 8001ce6:	430b      	orrs	r3, r1
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8001ce8:	60d3      	str	r3, [r2, #12]
  if (status == HAL_OK)
 8001cea:	e7dd      	b.n	8001ca8 <HAL_TIM_IC_Start_IT+0xa8>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001cec:	0002      	movs	r2, r0
 8001cee:	3240      	adds	r2, #64	@ 0x40
 8001cf0:	e7f5      	b.n	8001cde <HAL_TIM_IC_Start_IT+0xde>
 8001cf2:	0004      	movs	r4, r0
 8001cf4:	3441      	adds	r4, #65	@ 0x41
 8001cf6:	7023      	strb	r3, [r4, #0]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8001cf8:	7013      	strb	r3, [r2, #0]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8001cfa:	2310      	movs	r3, #16
 8001cfc:	6802      	ldr	r2, [r0, #0]
 8001cfe:	68d4      	ldr	r4, [r2, #12]
 8001d00:	4323      	orrs	r3, r4
 8001d02:	e7f1      	b.n	8001ce8 <HAL_TIM_IC_Start_IT+0xe8>
 8001d04:	40012c00 	.word	0x40012c00
 8001d08:	40000400 	.word	0x40000400
 8001d0c:	00010007 	.word	0x00010007

08001d10 <HAL_TIM_IC_Stop_IT>:
{
 8001d10:	b570      	push	{r4, r5, r6, lr}
 8001d12:	0004      	movs	r4, r0
 8001d14:	000d      	movs	r5, r1
  switch (Channel)
 8001d16:	2908      	cmp	r1, #8
 8001d18:	d011      	beq.n	8001d3e <HAL_TIM_IC_Stop_IT+0x2e>
 8001d1a:	d805      	bhi.n	8001d28 <HAL_TIM_IC_Stop_IT+0x18>
 8001d1c:	2900      	cmp	r1, #0
 8001d1e:	d009      	beq.n	8001d34 <HAL_TIM_IC_Stop_IT+0x24>
 8001d20:	2904      	cmp	r1, #4
 8001d22:	d00c      	beq.n	8001d3e <HAL_TIM_IC_Stop_IT+0x2e>
 8001d24:	2001      	movs	r0, #1
}
 8001d26:	bd70      	pop	{r4, r5, r6, pc}
  switch (Channel)
 8001d28:	290c      	cmp	r1, #12
 8001d2a:	d1fb      	bne.n	8001d24 <HAL_TIM_IC_Stop_IT+0x14>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8001d2c:	6802      	ldr	r2, [r0, #0]
 8001d2e:	2110      	movs	r1, #16
 8001d30:	68d3      	ldr	r3, [r2, #12]
 8001d32:	e002      	b.n	8001d3a <HAL_TIM_IC_Stop_IT+0x2a>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8001d34:	2102      	movs	r1, #2
 8001d36:	6802      	ldr	r2, [r0, #0]
 8001d38:	68d3      	ldr	r3, [r2, #12]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8001d3a:	438b      	bics	r3, r1
 8001d3c:	e002      	b.n	8001d44 <HAL_TIM_IC_Stop_IT+0x34>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8001d3e:	6822      	ldr	r2, [r4, #0]
 8001d40:	68d3      	ldr	r3, [r2, #12]
 8001d42:	43ab      	bics	r3, r5
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8001d44:	6826      	ldr	r6, [r4, #0]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8001d46:	60d3      	str	r3, [r2, #12]
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8001d48:	0029      	movs	r1, r5
 8001d4a:	2200      	movs	r2, #0
 8001d4c:	0030      	movs	r0, r6
 8001d4e:	f7ff ff49 	bl	8001be4 <TIM_CCxChannelCmd>
    __HAL_TIM_DISABLE(htim);
 8001d52:	6a32      	ldr	r2, [r6, #32]
 8001d54:	4b12      	ldr	r3, [pc, #72]	@ (8001da0 <HAL_TIM_IC_Stop_IT+0x90>)
 8001d56:	421a      	tst	r2, r3
 8001d58:	d107      	bne.n	8001d6a <HAL_TIM_IC_Stop_IT+0x5a>
 8001d5a:	6a32      	ldr	r2, [r6, #32]
 8001d5c:	4b11      	ldr	r3, [pc, #68]	@ (8001da4 <HAL_TIM_IC_Stop_IT+0x94>)
 8001d5e:	421a      	tst	r2, r3
 8001d60:	d103      	bne.n	8001d6a <HAL_TIM_IC_Stop_IT+0x5a>
 8001d62:	2201      	movs	r2, #1
 8001d64:	6833      	ldr	r3, [r6, #0]
 8001d66:	4393      	bics	r3, r2
 8001d68:	6033      	str	r3, [r6, #0]
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d6a:	2301      	movs	r3, #1
 8001d6c:	0022      	movs	r2, r4
 8001d6e:	2d00      	cmp	r5, #0
 8001d70:	d105      	bne.n	8001d7e <HAL_TIM_IC_Stop_IT+0x6e>
 8001d72:	323e      	adds	r2, #62	@ 0x3e
 8001d74:	7013      	strb	r3, [r2, #0]
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d76:	3444      	adds	r4, #68	@ 0x44
  switch (Channel)
 8001d78:	2000      	movs	r0, #0
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d7a:	7023      	strb	r3, [r4, #0]
 8001d7c:	e7d3      	b.n	8001d26 <HAL_TIM_IC_Stop_IT+0x16>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d7e:	2d04      	cmp	r5, #4
 8001d80:	d103      	bne.n	8001d8a <HAL_TIM_IC_Stop_IT+0x7a>
 8001d82:	323f      	adds	r2, #63	@ 0x3f
 8001d84:	7013      	strb	r3, [r2, #0]
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d86:	3445      	adds	r4, #69	@ 0x45
 8001d88:	e7f6      	b.n	8001d78 <HAL_TIM_IC_Stop_IT+0x68>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d8a:	2d08      	cmp	r5, #8
 8001d8c:	d103      	bne.n	8001d96 <HAL_TIM_IC_Stop_IT+0x86>
 8001d8e:	3240      	adds	r2, #64	@ 0x40
 8001d90:	7013      	strb	r3, [r2, #0]
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d92:	3446      	adds	r4, #70	@ 0x46
 8001d94:	e7f0      	b.n	8001d78 <HAL_TIM_IC_Stop_IT+0x68>
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d96:	3241      	adds	r2, #65	@ 0x41
 8001d98:	7013      	strb	r3, [r2, #0]
    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8001d9a:	3447      	adds	r4, #71	@ 0x47
 8001d9c:	e7ec      	b.n	8001d78 <HAL_TIM_IC_Stop_IT+0x68>
 8001d9e:	46c0      	nop			@ (mov r8, r8)
 8001da0:	00001111 	.word	0x00001111
 8001da4:	00000444 	.word	0x00000444

08001da8 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
 8001da8:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8001daa:	0004      	movs	r4, r0
 8001dac:	2202      	movs	r2, #2
 8001dae:	343c      	adds	r4, #60	@ 0x3c
 8001db0:	7825      	ldrb	r5, [r4, #0]
{
 8001db2:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8001db4:	0010      	movs	r0, r2
 8001db6:	2d01      	cmp	r5, #1
 8001db8:	d01f      	beq.n	8001dfa <HAL_TIMEx_MasterConfigSynchronization+0x52>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8001dba:	001d      	movs	r5, r3
 8001dbc:	353d      	adds	r5, #61	@ 0x3d
 8001dbe:	702a      	strb	r2, [r5, #0]

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8001dc0:	681a      	ldr	r2, [r3, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8001dc2:	4e0e      	ldr	r6, [pc, #56]	@ (8001dfc <HAL_TIMEx_MasterConfigSynchronization+0x54>)
  tmpcr2 = htim->Instance->CR2;
 8001dc4:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 8001dc6:	6890      	ldr	r0, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8001dc8:	42b2      	cmp	r2, r6
 8001dca:	d103      	bne.n	8001dd4 <HAL_TIMEx_MasterConfigSynchronization+0x2c>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8001dcc:	4f0c      	ldr	r7, [pc, #48]	@ (8001e00 <HAL_TIMEx_MasterConfigSynchronization+0x58>)
 8001dce:	403b      	ands	r3, r7
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8001dd0:	684f      	ldr	r7, [r1, #4]
 8001dd2:	433b      	orrs	r3, r7
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8001dd4:	2770      	movs	r7, #112	@ 0x70
 8001dd6:	43bb      	bics	r3, r7
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8001dd8:	680f      	ldr	r7, [r1, #0]
 8001dda:	433b      	orrs	r3, r7

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8001ddc:	6053      	str	r3, [r2, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8001dde:	42b2      	cmp	r2, r6
 8001de0:	d002      	beq.n	8001de8 <HAL_TIMEx_MasterConfigSynchronization+0x40>
 8001de2:	4b08      	ldr	r3, [pc, #32]	@ (8001e04 <HAL_TIMEx_MasterConfigSynchronization+0x5c>)
 8001de4:	429a      	cmp	r2, r3
 8001de6:	d104      	bne.n	8001df2 <HAL_TIMEx_MasterConfigSynchronization+0x4a>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8001de8:	2380      	movs	r3, #128	@ 0x80
 8001dea:	4398      	bics	r0, r3
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8001dec:	688b      	ldr	r3, [r1, #8]
 8001dee:	4318      	orrs	r0, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8001df0:	6090      	str	r0, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8001df2:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 8001df4:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8001df6:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 8001df8:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8001dfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dfc:	40012c00 	.word	0x40012c00
 8001e00:	ff0fffff 	.word	0xff0fffff
 8001e04:	40000400 	.word	0x40000400

08001e08 <HAL_TIMEx_CommutCallback>:
/**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
 8001e08:	4770      	bx	lr

08001e0a <HAL_TIMEx_BreakCallback>:
/**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
 8001e0a:	4770      	bx	lr

08001e0c <HAL_TIMEx_Break2Callback>:
/**
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
 8001e0c:	4770      	bx	lr
	...

08001e10 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8001e10:	b530      	push	{r4, r5, lr}
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8001e12:	f3ef 8410 	mrs	r4, PRIMASK
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8001e16:	2201      	movs	r2, #1
 8001e18:	f382 8810 	msr	PRIMASK, r2
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8001e1c:	6801      	ldr	r1, [r0, #0]
 8001e1e:	4d13      	ldr	r5, [pc, #76]	@ (8001e6c <UART_EndRxTransfer+0x5c>)
 8001e20:	680b      	ldr	r3, [r1, #0]
 8001e22:	402b      	ands	r3, r5
 8001e24:	600b      	str	r3, [r1, #0]
 8001e26:	f384 8810 	msr	PRIMASK, r4
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8001e2a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8001e2e:	f382 8810 	msr	PRIMASK, r2
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8001e32:	6802      	ldr	r2, [r0, #0]
 8001e34:	4c0e      	ldr	r4, [pc, #56]	@ (8001e70 <UART_EndRxTransfer+0x60>)
 8001e36:	6893      	ldr	r3, [r2, #8]
 8001e38:	4023      	ands	r3, r4
 8001e3a:	6093      	str	r3, [r2, #8]
 8001e3c:	f381 8810 	msr	PRIMASK, r1

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8001e40:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8001e42:	2b01      	cmp	r3, #1
 8001e44:	d10a      	bne.n	8001e5c <UART_EndRxTransfer+0x4c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8001e46:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8001e4a:	f383 8810 	msr	PRIMASK, r3
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8001e4e:	2410      	movs	r4, #16
 8001e50:	6802      	ldr	r2, [r0, #0]
 8001e52:	6813      	ldr	r3, [r2, #0]
 8001e54:	43a3      	bics	r3, r4
 8001e56:	6013      	str	r3, [r2, #0]
 8001e58:	f381 8810 	msr	PRIMASK, r1
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8001e5c:	0003      	movs	r3, r0
 8001e5e:	2220      	movs	r2, #32
 8001e60:	338c      	adds	r3, #140	@ 0x8c
 8001e62:	601a      	str	r2, [r3, #0]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8001e64:	2300      	movs	r3, #0
 8001e66:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8001e68:	6743      	str	r3, [r0, #116]	@ 0x74
}
 8001e6a:	bd30      	pop	{r4, r5, pc}
 8001e6c:	fffffedf 	.word	0xfffffedf
 8001e70:	effffffe 	.word	0xeffffffe

08001e74 <HAL_UART_TxCpltCallback>:
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
 8001e74:	4770      	bx	lr

08001e76 <HAL_UART_ErrorCallback>:
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
 8001e76:	4770      	bx	lr

08001e78 <UART_DMAAbortOnError>:
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8001e78:	6a80      	ldr	r0, [r0, #40]	@ 0x28
  huart->RxXferCount = 0U;
 8001e7a:	2200      	movs	r2, #0
 8001e7c:	0003      	movs	r3, r0
{
 8001e7e:	b510      	push	{r4, lr}
  huart->RxXferCount = 0U;
 8001e80:	335e      	adds	r3, #94	@ 0x5e
 8001e82:	801a      	strh	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8001e84:	f7ff fff7 	bl	8001e76 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8001e88:	bd10      	pop	{r4, pc}

08001e8a <HAL_UARTEx_RxEventCallback>:
}
 8001e8a:	4770      	bx	lr

08001e8c <HAL_UART_IRQHandler>:
{
 8001e8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8001e8e:	6801      	ldr	r1, [r0, #0]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8001e90:	4dc3      	ldr	r5, [pc, #780]	@ (80021a0 <HAL_UART_IRQHandler+0x314>)
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8001e92:	69cb      	ldr	r3, [r1, #28]
{
 8001e94:	0004      	movs	r4, r0
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8001e96:	680a      	ldr	r2, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8001e98:	6888      	ldr	r0, [r1, #8]
  if (errorflags == 0U)
 8001e9a:	422b      	tst	r3, r5
 8001e9c:	d110      	bne.n	8001ec0 <HAL_UART_IRQHandler+0x34>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8001e9e:	2520      	movs	r5, #32
 8001ea0:	422b      	tst	r3, r5
 8001ea2:	d100      	bne.n	8001ea6 <HAL_UART_IRQHandler+0x1a>
 8001ea4:	e09b      	b.n	8001fde <HAL_UART_IRQHandler+0x152>
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8001ea6:	2680      	movs	r6, #128	@ 0x80
 8001ea8:	0576      	lsls	r6, r6, #21
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8001eaa:	4015      	ands	r5, r2
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8001eac:	4006      	ands	r6, r0
 8001eae:	4335      	orrs	r5, r6
 8001eb0:	d100      	bne.n	8001eb4 <HAL_UART_IRQHandler+0x28>
 8001eb2:	e094      	b.n	8001fde <HAL_UART_IRQHandler+0x152>
      if (huart->RxISR != NULL)
 8001eb4:	6f63      	ldr	r3, [r4, #116]	@ 0x74
      huart->TxISR(huart);
 8001eb6:	0020      	movs	r0, r4
    if (huart->TxISR != NULL)
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d000      	beq.n	8001ebe <HAL_UART_IRQHandler+0x32>
 8001ebc:	e085      	b.n	8001fca <HAL_UART_IRQHandler+0x13e>
 8001ebe:	e085      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 8001ec0:	4db8      	ldr	r5, [pc, #736]	@ (80021a4 <HAL_UART_IRQHandler+0x318>)
 8001ec2:	4005      	ands	r5, r0
 8001ec4:	9500      	str	r5, [sp, #0]
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8001ec6:	4db8      	ldr	r5, [pc, #736]	@ (80021a8 <HAL_UART_IRQHandler+0x31c>)
 8001ec8:	9e00      	ldr	r6, [sp, #0]
 8001eca:	4015      	ands	r5, r2
 8001ecc:	4335      	orrs	r5, r6
 8001ece:	d100      	bne.n	8001ed2 <HAL_UART_IRQHandler+0x46>
 8001ed0:	e085      	b.n	8001fde <HAL_UART_IRQHandler+0x152>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8001ed2:	0025      	movs	r5, r4
 8001ed4:	2601      	movs	r6, #1
 8001ed6:	3590      	adds	r5, #144	@ 0x90
 8001ed8:	4233      	tst	r3, r6
 8001eda:	d005      	beq.n	8001ee8 <HAL_UART_IRQHandler+0x5c>
 8001edc:	05d7      	lsls	r7, r2, #23
 8001ede:	d503      	bpl.n	8001ee8 <HAL_UART_IRQHandler+0x5c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8001ee0:	620e      	str	r6, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001ee2:	682f      	ldr	r7, [r5, #0]
 8001ee4:	433e      	orrs	r6, r7
 8001ee6:	602e      	str	r6, [r5, #0]
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8001ee8:	2602      	movs	r6, #2
 8001eea:	4233      	tst	r3, r6
 8001eec:	d00c      	beq.n	8001f08 <HAL_UART_IRQHandler+0x7c>
 8001eee:	07c7      	lsls	r7, r0, #31
 8001ef0:	d50a      	bpl.n	8001f08 <HAL_UART_IRQHandler+0x7c>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001ef2:	0027      	movs	r7, r4
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8001ef4:	620e      	str	r6, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001ef6:	3790      	adds	r7, #144	@ 0x90
 8001ef8:	683e      	ldr	r6, [r7, #0]
 8001efa:	9701      	str	r7, [sp, #4]
 8001efc:	46b4      	mov	ip, r6
 8001efe:	2604      	movs	r6, #4
 8001f00:	4667      	mov	r7, ip
 8001f02:	433e      	orrs	r6, r7
 8001f04:	9f01      	ldr	r7, [sp, #4]
 8001f06:	603e      	str	r6, [r7, #0]
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8001f08:	2604      	movs	r6, #4
 8001f0a:	4233      	tst	r3, r6
 8001f0c:	d00c      	beq.n	8001f28 <HAL_UART_IRQHandler+0x9c>
 8001f0e:	07c7      	lsls	r7, r0, #31
 8001f10:	d50a      	bpl.n	8001f28 <HAL_UART_IRQHandler+0x9c>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001f12:	0027      	movs	r7, r4
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8001f14:	620e      	str	r6, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001f16:	3790      	adds	r7, #144	@ 0x90
 8001f18:	683e      	ldr	r6, [r7, #0]
 8001f1a:	9701      	str	r7, [sp, #4]
 8001f1c:	46b4      	mov	ip, r6
 8001f1e:	2602      	movs	r6, #2
 8001f20:	4667      	mov	r7, ip
 8001f22:	433e      	orrs	r6, r7
 8001f24:	9f01      	ldr	r7, [sp, #4]
 8001f26:	603e      	str	r6, [r7, #0]
    if (((isrflags & USART_ISR_ORE) != 0U)
 8001f28:	2608      	movs	r6, #8
 8001f2a:	46b4      	mov	ip, r6
 8001f2c:	4233      	tst	r3, r6
 8001f2e:	d009      	beq.n	8001f44 <HAL_UART_IRQHandler+0xb8>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 8001f30:	2720      	movs	r7, #32
 8001f32:	9e00      	ldr	r6, [sp, #0]
 8001f34:	4017      	ands	r7, r2
 8001f36:	4337      	orrs	r7, r6
 8001f38:	d004      	beq.n	8001f44 <HAL_UART_IRQHandler+0xb8>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8001f3a:	4666      	mov	r6, ip
 8001f3c:	620e      	str	r6, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001f3e:	682f      	ldr	r7, [r5, #0]
 8001f40:	433e      	orrs	r6, r7
 8001f42:	602e      	str	r6, [r5, #0]
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8001f44:	2680      	movs	r6, #128	@ 0x80
 8001f46:	0136      	lsls	r6, r6, #4
 8001f48:	4233      	tst	r3, r6
 8001f4a:	d006      	beq.n	8001f5a <HAL_UART_IRQHandler+0xce>
 8001f4c:	0157      	lsls	r7, r2, #5
 8001f4e:	d504      	bpl.n	8001f5a <HAL_UART_IRQHandler+0xce>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8001f50:	620e      	str	r6, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8001f52:	2120      	movs	r1, #32
 8001f54:	682e      	ldr	r6, [r5, #0]
 8001f56:	4331      	orrs	r1, r6
 8001f58:	6029      	str	r1, [r5, #0]
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001f5a:	6829      	ldr	r1, [r5, #0]
 8001f5c:	2900      	cmp	r1, #0
 8001f5e:	d035      	beq.n	8001fcc <HAL_UART_IRQHandler+0x140>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8001f60:	2120      	movs	r1, #32
 8001f62:	420b      	tst	r3, r1
 8001f64:	d00a      	beq.n	8001f7c <HAL_UART_IRQHandler+0xf0>
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8001f66:	2380      	movs	r3, #128	@ 0x80
 8001f68:	055b      	lsls	r3, r3, #21
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8001f6a:	4011      	ands	r1, r2
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8001f6c:	4003      	ands	r3, r0
 8001f6e:	4319      	orrs	r1, r3
 8001f70:	d004      	beq.n	8001f7c <HAL_UART_IRQHandler+0xf0>
        if (huart->RxISR != NULL)
 8001f72:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 8001f74:	2b00      	cmp	r3, #0
 8001f76:	d001      	beq.n	8001f7c <HAL_UART_IRQHandler+0xf0>
          huart->RxISR(huart);
 8001f78:	0020      	movs	r0, r4
 8001f7a:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8001f7c:	6822      	ldr	r2, [r4, #0]
      errorcode = huart->ErrorCode;
 8001f7e:	682b      	ldr	r3, [r5, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8001f80:	2740      	movs	r7, #64	@ 0x40
 8001f82:	6896      	ldr	r6, [r2, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8001f84:	2228      	movs	r2, #40	@ 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8001f86:	403e      	ands	r6, r7
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8001f88:	4013      	ands	r3, r2
        UART_EndRxTransfer(huart);
 8001f8a:	0020      	movs	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8001f8c:	431e      	orrs	r6, r3
 8001f8e:	d022      	beq.n	8001fd6 <HAL_UART_IRQHandler+0x14a>
        UART_EndRxTransfer(huart);
 8001f90:	f7ff ff3e 	bl	8001e10 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001f94:	6823      	ldr	r3, [r4, #0]
 8001f96:	689b      	ldr	r3, [r3, #8]
 8001f98:	423b      	tst	r3, r7
 8001f9a:	d018      	beq.n	8001fce <HAL_UART_IRQHandler+0x142>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8001f9c:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8001fa0:	2301      	movs	r3, #1
 8001fa2:	f383 8810 	msr	PRIMASK, r3
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001fa6:	0025      	movs	r5, r4
 8001fa8:	cd04      	ldmia	r5!, {r2}
 8001faa:	6893      	ldr	r3, [r2, #8]
 8001fac:	43bb      	bics	r3, r7
 8001fae:	6093      	str	r3, [r2, #8]
 8001fb0:	f381 8810 	msr	PRIMASK, r1
          if (huart->hdmarx != NULL)
 8001fb4:	6fe8      	ldr	r0, [r5, #124]	@ 0x7c
 8001fb6:	2800      	cmp	r0, #0
 8001fb8:	d009      	beq.n	8001fce <HAL_UART_IRQHandler+0x142>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8001fba:	4b7c      	ldr	r3, [pc, #496]	@ (80021ac <HAL_UART_IRQHandler+0x320>)
 8001fbc:	6383      	str	r3, [r0, #56]	@ 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8001fbe:	f7fe fe49 	bl	8000c54 <HAL_DMA_Abort_IT>
 8001fc2:	2800      	cmp	r0, #0
 8001fc4:	d002      	beq.n	8001fcc <HAL_UART_IRQHandler+0x140>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001fc6:	6fe8      	ldr	r0, [r5, #124]	@ 0x7c
 8001fc8:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8001fca:	4798      	blx	r3
}
 8001fcc:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            HAL_UART_ErrorCallback(huart);
 8001fce:	0020      	movs	r0, r4
 8001fd0:	f7ff ff51 	bl	8001e76 <HAL_UART_ErrorCallback>
 8001fd4:	e7fa      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
        HAL_UART_ErrorCallback(huart);
 8001fd6:	f7ff ff4e 	bl	8001e76 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001fda:	602e      	str	r6, [r5, #0]
 8001fdc:	e7f6      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8001fde:	6ee5      	ldr	r5, [r4, #108]	@ 0x6c
 8001fe0:	2d01      	cmp	r5, #1
 8001fe2:	d000      	beq.n	8001fe6 <HAL_UART_IRQHandler+0x15a>
 8001fe4:	e0a4      	b.n	8002130 <HAL_UART_IRQHandler+0x2a4>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8001fe6:	2610      	movs	r6, #16
 8001fe8:	4233      	tst	r3, r6
 8001fea:	d100      	bne.n	8001fee <HAL_UART_IRQHandler+0x162>
 8001fec:	e0a0      	b.n	8002130 <HAL_UART_IRQHandler+0x2a4>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8001fee:	4232      	tst	r2, r6
 8001ff0:	d100      	bne.n	8001ff4 <HAL_UART_IRQHandler+0x168>
 8001ff2:	e09d      	b.n	8002130 <HAL_UART_IRQHandler+0x2a4>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8001ff4:	0023      	movs	r3, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8001ff6:	620e      	str	r6, [r1, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001ff8:	6889      	ldr	r1, [r1, #8]
          && (nb_remaining_rx_data < huart->RxXferSize))
 8001ffa:	335c      	adds	r3, #92	@ 0x5c
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001ffc:	0008      	movs	r0, r1
          && (nb_remaining_rx_data < huart->RxXferSize))
 8001ffe:	881a      	ldrh	r2, [r3, #0]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8002000:	2340      	movs	r3, #64	@ 0x40
 8002002:	4018      	ands	r0, r3
 8002004:	4219      	tst	r1, r3
 8002006:	d05e      	beq.n	80020c6 <HAL_UART_IRQHandler+0x23a>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8002008:	1d20      	adds	r0, r4, #4
 800200a:	6fc1      	ldr	r1, [r0, #124]	@ 0x7c
 800200c:	680f      	ldr	r7, [r1, #0]
 800200e:	6879      	ldr	r1, [r7, #4]
 8002010:	b289      	uxth	r1, r1
      if ((nb_remaining_rx_data > 0U)
 8002012:	2900      	cmp	r1, #0
 8002014:	d04d      	beq.n	80020b2 <HAL_UART_IRQHandler+0x226>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8002016:	4291      	cmp	r1, r2
 8002018:	d24b      	bcs.n	80020b2 <HAL_UART_IRQHandler+0x226>
        huart->RxXferCount = nb_remaining_rx_data;
 800201a:	0022      	movs	r2, r4
 800201c:	325e      	adds	r2, #94	@ 0x5e
 800201e:	8011      	strh	r1, [r2, #0]
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8002020:	2120      	movs	r1, #32
 8002022:	468c      	mov	ip, r1
 8002024:	683a      	ldr	r2, [r7, #0]
 8002026:	4011      	ands	r1, r2
 8002028:	9100      	str	r1, [sp, #0]
 800202a:	4661      	mov	r1, ip
 800202c:	420a      	tst	r2, r1
 800202e:	d132      	bne.n	8002096 <HAL_UART_IRQHandler+0x20a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002030:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002034:	f385 8810 	msr	PRIMASK, r5
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8002038:	6821      	ldr	r1, [r4, #0]
 800203a:	4e5d      	ldr	r6, [pc, #372]	@ (80021b0 <HAL_UART_IRQHandler+0x324>)
 800203c:	680a      	ldr	r2, [r1, #0]
 800203e:	4032      	ands	r2, r6
 8002040:	600a      	str	r2, [r1, #0]
 8002042:	f387 8810 	msr	PRIMASK, r7
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002046:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800204a:	f385 8810 	msr	PRIMASK, r5
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800204e:	6821      	ldr	r1, [r4, #0]
 8002050:	688a      	ldr	r2, [r1, #8]
 8002052:	43aa      	bics	r2, r5
 8002054:	608a      	str	r2, [r1, #8]
 8002056:	f387 8810 	msr	PRIMASK, r7
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800205a:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800205e:	f385 8810 	msr	PRIMASK, r5
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002062:	6821      	ldr	r1, [r4, #0]
 8002064:	688a      	ldr	r2, [r1, #8]
 8002066:	439a      	bics	r2, r3
 8002068:	608a      	str	r2, [r1, #8]
 800206a:	f387 8810 	msr	PRIMASK, r7
          huart->RxState = HAL_UART_STATE_READY;
 800206e:	0023      	movs	r3, r4
 8002070:	4662      	mov	r2, ip
 8002072:	338c      	adds	r3, #140	@ 0x8c
 8002074:	601a      	str	r2, [r3, #0]
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002076:	9b00      	ldr	r3, [sp, #0]
 8002078:	66e3      	str	r3, [r4, #108]	@ 0x6c
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800207a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800207e:	f385 8810 	msr	PRIMASK, r5
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002082:	6822      	ldr	r2, [r4, #0]
 8002084:	350f      	adds	r5, #15
 8002086:	6813      	ldr	r3, [r2, #0]
 8002088:	43ab      	bics	r3, r5
 800208a:	6013      	str	r3, [r2, #0]
 800208c:	f381 8810 	msr	PRIMASK, r1
          (void)HAL_DMA_Abort(huart->hdmarx);
 8002090:	6fc0      	ldr	r0, [r0, #124]	@ 0x7c
 8002092:	f7fe fda5 	bl	8000be0 <HAL_DMA_Abort>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8002096:	2302      	movs	r3, #2
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8002098:	0022      	movs	r2, r4
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 800209a:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 800209c:	0023      	movs	r3, r4
 800209e:	325c      	adds	r2, #92	@ 0x5c
 80020a0:	335e      	adds	r3, #94	@ 0x5e
 80020a2:	881b      	ldrh	r3, [r3, #0]
 80020a4:	8811      	ldrh	r1, [r2, #0]
 80020a6:	1ac9      	subs	r1, r1, r3
 80020a8:	b289      	uxth	r1, r1
            HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80020aa:	0020      	movs	r0, r4
 80020ac:	f7ff feed 	bl	8001e8a <HAL_UARTEx_RxEventCallback>
 80020b0:	e78c      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
        if (nb_remaining_rx_data == huart->RxXferSize)
 80020b2:	4291      	cmp	r1, r2
 80020b4:	d000      	beq.n	80020b8 <HAL_UART_IRQHandler+0x22c>
 80020b6:	e789      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
          if (HAL_IS_BIT_SET(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80020b8:	683b      	ldr	r3, [r7, #0]
 80020ba:	069b      	lsls	r3, r3, #26
 80020bc:	d400      	bmi.n	80020c0 <HAL_UART_IRQHandler+0x234>
 80020be:	e785      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
            huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 80020c0:	2302      	movs	r3, #2
 80020c2:	6723      	str	r3, [r4, #112]	@ 0x70
 80020c4:	e7f1      	b.n	80020aa <HAL_UART_IRQHandler+0x21e>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80020c6:	0021      	movs	r1, r4
 80020c8:	315e      	adds	r1, #94	@ 0x5e
 80020ca:	880b      	ldrh	r3, [r1, #0]
      if ((huart->RxXferCount > 0U)
 80020cc:	8809      	ldrh	r1, [r1, #0]
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80020ce:	b29b      	uxth	r3, r3
      if ((huart->RxXferCount > 0U)
 80020d0:	2900      	cmp	r1, #0
 80020d2:	d100      	bne.n	80020d6 <HAL_UART_IRQHandler+0x24a>
 80020d4:	e77a      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80020d6:	1ad2      	subs	r2, r2, r3
 80020d8:	b291      	uxth	r1, r2
          && (nb_rx_data > 0U))
 80020da:	2900      	cmp	r1, #0
 80020dc:	d100      	bne.n	80020e0 <HAL_UART_IRQHandler+0x254>
 80020de:	e775      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80020e0:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80020e4:	f385 8810 	msr	PRIMASK, r5
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80020e8:	6822      	ldr	r2, [r4, #0]
 80020ea:	4e32      	ldr	r6, [pc, #200]	@ (80021b4 <HAL_UART_IRQHandler+0x328>)
 80020ec:	6813      	ldr	r3, [r2, #0]
 80020ee:	4033      	ands	r3, r6
 80020f0:	6013      	str	r3, [r2, #0]
 80020f2:	f387 8810 	msr	PRIMASK, r7
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80020f6:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80020fa:	f385 8810 	msr	PRIMASK, r5
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80020fe:	6822      	ldr	r2, [r4, #0]
 8002100:	4e2d      	ldr	r6, [pc, #180]	@ (80021b8 <HAL_UART_IRQHandler+0x32c>)
 8002102:	6893      	ldr	r3, [r2, #8]
 8002104:	4033      	ands	r3, r6
 8002106:	6093      	str	r3, [r2, #8]
 8002108:	f387 8810 	msr	PRIMASK, r7
        huart->RxState = HAL_UART_STATE_READY;
 800210c:	0023      	movs	r3, r4
 800210e:	2220      	movs	r2, #32
 8002110:	338c      	adds	r3, #140	@ 0x8c
 8002112:	601a      	str	r2, [r3, #0]
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002114:	66e0      	str	r0, [r4, #108]	@ 0x6c
        huart->RxISR = NULL;
 8002116:	6760      	str	r0, [r4, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002118:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800211c:	f385 8810 	msr	PRIMASK, r5
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002120:	2510      	movs	r5, #16
 8002122:	6822      	ldr	r2, [r4, #0]
 8002124:	6813      	ldr	r3, [r2, #0]
 8002126:	43ab      	bics	r3, r5
 8002128:	6013      	str	r3, [r2, #0]
 800212a:	f380 8810 	msr	PRIMASK, r0
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 800212e:	e7c7      	b.n	80020c0 <HAL_UART_IRQHandler+0x234>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8002130:	2580      	movs	r5, #128	@ 0x80
 8002132:	036d      	lsls	r5, r5, #13
 8002134:	422b      	tst	r3, r5
 8002136:	d006      	beq.n	8002146 <HAL_UART_IRQHandler+0x2ba>
 8002138:	0246      	lsls	r6, r0, #9
 800213a:	d504      	bpl.n	8002146 <HAL_UART_IRQHandler+0x2ba>
    HAL_UARTEx_WakeupCallback(huart);
 800213c:	0020      	movs	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800213e:	620d      	str	r5, [r1, #32]
    HAL_UARTEx_WakeupCallback(huart);
 8002140:	f000 fe24 	bl	8002d8c <HAL_UARTEx_WakeupCallback>
    return;
 8002144:	e742      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 8002146:	2180      	movs	r1, #128	@ 0x80
 8002148:	420b      	tst	r3, r1
 800214a:	d007      	beq.n	800215c <HAL_UART_IRQHandler+0x2d0>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 800214c:	2580      	movs	r5, #128	@ 0x80
 800214e:	042d      	lsls	r5, r5, #16
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 8002150:	4011      	ands	r1, r2
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8002152:	4028      	ands	r0, r5
 8002154:	4301      	orrs	r1, r0
 8002156:	d001      	beq.n	800215c <HAL_UART_IRQHandler+0x2d0>
    if (huart->TxISR != NULL)
 8002158:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800215a:	e6ac      	b.n	8001eb6 <HAL_UART_IRQHandler+0x2a>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800215c:	2140      	movs	r1, #64	@ 0x40
 800215e:	420b      	tst	r3, r1
 8002160:	d016      	beq.n	8002190 <HAL_UART_IRQHandler+0x304>
 8002162:	420a      	tst	r2, r1
 8002164:	d014      	beq.n	8002190 <HAL_UART_IRQHandler+0x304>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002166:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800216a:	2301      	movs	r3, #1
 800216c:	f383 8810 	msr	PRIMASK, r3
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002170:	6822      	ldr	r2, [r4, #0]
 8002172:	6813      	ldr	r3, [r2, #0]
 8002174:	438b      	bics	r3, r1
 8002176:	6013      	str	r3, [r2, #0]
 8002178:	f380 8810 	msr	PRIMASK, r0

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800217c:	0023      	movs	r3, r4
 800217e:	2220      	movs	r2, #32
 8002180:	3388      	adds	r3, #136	@ 0x88
 8002182:	601a      	str	r2, [r3, #0]

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8002184:	2300      	movs	r3, #0
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8002186:	0020      	movs	r0, r4
  huart->TxISR = NULL;
 8002188:	67a3      	str	r3, [r4, #120]	@ 0x78
  HAL_UART_TxCpltCallback(huart);
 800218a:	f7ff fe73 	bl	8001e74 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800218e:	e71d      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8002190:	0219      	lsls	r1, r3, #8
 8002192:	d513      	bpl.n	80021bc <HAL_UART_IRQHandler+0x330>
 8002194:	0051      	lsls	r1, r2, #1
 8002196:	d511      	bpl.n	80021bc <HAL_UART_IRQHandler+0x330>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8002198:	0020      	movs	r0, r4
 800219a:	f000 fdf9 	bl	8002d90 <HAL_UARTEx_TxFifoEmptyCallback>
    return;
 800219e:	e715      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
 80021a0:	0000080f 	.word	0x0000080f
 80021a4:	10000001 	.word	0x10000001
 80021a8:	04000120 	.word	0x04000120
 80021ac:	08001e79 	.word	0x08001e79
 80021b0:	fffffeff 	.word	0xfffffeff
 80021b4:	fffffedf 	.word	0xfffffedf
 80021b8:	effffffe 	.word	0xeffffffe
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 80021bc:	01db      	lsls	r3, r3, #7
 80021be:	d400      	bmi.n	80021c2 <HAL_UART_IRQHandler+0x336>
 80021c0:	e704      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
 80021c2:	2a00      	cmp	r2, #0
 80021c4:	db00      	blt.n	80021c8 <HAL_UART_IRQHandler+0x33c>
 80021c6:	e701      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>
    HAL_UARTEx_RxFifoFullCallback(huart);
 80021c8:	0020      	movs	r0, r4
 80021ca:	f000 fde0 	bl	8002d8e <HAL_UARTEx_RxFifoFullCallback>
    return;
 80021ce:	e6fd      	b.n	8001fcc <HAL_UART_IRQHandler+0x140>

080021d0 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80021d0:	0001      	movs	r1, r0
{
 80021d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t uhMask = huart->Mask;
 80021d4:	0003      	movs	r3, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80021d6:	318c      	adds	r1, #140	@ 0x8c
 80021d8:	680c      	ldr	r4, [r1, #0]
  uint16_t uhMask = huart->Mask;
 80021da:	3360      	adds	r3, #96	@ 0x60
 80021dc:	881a      	ldrh	r2, [r3, #0]
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80021de:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80021e0:	2c22      	cmp	r4, #34	@ 0x22
 80021e2:	d157      	bne.n	8002294 <UART_RxISR_8BIT+0xc4>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80021e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80021e6:	6d84      	ldr	r4, [r0, #88]	@ 0x58
 80021e8:	4013      	ands	r3, r2
    huart->pRxBuffPtr++;
    huart->RxXferCount--;
 80021ea:	0002      	movs	r2, r0
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80021ec:	7023      	strb	r3, [r4, #0]
    huart->pRxBuffPtr++;
 80021ee:	6d83      	ldr	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 80021f0:	325e      	adds	r2, #94	@ 0x5e
    huart->pRxBuffPtr++;
 80021f2:	3301      	adds	r3, #1
 80021f4:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 80021f6:	8813      	ldrh	r3, [r2, #0]
 80021f8:	3b01      	subs	r3, #1
 80021fa:	b29b      	uxth	r3, r3
 80021fc:	8013      	strh	r3, [r2, #0]

    if (huart->RxXferCount == 0U)
 80021fe:	8813      	ldrh	r3, [r2, #0]
 8002200:	b29c      	uxth	r4, r3
 8002202:	2b00      	cmp	r3, #0
 8002204:	d142      	bne.n	800228c <UART_RxISR_8BIT+0xbc>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002206:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800220a:	3301      	adds	r3, #1
 800220c:	f383 8810 	msr	PRIMASK, r3
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8002210:	6805      	ldr	r5, [r0, #0]
 8002212:	4f23      	ldr	r7, [pc, #140]	@ (80022a0 <UART_RxISR_8BIT+0xd0>)
 8002214:	682a      	ldr	r2, [r5, #0]
 8002216:	403a      	ands	r2, r7
 8002218:	602a      	str	r2, [r5, #0]
 800221a:	f386 8810 	msr	PRIMASK, r6
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800221e:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002222:	f383 8810 	msr	PRIMASK, r3

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002226:	6805      	ldr	r5, [r0, #0]
 8002228:	68aa      	ldr	r2, [r5, #8]
 800222a:	439a      	bics	r2, r3
 800222c:	60aa      	str	r2, [r5, #8]
 800222e:	f386 8810 	msr	PRIMASK, r6

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8002232:	2220      	movs	r2, #32
 8002234:	600a      	str	r2, [r1, #0]

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002236:	6802      	ldr	r2, [r0, #0]
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 8002238:	6704      	str	r4, [r0, #112]	@ 0x70
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800223a:	6852      	ldr	r2, [r2, #4]
      huart->RxISR = NULL;
 800223c:	6744      	str	r4, [r0, #116]	@ 0x74
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800223e:	0212      	lsls	r2, r2, #8
 8002240:	d50a      	bpl.n	8002258 <UART_RxISR_8BIT+0x88>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002242:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002246:	f383 8810 	msr	PRIMASK, r3
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800224a:	6802      	ldr	r2, [r0, #0]
 800224c:	4c15      	ldr	r4, [pc, #84]	@ (80022a4 <UART_RxISR_8BIT+0xd4>)
 800224e:	6813      	ldr	r3, [r2, #0]
 8002250:	4023      	ands	r3, r4
 8002252:	6013      	str	r3, [r2, #0]
 8002254:	f381 8810 	msr	PRIMASK, r1
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8002258:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 800225a:	2b01      	cmp	r3, #1
 800225c:	d117      	bne.n	800228e <UART_RxISR_8BIT+0xbe>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800225e:	2200      	movs	r2, #0
 8002260:	66c2      	str	r2, [r0, #108]	@ 0x6c
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002262:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002266:	f383 8810 	msr	PRIMASK, r3

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800226a:	6801      	ldr	r1, [r0, #0]
 800226c:	330f      	adds	r3, #15
 800226e:	680a      	ldr	r2, [r1, #0]
 8002270:	439a      	bics	r2, r3
 8002272:	600a      	str	r2, [r1, #0]
 8002274:	f384 8810 	msr	PRIMASK, r4

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8002278:	6802      	ldr	r2, [r0, #0]
 800227a:	69d1      	ldr	r1, [r2, #28]
 800227c:	4219      	tst	r1, r3
 800227e:	d000      	beq.n	8002282 <UART_RxISR_8BIT+0xb2>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8002280:	6213      	str	r3, [r2, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8002282:	0003      	movs	r3, r0
 8002284:	335c      	adds	r3, #92	@ 0x5c
 8002286:	8819      	ldrh	r1, [r3, #0]
 8002288:	f7ff fdff 	bl	8001e8a <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800228c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        HAL_UART_RxCpltCallback(huart);
 800228e:	f7fe f8a7 	bl	80003e0 <HAL_UART_RxCpltCallback>
 8002292:	e7fb      	b.n	800228c <UART_RxISR_8BIT+0xbc>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8002294:	2208      	movs	r2, #8
 8002296:	6999      	ldr	r1, [r3, #24]
 8002298:	430a      	orrs	r2, r1
 800229a:	619a      	str	r2, [r3, #24]
}
 800229c:	e7f6      	b.n	800228c <UART_RxISR_8BIT+0xbc>
 800229e:	46c0      	nop			@ (mov r8, r8)
 80022a0:	fffffedf 	.word	0xfffffedf
 80022a4:	fbffffff 	.word	0xfbffffff

080022a8 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80022a8:	0002      	movs	r2, r0
{
 80022aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t uhMask = huart->Mask;
 80022ac:	0003      	movs	r3, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80022ae:	328c      	adds	r2, #140	@ 0x8c
 80022b0:	6811      	ldr	r1, [r2, #0]
  uint16_t uhMask = huart->Mask;
 80022b2:	3360      	adds	r3, #96	@ 0x60
 80022b4:	881c      	ldrh	r4, [r3, #0]
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80022b6:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80022b8:	2922      	cmp	r1, #34	@ 0x22
 80022ba:	d156      	bne.n	800236a <UART_RxISR_16BIT+0xc2>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80022bc:	6a59      	ldr	r1, [r3, #36]	@ 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 80022be:	6d83      	ldr	r3, [r0, #88]	@ 0x58
    *tmp = (uint16_t)(uhdata & uhMask);
 80022c0:	4021      	ands	r1, r4
 80022c2:	8019      	strh	r1, [r3, #0]
    huart->pRxBuffPtr += 2U;
    huart->RxXferCount--;
 80022c4:	0001      	movs	r1, r0
    huart->pRxBuffPtr += 2U;
 80022c6:	3302      	adds	r3, #2
 80022c8:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 80022ca:	315e      	adds	r1, #94	@ 0x5e
 80022cc:	880b      	ldrh	r3, [r1, #0]
 80022ce:	3b01      	subs	r3, #1
 80022d0:	b29b      	uxth	r3, r3
 80022d2:	800b      	strh	r3, [r1, #0]

    if (huart->RxXferCount == 0U)
 80022d4:	880b      	ldrh	r3, [r1, #0]
 80022d6:	b29c      	uxth	r4, r3
 80022d8:	2b00      	cmp	r3, #0
 80022da:	d142      	bne.n	8002362 <UART_RxISR_16BIT+0xba>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80022dc:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80022e0:	3301      	adds	r3, #1
 80022e2:	f383 8810 	msr	PRIMASK, r3
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80022e6:	6805      	ldr	r5, [r0, #0]
 80022e8:	4f22      	ldr	r7, [pc, #136]	@ (8002374 <UART_RxISR_16BIT+0xcc>)
 80022ea:	6829      	ldr	r1, [r5, #0]
 80022ec:	4039      	ands	r1, r7
 80022ee:	6029      	str	r1, [r5, #0]
 80022f0:	f386 8810 	msr	PRIMASK, r6
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80022f4:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80022f8:	f383 8810 	msr	PRIMASK, r3

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80022fc:	6805      	ldr	r5, [r0, #0]
 80022fe:	68a9      	ldr	r1, [r5, #8]
 8002300:	4399      	bics	r1, r3
 8002302:	60a9      	str	r1, [r5, #8]
 8002304:	f386 8810 	msr	PRIMASK, r6

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8002308:	2120      	movs	r1, #32
 800230a:	6011      	str	r1, [r2, #0]

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800230c:	6802      	ldr	r2, [r0, #0]
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 800230e:	6704      	str	r4, [r0, #112]	@ 0x70
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002310:	6852      	ldr	r2, [r2, #4]
      huart->RxISR = NULL;
 8002312:	6744      	str	r4, [r0, #116]	@ 0x74
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002314:	0212      	lsls	r2, r2, #8
 8002316:	d50a      	bpl.n	800232e <UART_RxISR_16BIT+0x86>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002318:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800231c:	f383 8810 	msr	PRIMASK, r3
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8002320:	6802      	ldr	r2, [r0, #0]
 8002322:	4c15      	ldr	r4, [pc, #84]	@ (8002378 <UART_RxISR_16BIT+0xd0>)
 8002324:	6813      	ldr	r3, [r2, #0]
 8002326:	4023      	ands	r3, r4
 8002328:	6013      	str	r3, [r2, #0]
 800232a:	f381 8810 	msr	PRIMASK, r1
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800232e:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8002330:	2b01      	cmp	r3, #1
 8002332:	d117      	bne.n	8002364 <UART_RxISR_16BIT+0xbc>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002334:	2200      	movs	r2, #0
 8002336:	66c2      	str	r2, [r0, #108]	@ 0x6c
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002338:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800233c:	f383 8810 	msr	PRIMASK, r3

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002340:	6801      	ldr	r1, [r0, #0]
 8002342:	330f      	adds	r3, #15
 8002344:	680a      	ldr	r2, [r1, #0]
 8002346:	439a      	bics	r2, r3
 8002348:	600a      	str	r2, [r1, #0]
 800234a:	f384 8810 	msr	PRIMASK, r4

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800234e:	6802      	ldr	r2, [r0, #0]
 8002350:	69d1      	ldr	r1, [r2, #28]
 8002352:	4219      	tst	r1, r3
 8002354:	d000      	beq.n	8002358 <UART_RxISR_16BIT+0xb0>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8002356:	6213      	str	r3, [r2, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8002358:	0003      	movs	r3, r0
 800235a:	335c      	adds	r3, #92	@ 0x5c
 800235c:	8819      	ldrh	r1, [r3, #0]
 800235e:	f7ff fd94 	bl	8001e8a <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8002362:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        HAL_UART_RxCpltCallback(huart);
 8002364:	f7fe f83c 	bl	80003e0 <HAL_UART_RxCpltCallback>
 8002368:	e7fb      	b.n	8002362 <UART_RxISR_16BIT+0xba>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800236a:	2208      	movs	r2, #8
 800236c:	6999      	ldr	r1, [r3, #24]
 800236e:	430a      	orrs	r2, r1
 8002370:	619a      	str	r2, [r3, #24]
}
 8002372:	e7f6      	b.n	8002362 <UART_RxISR_16BIT+0xba>
 8002374:	fffffedf 	.word	0xfffffedf
 8002378:	fbffffff 	.word	0xfbffffff

0800237c <UART_RxISR_8BIT_FIFOEN>:
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
  uint16_t  uhMask = huart->Mask;
 800237c:	0003      	movs	r3, r0
{
 800237e:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8002380:	0006      	movs	r6, r0
  uint16_t  uhMask = huart->Mask;
 8002382:	3360      	adds	r3, #96	@ 0x60
 8002384:	881b      	ldrh	r3, [r3, #0]
{
 8002386:	b085      	sub	sp, #20
  uint16_t  uhMask = huart->Mask;
 8002388:	9302      	str	r3, [sp, #8]
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800238a:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800238c:	368c      	adds	r6, #140	@ 0x8c
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800238e:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8002390:	681a      	ldr	r2, [r3, #0]
{
 8002392:	0004      	movs	r4, r0
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8002394:	9203      	str	r2, [sp, #12]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8002396:	689a      	ldr	r2, [r3, #8]
 8002398:	9201      	str	r2, [sp, #4]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800239a:	6832      	ldr	r2, [r6, #0]
 800239c:	2a22      	cmp	r2, #34	@ 0x22
 800239e:	d000      	beq.n	80023a2 <UART_RxISR_8BIT_FIFOEN+0x26>
 80023a0:	e0c2      	b.n	8002528 <UART_RxISR_8BIT_FIFOEN+0x1ac>
  {
    nb_rx_data = huart->NbRxDataToProcess;
 80023a2:	0003      	movs	r3, r0
 80023a4:	3368      	adds	r3, #104	@ 0x68
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 80023a6:	881b      	ldrh	r3, [r3, #0]
 80023a8:	2b00      	cmp	r3, #0
 80023aa:	d100      	bne.n	80023ae <UART_RxISR_8BIT_FIFOEN+0x32>
 80023ac:	e092      	b.n	80024d4 <UART_RxISR_8BIT_FIFOEN+0x158>
 80023ae:	2320      	movs	r3, #32
 80023b0:	421d      	tst	r5, r3
 80023b2:	d100      	bne.n	80023b6 <UART_RxISR_8BIT_FIFOEN+0x3a>
 80023b4:	e08e      	b.n	80024d4 <UART_RxISR_8BIT_FIFOEN+0x158>
    {
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80023b6:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80023b8:	9902      	ldr	r1, [sp, #8]
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80023ba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80023bc:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 80023be:	400b      	ands	r3, r1
 80023c0:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
      huart->RxXferCount--;
 80023c2:	0022      	movs	r2, r4
      huart->pRxBuffPtr++;
 80023c4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 80023c6:	325e      	adds	r2, #94	@ 0x5e
      huart->pRxBuffPtr++;
 80023c8:	3301      	adds	r3, #1
 80023ca:	65a3      	str	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 80023cc:	8813      	ldrh	r3, [r2, #0]
 80023ce:	3b01      	subs	r3, #1
 80023d0:	b29b      	uxth	r3, r3
 80023d2:	8013      	strh	r3, [r2, #0]
      isrflags = READ_REG(huart->Instance->ISR);

      /* If some non blocking errors occurred */
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80023d4:	2307      	movs	r3, #7
      isrflags = READ_REG(huart->Instance->ISR);
 80023d6:	6822      	ldr	r2, [r4, #0]
 80023d8:	69d5      	ldr	r5, [r2, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80023da:	421d      	tst	r5, r3
 80023dc:	d02f      	beq.n	800243e <UART_RxISR_8BIT_FIFOEN+0xc2>
      {
        /* UART parity error interrupt occurred -------------------------------------*/
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80023de:	3b06      	subs	r3, #6
 80023e0:	421d      	tst	r5, r3
 80023e2:	d008      	beq.n	80023f6 <UART_RxISR_8BIT_FIFOEN+0x7a>
 80023e4:	9903      	ldr	r1, [sp, #12]
 80023e6:	05c9      	lsls	r1, r1, #23
 80023e8:	d505      	bpl.n	80023f6 <UART_RxISR_8BIT_FIFOEN+0x7a>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);

          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80023ea:	0021      	movs	r1, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80023ec:	6213      	str	r3, [r2, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80023ee:	3190      	adds	r1, #144	@ 0x90
 80023f0:	6808      	ldr	r0, [r1, #0]
 80023f2:	4303      	orrs	r3, r0
 80023f4:	600b      	str	r3, [r1, #0]
        }

        /* UART frame error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80023f6:	2302      	movs	r3, #2
 80023f8:	421d      	tst	r5, r3
 80023fa:	d009      	beq.n	8002410 <UART_RxISR_8BIT_FIFOEN+0x94>
 80023fc:	9901      	ldr	r1, [sp, #4]
 80023fe:	07c9      	lsls	r1, r1, #31
 8002400:	d506      	bpl.n	8002410 <UART_RxISR_8BIT_FIFOEN+0x94>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);

          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8002402:	0021      	movs	r1, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8002404:	6213      	str	r3, [r2, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8002406:	3190      	adds	r1, #144	@ 0x90
 8002408:	6808      	ldr	r0, [r1, #0]
 800240a:	18db      	adds	r3, r3, r3
 800240c:	4303      	orrs	r3, r0
 800240e:	600b      	str	r3, [r1, #0]
        }

        /* UART noise error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8002410:	2304      	movs	r3, #4
 8002412:	421d      	tst	r5, r3
 8002414:	d009      	beq.n	800242a <UART_RxISR_8BIT_FIFOEN+0xae>
 8002416:	9901      	ldr	r1, [sp, #4]
 8002418:	07c9      	lsls	r1, r1, #31
 800241a:	d506      	bpl.n	800242a <UART_RxISR_8BIT_FIFOEN+0xae>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800241c:	6213      	str	r3, [r2, #32]

          huart->ErrorCode |= HAL_UART_ERROR_NE;
 800241e:	0022      	movs	r2, r4
 8002420:	3290      	adds	r2, #144	@ 0x90
 8002422:	6811      	ldr	r1, [r2, #0]
 8002424:	3b02      	subs	r3, #2
 8002426:	430b      	orrs	r3, r1
 8002428:	6013      	str	r3, [r2, #0]
        }

        /* Call UART Error Call back function if need be ----------------------------*/
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800242a:	0027      	movs	r7, r4
 800242c:	3790      	adds	r7, #144	@ 0x90
 800242e:	683b      	ldr	r3, [r7, #0]
 8002430:	2b00      	cmp	r3, #0
 8002432:	d004      	beq.n	800243e <UART_RxISR_8BIT_FIFOEN+0xc2>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8002434:	0020      	movs	r0, r4
 8002436:	f7ff fd1e 	bl	8001e76 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 800243a:	2300      	movs	r3, #0
 800243c:	603b      	str	r3, [r7, #0]
        }
      }

      if (huart->RxXferCount == 0U)
 800243e:	0023      	movs	r3, r4
 8002440:	335e      	adds	r3, #94	@ 0x5e
 8002442:	881b      	ldrh	r3, [r3, #0]
 8002444:	b299      	uxth	r1, r3
 8002446:	2b00      	cmp	r3, #0
 8002448:	d1b1      	bne.n	80023ae <UART_RxISR_8BIT_FIFOEN+0x32>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800244a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800244e:	3301      	adds	r3, #1
 8002450:	f383 8810 	msr	PRIMASK, r3
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8002454:	6820      	ldr	r0, [r4, #0]
 8002456:	4f37      	ldr	r7, [pc, #220]	@ (8002534 <UART_RxISR_8BIT_FIFOEN+0x1b8>)
 8002458:	6802      	ldr	r2, [r0, #0]
 800245a:	403a      	ands	r2, r7
 800245c:	6002      	str	r2, [r0, #0]
 800245e:	f385 8810 	msr	PRIMASK, r5
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002462:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002466:	f383 8810 	msr	PRIMASK, r3

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800246a:	6820      	ldr	r0, [r4, #0]
 800246c:	4f32      	ldr	r7, [pc, #200]	@ (8002538 <UART_RxISR_8BIT_FIFOEN+0x1bc>)
 800246e:	6882      	ldr	r2, [r0, #8]
 8002470:	403a      	ands	r2, r7
 8002472:	6082      	str	r2, [r0, #8]
 8002474:	f385 8810 	msr	PRIMASK, r5

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8002478:	2220      	movs	r2, #32
 800247a:	6032      	str	r2, [r6, #0]

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        /* Check that USART RTOEN bit is set */
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800247c:	6822      	ldr	r2, [r4, #0]
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 800247e:	6721      	str	r1, [r4, #112]	@ 0x70
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002480:	6852      	ldr	r2, [r2, #4]
        huart->RxISR = NULL;
 8002482:	6761      	str	r1, [r4, #116]	@ 0x74
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002484:	0212      	lsls	r2, r2, #8
 8002486:	d50a      	bpl.n	800249e <UART_RxISR_8BIT_FIFOEN+0x122>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002488:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800248c:	f383 8810 	msr	PRIMASK, r3
        {
          /* Enable the UART Receiver Timeout Interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8002490:	6822      	ldr	r2, [r4, #0]
 8002492:	482a      	ldr	r0, [pc, #168]	@ (800253c <UART_RxISR_8BIT_FIFOEN+0x1c0>)
 8002494:	6813      	ldr	r3, [r2, #0]
 8002496:	4003      	ands	r3, r0
 8002498:	6013      	str	r3, [r2, #0]
 800249a:	f381 8810 	msr	PRIMASK, r1
        }

        /* Check current reception Mode :
           If Reception till IDLE event has been selected : */
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800249e:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 80024a0:	2b01      	cmp	r3, #1
 80024a2:	d13d      	bne.n	8002520 <UART_RxISR_8BIT_FIFOEN+0x1a4>
        {
          /* Set reception type to Standard */
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80024a4:	2200      	movs	r2, #0
 80024a6:	66e2      	str	r2, [r4, #108]	@ 0x6c
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80024a8:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80024ac:	f383 8810 	msr	PRIMASK, r3

          /* Disable IDLE interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80024b0:	6821      	ldr	r1, [r4, #0]
 80024b2:	330f      	adds	r3, #15
 80024b4:	680a      	ldr	r2, [r1, #0]
 80024b6:	439a      	bics	r2, r3
 80024b8:	600a      	str	r2, [r1, #0]
 80024ba:	f380 8810 	msr	PRIMASK, r0

          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80024be:	6822      	ldr	r2, [r4, #0]
 80024c0:	69d1      	ldr	r1, [r2, #28]
 80024c2:	4219      	tst	r1, r3
 80024c4:	d000      	beq.n	80024c8 <UART_RxISR_8BIT_FIFOEN+0x14c>
          {
            /* Clear IDLE Flag */
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80024c6:	6213      	str	r3, [r2, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx Event callback*/
          huart->RxEventCallback(huart, huart->RxXferSize);
#else
          /*Call legacy weak Rx Event callback*/
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80024c8:	0023      	movs	r3, r4
 80024ca:	335c      	adds	r3, #92	@ 0x5c
 80024cc:	0020      	movs	r0, r4
 80024ce:	8819      	ldrh	r1, [r3, #0]
 80024d0:	f7ff fcdb 	bl	8001e8a <HAL_UARTEx_RxEventCallback>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 80024d4:	0023      	movs	r3, r4
 80024d6:	335e      	adds	r3, #94	@ 0x5e
 80024d8:	881b      	ldrh	r3, [r3, #0]
 80024da:	b29a      	uxth	r2, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80024dc:	2b00      	cmp	r3, #0
 80024de:	d01d      	beq.n	800251c <UART_RxISR_8BIT_FIFOEN+0x1a0>
 80024e0:	0023      	movs	r3, r4
 80024e2:	3368      	adds	r3, #104	@ 0x68
 80024e4:	881b      	ldrh	r3, [r3, #0]
 80024e6:	4293      	cmp	r3, r2
 80024e8:	d918      	bls.n	800251c <UART_RxISR_8BIT_FIFOEN+0x1a0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80024ea:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80024ee:	2201      	movs	r2, #1
 80024f0:	f382 8810 	msr	PRIMASK, r2
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80024f4:	6821      	ldr	r1, [r4, #0]
 80024f6:	4d12      	ldr	r5, [pc, #72]	@ (8002540 <UART_RxISR_8BIT_FIFOEN+0x1c4>)
 80024f8:	688b      	ldr	r3, [r1, #8]
 80024fa:	402b      	ands	r3, r5
 80024fc:	608b      	str	r3, [r1, #8]
 80024fe:	f380 8810 	msr	PRIMASK, r0

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 8002502:	4b10      	ldr	r3, [pc, #64]	@ (8002544 <UART_RxISR_8BIT_FIFOEN+0x1c8>)
 8002504:	6763      	str	r3, [r4, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002506:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800250a:	f382 8810 	msr	PRIMASK, r2

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 800250e:	2320      	movs	r3, #32
 8002510:	6822      	ldr	r2, [r4, #0]
 8002512:	6810      	ldr	r0, [r2, #0]
 8002514:	4303      	orrs	r3, r0
 8002516:	6013      	str	r3, [r2, #0]
 8002518:	f381 8810 	msr	PRIMASK, r1
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800251c:	b005      	add	sp, #20
 800251e:	bdf0      	pop	{r4, r5, r6, r7, pc}
          HAL_UART_RxCpltCallback(huart);
 8002520:	0020      	movs	r0, r4
 8002522:	f7fd ff5d 	bl	80003e0 <HAL_UART_RxCpltCallback>
 8002526:	e7d5      	b.n	80024d4 <UART_RxISR_8BIT_FIFOEN+0x158>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8002528:	2208      	movs	r2, #8
 800252a:	6999      	ldr	r1, [r3, #24]
 800252c:	430a      	orrs	r2, r1
 800252e:	619a      	str	r2, [r3, #24]
}
 8002530:	e7f4      	b.n	800251c <UART_RxISR_8BIT_FIFOEN+0x1a0>
 8002532:	46c0      	nop			@ (mov r8, r8)
 8002534:	fffffeff 	.word	0xfffffeff
 8002538:	effffffe 	.word	0xeffffffe
 800253c:	fbffffff 	.word	0xfbffffff
 8002540:	efffffff 	.word	0xefffffff
 8002544:	080021d1 	.word	0x080021d1

08002548 <UART_RxISR_16BIT_FIFOEN>:
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
 8002548:	0003      	movs	r3, r0
{
 800254a:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800254c:	0006      	movs	r6, r0
  uint16_t  uhMask = huart->Mask;
 800254e:	3360      	adds	r3, #96	@ 0x60
 8002550:	881b      	ldrh	r3, [r3, #0]
{
 8002552:	b085      	sub	sp, #20
  uint16_t  uhMask = huart->Mask;
 8002554:	9302      	str	r3, [sp, #8]
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8002556:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8002558:	368c      	adds	r6, #140	@ 0x8c
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800255a:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 800255c:	681a      	ldr	r2, [r3, #0]
{
 800255e:	0004      	movs	r4, r0
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8002560:	9203      	str	r2, [sp, #12]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8002562:	689a      	ldr	r2, [r3, #8]
 8002564:	9201      	str	r2, [sp, #4]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8002566:	6832      	ldr	r2, [r6, #0]
 8002568:	2a22      	cmp	r2, #34	@ 0x22
 800256a:	d000      	beq.n	800256e <UART_RxISR_16BIT_FIFOEN+0x26>
 800256c:	e0c0      	b.n	80026f0 <UART_RxISR_16BIT_FIFOEN+0x1a8>
  {
    nb_rx_data = huart->NbRxDataToProcess;
 800256e:	0003      	movs	r3, r0
 8002570:	3368      	adds	r3, #104	@ 0x68
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8002572:	881b      	ldrh	r3, [r3, #0]
 8002574:	2b00      	cmp	r3, #0
 8002576:	d100      	bne.n	800257a <UART_RxISR_16BIT_FIFOEN+0x32>
 8002578:	e090      	b.n	800269c <UART_RxISR_16BIT_FIFOEN+0x154>
 800257a:	2320      	movs	r3, #32
 800257c:	421d      	tst	r5, r3
 800257e:	d100      	bne.n	8002582 <UART_RxISR_16BIT_FIFOEN+0x3a>
 8002580:	e08c      	b.n	800269c <UART_RxISR_16BIT_FIFOEN+0x154>
    {
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8002582:	6823      	ldr	r3, [r4, #0]
      tmp = (uint16_t *) huart->pRxBuffPtr ;
      *tmp = (uint16_t)(uhdata & uhMask);
 8002584:	9802      	ldr	r0, [sp, #8]
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8002586:	6a59      	ldr	r1, [r3, #36]	@ 0x24
      tmp = (uint16_t *) huart->pRxBuffPtr ;
 8002588:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      *tmp = (uint16_t)(uhdata & uhMask);
 800258a:	4001      	ands	r1, r0
 800258c:	8011      	strh	r1, [r2, #0]
      huart->pRxBuffPtr += 2U;
      huart->RxXferCount--;
 800258e:	0021      	movs	r1, r4
      huart->pRxBuffPtr += 2U;
 8002590:	3202      	adds	r2, #2
 8002592:	65a2      	str	r2, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 8002594:	315e      	adds	r1, #94	@ 0x5e
 8002596:	880a      	ldrh	r2, [r1, #0]
 8002598:	3a01      	subs	r2, #1
 800259a:	b292      	uxth	r2, r2
 800259c:	800a      	strh	r2, [r1, #0]
      isrflags = READ_REG(huart->Instance->ISR);

      /* If some non blocking errors occurred */
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 800259e:	2207      	movs	r2, #7
      isrflags = READ_REG(huart->Instance->ISR);
 80025a0:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 80025a2:	4215      	tst	r5, r2
 80025a4:	d02f      	beq.n	8002606 <UART_RxISR_16BIT_FIFOEN+0xbe>
      {
        /* UART parity error interrupt occurred -------------------------------------*/
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80025a6:	3a06      	subs	r2, #6
 80025a8:	4215      	tst	r5, r2
 80025aa:	d008      	beq.n	80025be <UART_RxISR_16BIT_FIFOEN+0x76>
 80025ac:	9903      	ldr	r1, [sp, #12]
 80025ae:	05c9      	lsls	r1, r1, #23
 80025b0:	d505      	bpl.n	80025be <UART_RxISR_16BIT_FIFOEN+0x76>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);

          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80025b2:	0021      	movs	r1, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80025b4:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 80025b6:	3190      	adds	r1, #144	@ 0x90
 80025b8:	6808      	ldr	r0, [r1, #0]
 80025ba:	4302      	orrs	r2, r0
 80025bc:	600a      	str	r2, [r1, #0]
        }

        /* UART frame error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80025be:	2202      	movs	r2, #2
 80025c0:	4215      	tst	r5, r2
 80025c2:	d009      	beq.n	80025d8 <UART_RxISR_16BIT_FIFOEN+0x90>
 80025c4:	9901      	ldr	r1, [sp, #4]
 80025c6:	07c9      	lsls	r1, r1, #31
 80025c8:	d506      	bpl.n	80025d8 <UART_RxISR_16BIT_FIFOEN+0x90>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);

          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80025ca:	0021      	movs	r1, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80025cc:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 80025ce:	3190      	adds	r1, #144	@ 0x90
 80025d0:	6808      	ldr	r0, [r1, #0]
 80025d2:	1892      	adds	r2, r2, r2
 80025d4:	4302      	orrs	r2, r0
 80025d6:	600a      	str	r2, [r1, #0]
        }

        /* UART noise error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80025d8:	2204      	movs	r2, #4
 80025da:	4215      	tst	r5, r2
 80025dc:	d009      	beq.n	80025f2 <UART_RxISR_16BIT_FIFOEN+0xaa>
 80025de:	9901      	ldr	r1, [sp, #4]
 80025e0:	07c9      	lsls	r1, r1, #31
 80025e2:	d506      	bpl.n	80025f2 <UART_RxISR_16BIT_FIFOEN+0xaa>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80025e4:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_NE;
 80025e6:	0022      	movs	r2, r4
 80025e8:	2302      	movs	r3, #2
 80025ea:	3290      	adds	r2, #144	@ 0x90
 80025ec:	6811      	ldr	r1, [r2, #0]
 80025ee:	430b      	orrs	r3, r1
 80025f0:	6013      	str	r3, [r2, #0]
        }

        /* Call UART Error Call back function if need be ----------------------------*/
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80025f2:	0027      	movs	r7, r4
 80025f4:	3790      	adds	r7, #144	@ 0x90
 80025f6:	683b      	ldr	r3, [r7, #0]
 80025f8:	2b00      	cmp	r3, #0
 80025fa:	d004      	beq.n	8002606 <UART_RxISR_16BIT_FIFOEN+0xbe>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 80025fc:	0020      	movs	r0, r4
 80025fe:	f7ff fc3a 	bl	8001e76 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002602:	2300      	movs	r3, #0
 8002604:	603b      	str	r3, [r7, #0]
        }
      }

      if (huart->RxXferCount == 0U)
 8002606:	0023      	movs	r3, r4
 8002608:	335e      	adds	r3, #94	@ 0x5e
 800260a:	881b      	ldrh	r3, [r3, #0]
 800260c:	b299      	uxth	r1, r3
 800260e:	2b00      	cmp	r3, #0
 8002610:	d1b3      	bne.n	800257a <UART_RxISR_16BIT_FIFOEN+0x32>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002612:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002616:	3301      	adds	r3, #1
 8002618:	f383 8810 	msr	PRIMASK, r3
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800261c:	6820      	ldr	r0, [r4, #0]
 800261e:	4f37      	ldr	r7, [pc, #220]	@ (80026fc <UART_RxISR_16BIT_FIFOEN+0x1b4>)
 8002620:	6802      	ldr	r2, [r0, #0]
 8002622:	403a      	ands	r2, r7
 8002624:	6002      	str	r2, [r0, #0]
 8002626:	f385 8810 	msr	PRIMASK, r5
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800262a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800262e:	f383 8810 	msr	PRIMASK, r3

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8002632:	6820      	ldr	r0, [r4, #0]
 8002634:	4f32      	ldr	r7, [pc, #200]	@ (8002700 <UART_RxISR_16BIT_FIFOEN+0x1b8>)
 8002636:	6882      	ldr	r2, [r0, #8]
 8002638:	403a      	ands	r2, r7
 800263a:	6082      	str	r2, [r0, #8]
 800263c:	f385 8810 	msr	PRIMASK, r5

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8002640:	2220      	movs	r2, #32
 8002642:	6032      	str	r2, [r6, #0]

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        /* Check that USART RTOEN bit is set */
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002644:	6822      	ldr	r2, [r4, #0]
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 8002646:	6721      	str	r1, [r4, #112]	@ 0x70
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002648:	6852      	ldr	r2, [r2, #4]
        huart->RxISR = NULL;
 800264a:	6761      	str	r1, [r4, #116]	@ 0x74
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800264c:	0212      	lsls	r2, r2, #8
 800264e:	d50a      	bpl.n	8002666 <UART_RxISR_16BIT_FIFOEN+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002650:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002654:	f383 8810 	msr	PRIMASK, r3
        {
          /* Enable the UART Receiver Timeout Interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8002658:	6822      	ldr	r2, [r4, #0]
 800265a:	482a      	ldr	r0, [pc, #168]	@ (8002704 <UART_RxISR_16BIT_FIFOEN+0x1bc>)
 800265c:	6813      	ldr	r3, [r2, #0]
 800265e:	4003      	ands	r3, r0
 8002660:	6013      	str	r3, [r2, #0]
 8002662:	f381 8810 	msr	PRIMASK, r1
        }

        /* Check current reception Mode :
           If Reception till IDLE event has been selected : */
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8002666:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 8002668:	2b01      	cmp	r3, #1
 800266a:	d13d      	bne.n	80026e8 <UART_RxISR_16BIT_FIFOEN+0x1a0>
        {
          /* Set reception type to Standard */
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800266c:	2200      	movs	r2, #0
 800266e:	66e2      	str	r2, [r4, #108]	@ 0x6c
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002670:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002674:	f383 8810 	msr	PRIMASK, r3

          /* Disable IDLE interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8002678:	6821      	ldr	r1, [r4, #0]
 800267a:	330f      	adds	r3, #15
 800267c:	680a      	ldr	r2, [r1, #0]
 800267e:	439a      	bics	r2, r3
 8002680:	600a      	str	r2, [r1, #0]
 8002682:	f380 8810 	msr	PRIMASK, r0

          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8002686:	6822      	ldr	r2, [r4, #0]
 8002688:	69d1      	ldr	r1, [r2, #28]
 800268a:	4219      	tst	r1, r3
 800268c:	d000      	beq.n	8002690 <UART_RxISR_16BIT_FIFOEN+0x148>
          {
            /* Clear IDLE Flag */
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800268e:	6213      	str	r3, [r2, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx Event callback*/
          huart->RxEventCallback(huart, huart->RxXferSize);
#else
          /*Call legacy weak Rx Event callback*/
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8002690:	0023      	movs	r3, r4
 8002692:	335c      	adds	r3, #92	@ 0x5c
 8002694:	0020      	movs	r0, r4
 8002696:	8819      	ldrh	r1, [r3, #0]
 8002698:	f7ff fbf7 	bl	8001e8a <HAL_UARTEx_RxEventCallback>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 800269c:	0023      	movs	r3, r4
 800269e:	335e      	adds	r3, #94	@ 0x5e
 80026a0:	881b      	ldrh	r3, [r3, #0]
 80026a2:	b29a      	uxth	r2, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 80026a4:	2b00      	cmp	r3, #0
 80026a6:	d01d      	beq.n	80026e4 <UART_RxISR_16BIT_FIFOEN+0x19c>
 80026a8:	0023      	movs	r3, r4
 80026aa:	3368      	adds	r3, #104	@ 0x68
 80026ac:	881b      	ldrh	r3, [r3, #0]
 80026ae:	4293      	cmp	r3, r2
 80026b0:	d918      	bls.n	80026e4 <UART_RxISR_16BIT_FIFOEN+0x19c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80026b2:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80026b6:	2201      	movs	r2, #1
 80026b8:	f382 8810 	msr	PRIMASK, r2
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 80026bc:	6821      	ldr	r1, [r4, #0]
 80026be:	4d12      	ldr	r5, [pc, #72]	@ (8002708 <UART_RxISR_16BIT_FIFOEN+0x1c0>)
 80026c0:	688b      	ldr	r3, [r1, #8]
 80026c2:	402b      	ands	r3, r5
 80026c4:	608b      	str	r3, [r1, #8]
 80026c6:	f380 8810 	msr	PRIMASK, r0

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 80026ca:	4b10      	ldr	r3, [pc, #64]	@ (800270c <UART_RxISR_16BIT_FIFOEN+0x1c4>)
 80026cc:	6763      	str	r3, [r4, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80026ce:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80026d2:	f382 8810 	msr	PRIMASK, r2

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80026d6:	2320      	movs	r3, #32
 80026d8:	6822      	ldr	r2, [r4, #0]
 80026da:	6810      	ldr	r0, [r2, #0]
 80026dc:	4303      	orrs	r3, r0
 80026de:	6013      	str	r3, [r2, #0]
 80026e0:	f381 8810 	msr	PRIMASK, r1
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80026e4:	b005      	add	sp, #20
 80026e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
          HAL_UART_RxCpltCallback(huart);
 80026e8:	0020      	movs	r0, r4
 80026ea:	f7fd fe79 	bl	80003e0 <HAL_UART_RxCpltCallback>
 80026ee:	e7d5      	b.n	800269c <UART_RxISR_16BIT_FIFOEN+0x154>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80026f0:	2208      	movs	r2, #8
 80026f2:	6999      	ldr	r1, [r3, #24]
 80026f4:	430a      	orrs	r2, r1
 80026f6:	619a      	str	r2, [r3, #24]
}
 80026f8:	e7f4      	b.n	80026e4 <UART_RxISR_16BIT_FIFOEN+0x19c>
 80026fa:	46c0      	nop			@ (mov r8, r8)
 80026fc:	fffffeff 	.word	0xfffffeff
 8002700:	effffffe 	.word	0xeffffffe
 8002704:	fbffffff 	.word	0xfbffffff
 8002708:	efffffff 	.word	0xefffffff
 800270c:	080022a9 	.word	0x080022a9

08002710 <UART_SetConfig>:
{
 8002710:	b570      	push	{r4, r5, r6, lr}
 8002712:	0004      	movs	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002714:	6925      	ldr	r5, [r4, #16]
 8002716:	68a1      	ldr	r1, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8002718:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800271a:	4329      	orrs	r1, r5
 800271c:	6965      	ldr	r5, [r4, #20]
 800271e:	69c2      	ldr	r2, [r0, #28]
 8002720:	4329      	orrs	r1, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8002722:	6818      	ldr	r0, [r3, #0]
 8002724:	4d50      	ldr	r5, [pc, #320]	@ (8002868 <UART_SetConfig+0x158>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002726:	4311      	orrs	r1, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8002728:	4028      	ands	r0, r5
 800272a:	4301      	orrs	r1, r0
 800272c:	6019      	str	r1, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800272e:	6859      	ldr	r1, [r3, #4]
 8002730:	484e      	ldr	r0, [pc, #312]	@ (800286c <UART_SetConfig+0x15c>)
  tmpreg |= huart->Init.OneBitSampling;
 8002732:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002734:	4001      	ands	r1, r0
 8002736:	68e0      	ldr	r0, [r4, #12]
 8002738:	4301      	orrs	r1, r0
 800273a:	6059      	str	r1, [r3, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800273c:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800273e:	6898      	ldr	r0, [r3, #8]
  tmpreg |= huart->Init.OneBitSampling;
 8002740:	4329      	orrs	r1, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8002742:	4d4b      	ldr	r5, [pc, #300]	@ (8002870 <UART_SetConfig+0x160>)
 8002744:	4028      	ands	r0, r5
 8002746:	4301      	orrs	r1, r0
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8002748:	200f      	movs	r0, #15
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800274a:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800274c:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800274e:	4381      	bics	r1, r0
 8002750:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8002752:	4301      	orrs	r1, r0
 8002754:	62d9      	str	r1, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002756:	4947      	ldr	r1, [pc, #284]	@ (8002874 <UART_SetConfig+0x164>)
 8002758:	428b      	cmp	r3, r1
 800275a:	d115      	bne.n	8002788 <UART_SetConfig+0x78>
 800275c:	2103      	movs	r1, #3
 800275e:	4b46      	ldr	r3, [pc, #280]	@ (8002878 <UART_SetConfig+0x168>)
 8002760:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002762:	400b      	ands	r3, r1
 8002764:	3b01      	subs	r3, #1
 8002766:	2b02      	cmp	r3, #2
 8002768:	d86f      	bhi.n	800284a <UART_SetConfig+0x13a>
 800276a:	4944      	ldr	r1, [pc, #272]	@ (800287c <UART_SetConfig+0x16c>)
 800276c:	5cc8      	ldrb	r0, [r1, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800276e:	2380      	movs	r3, #128	@ 0x80
 8002770:	021b      	lsls	r3, r3, #8
 8002772:	429a      	cmp	r2, r3
 8002774:	d137      	bne.n	80027e6 <UART_SetConfig+0xd6>
    switch (clocksource)
 8002776:	2808      	cmp	r0, #8
 8002778:	d865      	bhi.n	8002846 <UART_SetConfig+0x136>
 800277a:	f7fd fccd 	bl	8000118 <__gnu_thumb1_case_uqi>
 800277e:	646a      	.short	0x646a
 8002780:	6431640b 	.word	0x6431640b
 8002784:	6464      	.short	0x6464
 8002786:	14          	.byte	0x14
 8002787:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002788:	493d      	ldr	r1, [pc, #244]	@ (8002880 <UART_SetConfig+0x170>)
 800278a:	185b      	adds	r3, r3, r1
 800278c:	1e59      	subs	r1, r3, #1
 800278e:	418b      	sbcs	r3, r1
 8002790:	0118      	lsls	r0, r3, #4
 8002792:	e7ec      	b.n	800276e <UART_SetConfig+0x5e>
        pclk = (HSI_VALUE / ((__HAL_RCC_GET_HSIKER_DIVIDER() >> RCC_CR_HSIKERDIV_Pos) + 1U));
 8002794:	4b38      	ldr	r3, [pc, #224]	@ (8002878 <UART_SetConfig+0x168>)
 8002796:	483b      	ldr	r0, [pc, #236]	@ (8002884 <UART_SetConfig+0x174>)
 8002798:	6819      	ldr	r1, [r3, #0]
 800279a:	0609      	lsls	r1, r1, #24
 800279c:	0f49      	lsrs	r1, r1, #29
 800279e:	3101      	adds	r1, #1
 80027a0:	f7fd fcc4 	bl	800012c <__udivsi3>
 80027a4:	0002      	movs	r2, r0
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80027a6:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 80027a8:	4b37      	ldr	r3, [pc, #220]	@ (8002888 <UART_SetConfig+0x178>)
 80027aa:	0049      	lsls	r1, r1, #1
 80027ac:	0010      	movs	r0, r2
 80027ae:	5ac9      	ldrh	r1, [r1, r3]
 80027b0:	f7fd fcbc 	bl	800012c <__udivsi3>
 80027b4:	6865      	ldr	r5, [r4, #4]
 80027b6:	0040      	lsls	r0, r0, #1
 80027b8:	086b      	lsrs	r3, r5, #1
 80027ba:	18c0      	adds	r0, r0, r3
 80027bc:	0029      	movs	r1, r5
 80027be:	f7fd fcb5 	bl	800012c <__udivsi3>
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80027c2:	0002      	movs	r2, r0
 80027c4:	4b31      	ldr	r3, [pc, #196]	@ (800288c <UART_SetConfig+0x17c>)
 80027c6:	3a10      	subs	r2, #16
 80027c8:	429a      	cmp	r2, r3
 80027ca:	d83c      	bhi.n	8002846 <UART_SetConfig+0x136>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80027cc:	230f      	movs	r3, #15
 80027ce:	0002      	movs	r2, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80027d0:	0700      	lsls	r0, r0, #28
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80027d2:	439a      	bics	r2, r3
 80027d4:	b293      	uxth	r3, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80027d6:	0f40      	lsrs	r0, r0, #29
        huart->Instance->BRR = brrtemp;
 80027d8:	6822      	ldr	r2, [r4, #0]
 80027da:	4303      	orrs	r3, r0
 80027dc:	60d3      	str	r3, [r2, #12]
 80027de:	e03c      	b.n	800285a <UART_SetConfig+0x14a>
        pclk = HAL_RCC_GetSysClockFreq();
 80027e0:	f7fe fcae 	bl	8001140 <HAL_RCC_GetSysClockFreq>
 80027e4:	e037      	b.n	8002856 <UART_SetConfig+0x146>
    switch (clocksource)
 80027e6:	2808      	cmp	r0, #8
 80027e8:	d82d      	bhi.n	8002846 <UART_SetConfig+0x136>
 80027ea:	f7fd fc95 	bl	8000118 <__gnu_thumb1_case_uqi>
 80027ee:	2c05      	.short	0x2c05
 80027f0:	2c262c0a 	.word	0x2c262c0a
 80027f4:	2c2c      	.short	0x2c2c
 80027f6:	29          	.byte	0x29
 80027f7:	00          	.byte	0x00
        pclk = HAL_RCC_GetPCLK1Freq();
 80027f8:	f7fe fd88 	bl	800130c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80027fc:	2800      	cmp	r0, #0
 80027fe:	d02c      	beq.n	800285a <UART_SetConfig+0x14a>
 8002800:	e007      	b.n	8002812 <UART_SetConfig+0x102>
        pclk = (HSI_VALUE / ((__HAL_RCC_GET_HSIKER_DIVIDER() >> RCC_CR_HSIKERDIV_Pos) + 1U));
 8002802:	4b1d      	ldr	r3, [pc, #116]	@ (8002878 <UART_SetConfig+0x168>)
 8002804:	481f      	ldr	r0, [pc, #124]	@ (8002884 <UART_SetConfig+0x174>)
 8002806:	6819      	ldr	r1, [r3, #0]
 8002808:	0609      	lsls	r1, r1, #24
 800280a:	0f49      	lsrs	r1, r1, #29
 800280c:	3101      	adds	r1, #1
 800280e:	f7fd fc8d 	bl	800012c <__udivsi3>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8002812:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8002814:	4b1c      	ldr	r3, [pc, #112]	@ (8002888 <UART_SetConfig+0x178>)
 8002816:	0052      	lsls	r2, r2, #1
 8002818:	5ad1      	ldrh	r1, [r2, r3]
 800281a:	f7fd fc87 	bl	800012c <__udivsi3>
 800281e:	6865      	ldr	r5, [r4, #4]
 8002820:	086b      	lsrs	r3, r5, #1
 8002822:	18c0      	adds	r0, r0, r3
 8002824:	0029      	movs	r1, r5
 8002826:	f7fd fc81 	bl	800012c <__udivsi3>
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800282a:	0002      	movs	r2, r0
 800282c:	4b17      	ldr	r3, [pc, #92]	@ (800288c <UART_SetConfig+0x17c>)
 800282e:	3a10      	subs	r2, #16
 8002830:	429a      	cmp	r2, r3
 8002832:	d808      	bhi.n	8002846 <UART_SetConfig+0x136>
        huart->Instance->BRR = (uint16_t)usartdiv;
 8002834:	6823      	ldr	r3, [r4, #0]
 8002836:	60d8      	str	r0, [r3, #12]
 8002838:	e00f      	b.n	800285a <UART_SetConfig+0x14a>
        pclk = HAL_RCC_GetSysClockFreq();
 800283a:	f7fe fc81 	bl	8001140 <HAL_RCC_GetSysClockFreq>
        break;
 800283e:	e7dd      	b.n	80027fc <UART_SetConfig+0xec>
    switch (clocksource)
 8002840:	2080      	movs	r0, #128	@ 0x80
 8002842:	0200      	lsls	r0, r0, #8
 8002844:	e7e5      	b.n	8002812 <UART_SetConfig+0x102>
        ret = HAL_ERROR;
 8002846:	2001      	movs	r0, #1
 8002848:	e008      	b.n	800285c <UART_SetConfig+0x14c>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800284a:	2380      	movs	r3, #128	@ 0x80
 800284c:	021b      	lsls	r3, r3, #8
 800284e:	429a      	cmp	r2, r3
 8002850:	d1d2      	bne.n	80027f8 <UART_SetConfig+0xe8>
        pclk = HAL_RCC_GetPCLK1Freq();
 8002852:	f7fe fd5b 	bl	800130c <HAL_RCC_GetPCLK1Freq>
        pclk = HAL_RCC_GetSysClockFreq();
 8002856:	1e02      	subs	r2, r0, #0
    if (pclk != 0U)
 8002858:	d1a5      	bne.n	80027a6 <UART_SetConfig+0x96>
    switch (clocksource)
 800285a:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 800285c:	4b0c      	ldr	r3, [pc, #48]	@ (8002890 <UART_SetConfig+0x180>)
 800285e:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 8002860:	2300      	movs	r3, #0
 8002862:	6763      	str	r3, [r4, #116]	@ 0x74
  huart->TxISR = NULL;
 8002864:	67a3      	str	r3, [r4, #120]	@ 0x78
}
 8002866:	bd70      	pop	{r4, r5, r6, pc}
 8002868:	cfff69f3 	.word	0xcfff69f3
 800286c:	ffffcfff 	.word	0xffffcfff
 8002870:	11fff4ff 	.word	0x11fff4ff
 8002874:	40013800 	.word	0x40013800
 8002878:	40021000 	.word	0x40021000
 800287c:	08004a14 	.word	0x08004a14
 8002880:	bfffbc00 	.word	0xbfffbc00
 8002884:	02dc6c00 	.word	0x02dc6c00
 8002888:	08004a18 	.word	0x08004a18
 800288c:	0000ffef 	.word	0x0000ffef
 8002890:	00010001 	.word	0x00010001

08002894 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8002894:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
 8002896:	b530      	push	{r4, r5, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8002898:	071a      	lsls	r2, r3, #28
 800289a:	d506      	bpl.n	80028aa <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800289c:	6801      	ldr	r1, [r0, #0]
 800289e:	4c28      	ldr	r4, [pc, #160]	@ (8002940 <UART_AdvFeatureConfig+0xac>)
 80028a0:	684a      	ldr	r2, [r1, #4]
 80028a2:	4022      	ands	r2, r4
 80028a4:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 80028a6:	4322      	orrs	r2, r4
 80028a8:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80028aa:	07da      	lsls	r2, r3, #31
 80028ac:	d506      	bpl.n	80028bc <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80028ae:	6801      	ldr	r1, [r0, #0]
 80028b0:	4c24      	ldr	r4, [pc, #144]	@ (8002944 <UART_AdvFeatureConfig+0xb0>)
 80028b2:	684a      	ldr	r2, [r1, #4]
 80028b4:	4022      	ands	r2, r4
 80028b6:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 80028b8:	4322      	orrs	r2, r4
 80028ba:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80028bc:	079a      	lsls	r2, r3, #30
 80028be:	d506      	bpl.n	80028ce <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80028c0:	6801      	ldr	r1, [r0, #0]
 80028c2:	4c21      	ldr	r4, [pc, #132]	@ (8002948 <UART_AdvFeatureConfig+0xb4>)
 80028c4:	684a      	ldr	r2, [r1, #4]
 80028c6:	4022      	ands	r2, r4
 80028c8:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 80028ca:	4322      	orrs	r2, r4
 80028cc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80028ce:	075a      	lsls	r2, r3, #29
 80028d0:	d506      	bpl.n	80028e0 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80028d2:	6801      	ldr	r1, [r0, #0]
 80028d4:	4c1d      	ldr	r4, [pc, #116]	@ (800294c <UART_AdvFeatureConfig+0xb8>)
 80028d6:	684a      	ldr	r2, [r1, #4]
 80028d8:	4022      	ands	r2, r4
 80028da:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 80028dc:	4322      	orrs	r2, r4
 80028de:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80028e0:	06da      	lsls	r2, r3, #27
 80028e2:	d506      	bpl.n	80028f2 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80028e4:	6801      	ldr	r1, [r0, #0]
 80028e6:	4c1a      	ldr	r4, [pc, #104]	@ (8002950 <UART_AdvFeatureConfig+0xbc>)
 80028e8:	688a      	ldr	r2, [r1, #8]
 80028ea:	4022      	ands	r2, r4
 80028ec:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 80028ee:	4322      	orrs	r2, r4
 80028f0:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80028f2:	069a      	lsls	r2, r3, #26
 80028f4:	d506      	bpl.n	8002904 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80028f6:	6801      	ldr	r1, [r0, #0]
 80028f8:	4c16      	ldr	r4, [pc, #88]	@ (8002954 <UART_AdvFeatureConfig+0xc0>)
 80028fa:	688a      	ldr	r2, [r1, #8]
 80028fc:	4022      	ands	r2, r4
 80028fe:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 8002900:	4322      	orrs	r2, r4
 8002902:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8002904:	065a      	lsls	r2, r3, #25
 8002906:	d510      	bpl.n	800292a <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8002908:	6801      	ldr	r1, [r0, #0]
 800290a:	4d13      	ldr	r5, [pc, #76]	@ (8002958 <UART_AdvFeatureConfig+0xc4>)
 800290c:	684a      	ldr	r2, [r1, #4]
 800290e:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 8002910:	402a      	ands	r2, r5
 8002912:	4322      	orrs	r2, r4
 8002914:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8002916:	2280      	movs	r2, #128	@ 0x80
 8002918:	0352      	lsls	r2, r2, #13
 800291a:	4294      	cmp	r4, r2
 800291c:	d105      	bne.n	800292a <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800291e:	684a      	ldr	r2, [r1, #4]
 8002920:	4c0e      	ldr	r4, [pc, #56]	@ (800295c <UART_AdvFeatureConfig+0xc8>)
 8002922:	4022      	ands	r2, r4
 8002924:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 8002926:	4322      	orrs	r2, r4
 8002928:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800292a:	061b      	lsls	r3, r3, #24
 800292c:	d506      	bpl.n	800293c <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800292e:	6802      	ldr	r2, [r0, #0]
 8002930:	490b      	ldr	r1, [pc, #44]	@ (8002960 <UART_AdvFeatureConfig+0xcc>)
 8002932:	6853      	ldr	r3, [r2, #4]
 8002934:	400b      	ands	r3, r1
 8002936:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 8002938:	430b      	orrs	r3, r1
 800293a:	6053      	str	r3, [r2, #4]
}
 800293c:	bd30      	pop	{r4, r5, pc}
 800293e:	46c0      	nop			@ (mov r8, r8)
 8002940:	ffff7fff 	.word	0xffff7fff
 8002944:	fffdffff 	.word	0xfffdffff
 8002948:	fffeffff 	.word	0xfffeffff
 800294c:	fffbffff 	.word	0xfffbffff
 8002950:	ffffefff 	.word	0xffffefff
 8002954:	ffffdfff 	.word	0xffffdfff
 8002958:	ffefffff 	.word	0xffefffff
 800295c:	ff9fffff 	.word	0xff9fffff
 8002960:	fff7ffff 	.word	0xfff7ffff

08002964 <UART_WaitOnFlagUntilTimeout>:
{
 8002964:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8002966:	0004      	movs	r4, r0
 8002968:	000d      	movs	r5, r1
 800296a:	0017      	movs	r7, r2
 800296c:	9300      	str	r3, [sp, #0]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800296e:	6822      	ldr	r2, [r4, #0]
 8002970:	69d3      	ldr	r3, [r2, #28]
 8002972:	402b      	ands	r3, r5
 8002974:	1b5b      	subs	r3, r3, r5
 8002976:	4259      	negs	r1, r3
 8002978:	414b      	adcs	r3, r1
 800297a:	42bb      	cmp	r3, r7
 800297c:	d001      	beq.n	8002982 <UART_WaitOnFlagUntilTimeout+0x1e>
  return HAL_OK;
 800297e:	2000      	movs	r0, #0
 8002980:	e026      	b.n	80029d0 <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
 8002982:	9b08      	ldr	r3, [sp, #32]
 8002984:	3301      	adds	r3, #1
 8002986:	d0f3      	beq.n	8002970 <UART_WaitOnFlagUntilTimeout+0xc>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002988:	f7fe f8ee 	bl	8000b68 <HAL_GetTick>
 800298c:	9b00      	ldr	r3, [sp, #0]
 800298e:	1ac0      	subs	r0, r0, r3
 8002990:	9b08      	ldr	r3, [sp, #32]
 8002992:	4298      	cmp	r0, r3
 8002994:	d82d      	bhi.n	80029f2 <UART_WaitOnFlagUntilTimeout+0x8e>
 8002996:	2b00      	cmp	r3, #0
 8002998:	d02b      	beq.n	80029f2 <UART_WaitOnFlagUntilTimeout+0x8e>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 800299a:	6823      	ldr	r3, [r4, #0]
 800299c:	681a      	ldr	r2, [r3, #0]
 800299e:	0752      	lsls	r2, r2, #29
 80029a0:	d5e5      	bpl.n	800296e <UART_WaitOnFlagUntilTimeout+0xa>
 80029a2:	002a      	movs	r2, r5
 80029a4:	2140      	movs	r1, #64	@ 0x40
 80029a6:	3a40      	subs	r2, #64	@ 0x40
 80029a8:	438a      	bics	r2, r1
 80029aa:	d0e0      	beq.n	800296e <UART_WaitOnFlagUntilTimeout+0xa>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80029ac:	69da      	ldr	r2, [r3, #28]
 80029ae:	2608      	movs	r6, #8
 80029b0:	0011      	movs	r1, r2
 80029b2:	4031      	ands	r1, r6
 80029b4:	9101      	str	r1, [sp, #4]
 80029b6:	4232      	tst	r2, r6
 80029b8:	d00b      	beq.n	80029d2 <UART_WaitOnFlagUntilTimeout+0x6e>
          UART_EndRxTransfer(huart);
 80029ba:	0020      	movs	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80029bc:	621e      	str	r6, [r3, #32]
          UART_EndRxTransfer(huart);
 80029be:	f7ff fa27 	bl	8001e10 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 80029c2:	0023      	movs	r3, r4
 80029c4:	3390      	adds	r3, #144	@ 0x90
 80029c6:	601e      	str	r6, [r3, #0]
          __HAL_UNLOCK(huart);
 80029c8:	2300      	movs	r3, #0
          return HAL_ERROR;
 80029ca:	2001      	movs	r0, #1
          __HAL_UNLOCK(huart);
 80029cc:	3484      	adds	r4, #132	@ 0x84
 80029ce:	7023      	strb	r3, [r4, #0]
}
 80029d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80029d2:	2280      	movs	r2, #128	@ 0x80
 80029d4:	69d9      	ldr	r1, [r3, #28]
 80029d6:	0112      	lsls	r2, r2, #4
 80029d8:	4211      	tst	r1, r2
 80029da:	d0c8      	beq.n	800296e <UART_WaitOnFlagUntilTimeout+0xa>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80029dc:	621a      	str	r2, [r3, #32]
          UART_EndRxTransfer(huart);
 80029de:	0020      	movs	r0, r4
 80029e0:	f7ff fa16 	bl	8001e10 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80029e4:	0023      	movs	r3, r4
 80029e6:	2220      	movs	r2, #32
 80029e8:	3390      	adds	r3, #144	@ 0x90
 80029ea:	601a      	str	r2, [r3, #0]
          __HAL_UNLOCK(huart);
 80029ec:	9b01      	ldr	r3, [sp, #4]
 80029ee:	3484      	adds	r4, #132	@ 0x84
 80029f0:	7023      	strb	r3, [r4, #0]
        return HAL_TIMEOUT;
 80029f2:	2003      	movs	r0, #3
 80029f4:	e7ec      	b.n	80029d0 <UART_WaitOnFlagUntilTimeout+0x6c>

080029f6 <HAL_UART_Transmit>:
{
 80029f6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80029f8:	0017      	movs	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 80029fa:	0002      	movs	r2, r0
{
 80029fc:	b087      	sub	sp, #28
  if (huart->gState == HAL_UART_STATE_READY)
 80029fe:	3288      	adds	r2, #136	@ 0x88
{
 8002a00:	9305      	str	r3, [sp, #20]
  if (huart->gState == HAL_UART_STATE_READY)
 8002a02:	6813      	ldr	r3, [r2, #0]
{
 8002a04:	0004      	movs	r4, r0
 8002a06:	000d      	movs	r5, r1
    return HAL_BUSY;
 8002a08:	2002      	movs	r0, #2
  if (huart->gState == HAL_UART_STATE_READY)
 8002a0a:	2b20      	cmp	r3, #32
 8002a0c:	d139      	bne.n	8002a82 <HAL_UART_Transmit+0x8c>
      return  HAL_ERROR;
 8002a0e:	3801      	subs	r0, #1
    if ((pData == NULL) || (Size == 0U))
 8002a10:	2900      	cmp	r1, #0
 8002a12:	d036      	beq.n	8002a82 <HAL_UART_Transmit+0x8c>
 8002a14:	2f00      	cmp	r7, #0
 8002a16:	d034      	beq.n	8002a82 <HAL_UART_Transmit+0x8c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002a18:	2380      	movs	r3, #128	@ 0x80
 8002a1a:	68a1      	ldr	r1, [r4, #8]
 8002a1c:	015b      	lsls	r3, r3, #5
 8002a1e:	4299      	cmp	r1, r3
 8002a20:	d104      	bne.n	8002a2c <HAL_UART_Transmit+0x36>
 8002a22:	6923      	ldr	r3, [r4, #16]
 8002a24:	2b00      	cmp	r3, #0
 8002a26:	d101      	bne.n	8002a2c <HAL_UART_Transmit+0x36>
      if ((((uint32_t)pData) & 1U) != 0U)
 8002a28:	4205      	tst	r5, r0
 8002a2a:	d12a      	bne.n	8002a82 <HAL_UART_Transmit+0x8c>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002a2c:	0023      	movs	r3, r4
 8002a2e:	2600      	movs	r6, #0
 8002a30:	3390      	adds	r3, #144	@ 0x90
 8002a32:	601e      	str	r6, [r3, #0]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002a34:	2321      	movs	r3, #33	@ 0x21
 8002a36:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002a38:	f7fe f896 	bl	8000b68 <HAL_GetTick>
    huart->TxXferSize  = Size;
 8002a3c:	0023      	movs	r3, r4
 8002a3e:	3354      	adds	r3, #84	@ 0x54
 8002a40:	801f      	strh	r7, [r3, #0]
    huart->TxXferCount = Size;
 8002a42:	3302      	adds	r3, #2
 8002a44:	9303      	str	r3, [sp, #12]
 8002a46:	801f      	strh	r7, [r3, #0]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002a48:	2380      	movs	r3, #128	@ 0x80
 8002a4a:	68a2      	ldr	r2, [r4, #8]
    tickstart = HAL_GetTick();
 8002a4c:	9004      	str	r0, [sp, #16]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002a4e:	015b      	lsls	r3, r3, #5
 8002a50:	429a      	cmp	r2, r3
 8002a52:	d104      	bne.n	8002a5e <HAL_UART_Transmit+0x68>
 8002a54:	6923      	ldr	r3, [r4, #16]
 8002a56:	42b3      	cmp	r3, r6
 8002a58:	d101      	bne.n	8002a5e <HAL_UART_Transmit+0x68>
      pdata16bits = (const uint16_t *) pData;
 8002a5a:	002e      	movs	r6, r5
      pdata8bits  = NULL;
 8002a5c:	001d      	movs	r5, r3
    while (huart->TxXferCount > 0U)
 8002a5e:	0023      	movs	r3, r4
 8002a60:	3356      	adds	r3, #86	@ 0x56
 8002a62:	881b      	ldrh	r3, [r3, #0]
 8002a64:	b29a      	uxth	r2, r3
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	d10d      	bne.n	8002a86 <HAL_UART_Transmit+0x90>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8002a6a:	9b05      	ldr	r3, [sp, #20]
 8002a6c:	0020      	movs	r0, r4
 8002a6e:	9300      	str	r3, [sp, #0]
 8002a70:	2140      	movs	r1, #64	@ 0x40
 8002a72:	9b04      	ldr	r3, [sp, #16]
 8002a74:	f7ff ff76 	bl	8002964 <UART_WaitOnFlagUntilTimeout>
 8002a78:	2320      	movs	r3, #32
 8002a7a:	3488      	adds	r4, #136	@ 0x88
      huart->gState = HAL_UART_STATE_READY;
 8002a7c:	6023      	str	r3, [r4, #0]
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8002a7e:	2800      	cmp	r0, #0
 8002a80:	d10e      	bne.n	8002aa0 <HAL_UART_Transmit+0xaa>
}
 8002a82:	b007      	add	sp, #28
 8002a84:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8002a86:	9b05      	ldr	r3, [sp, #20]
 8002a88:	2200      	movs	r2, #0
 8002a8a:	9300      	str	r3, [sp, #0]
 8002a8c:	2180      	movs	r1, #128	@ 0x80
 8002a8e:	0020      	movs	r0, r4
 8002a90:	9b04      	ldr	r3, [sp, #16]
 8002a92:	f7ff ff67 	bl	8002964 <UART_WaitOnFlagUntilTimeout>
 8002a96:	2800      	cmp	r0, #0
 8002a98:	d004      	beq.n	8002aa4 <HAL_UART_Transmit+0xae>
        huart->gState = HAL_UART_STATE_READY;
 8002a9a:	2320      	movs	r3, #32
 8002a9c:	3488      	adds	r4, #136	@ 0x88
 8002a9e:	6023      	str	r3, [r4, #0]
        return HAL_TIMEOUT;
 8002aa0:	2003      	movs	r0, #3
 8002aa2:	e7ee      	b.n	8002a82 <HAL_UART_Transmit+0x8c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8002aa4:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 8002aa6:	2d00      	cmp	r5, #0
 8002aa8:	d10b      	bne.n	8002ac2 <HAL_UART_Transmit+0xcc>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8002aaa:	8833      	ldrh	r3, [r6, #0]
        pdata16bits++;
 8002aac:	3602      	adds	r6, #2
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8002aae:	05db      	lsls	r3, r3, #23
 8002ab0:	0ddb      	lsrs	r3, r3, #23
 8002ab2:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 8002ab4:	9b03      	ldr	r3, [sp, #12]
 8002ab6:	9a03      	ldr	r2, [sp, #12]
 8002ab8:	881b      	ldrh	r3, [r3, #0]
 8002aba:	3b01      	subs	r3, #1
 8002abc:	b29b      	uxth	r3, r3
 8002abe:	8013      	strh	r3, [r2, #0]
 8002ac0:	e7cd      	b.n	8002a5e <HAL_UART_Transmit+0x68>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8002ac2:	782b      	ldrb	r3, [r5, #0]
        pdata8bits++;
 8002ac4:	3501      	adds	r5, #1
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8002ac6:	6293      	str	r3, [r2, #40]	@ 0x28
        pdata8bits++;
 8002ac8:	e7f4      	b.n	8002ab4 <HAL_UART_Transmit+0xbe>
	...

08002acc <UART_CheckIdleState>:
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002acc:	0003      	movs	r3, r0
{
 8002ace:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002ad0:	2600      	movs	r6, #0
{
 8002ad2:	0004      	movs	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002ad4:	3390      	adds	r3, #144	@ 0x90
 8002ad6:	601e      	str	r6, [r3, #0]
  tickstart = HAL_GetTick();
 8002ad8:	f7fe f846 	bl	8000b68 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8002adc:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8002ade:	0005      	movs	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8002ae0:	681b      	ldr	r3, [r3, #0]
 8002ae2:	071b      	lsls	r3, r3, #28
 8002ae4:	d51f      	bpl.n	8002b26 <UART_CheckIdleState+0x5a>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8002ae6:	2180      	movs	r1, #128	@ 0x80
 8002ae8:	4b28      	ldr	r3, [pc, #160]	@ (8002b8c <UART_CheckIdleState+0xc0>)
 8002aea:	0032      	movs	r2, r6
 8002aec:	9300      	str	r3, [sp, #0]
 8002aee:	0389      	lsls	r1, r1, #14
 8002af0:	0003      	movs	r3, r0
 8002af2:	0020      	movs	r0, r4
 8002af4:	f7ff ff36 	bl	8002964 <UART_WaitOnFlagUntilTimeout>
 8002af8:	42b0      	cmp	r0, r6
 8002afa:	d014      	beq.n	8002b26 <UART_CheckIdleState+0x5a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002afc:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002b00:	2301      	movs	r3, #1
 8002b02:	f383 8810 	msr	PRIMASK, r3
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8002b06:	2080      	movs	r0, #128	@ 0x80
 8002b08:	6822      	ldr	r2, [r4, #0]
 8002b0a:	6813      	ldr	r3, [r2, #0]
 8002b0c:	4383      	bics	r3, r0
 8002b0e:	6013      	str	r3, [r2, #0]
 8002b10:	f381 8810 	msr	PRIMASK, r1
      huart->gState = HAL_UART_STATE_READY;
 8002b14:	0023      	movs	r3, r4
 8002b16:	2220      	movs	r2, #32
 8002b18:	3388      	adds	r3, #136	@ 0x88
 8002b1a:	601a      	str	r2, [r3, #0]
      return HAL_TIMEOUT;
 8002b1c:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
 8002b1e:	2300      	movs	r3, #0
 8002b20:	3484      	adds	r4, #132	@ 0x84
 8002b22:	7023      	strb	r3, [r4, #0]
}
 8002b24:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8002b26:	0026      	movs	r6, r4
 8002b28:	6823      	ldr	r3, [r4, #0]
 8002b2a:	368c      	adds	r6, #140	@ 0x8c
 8002b2c:	681b      	ldr	r3, [r3, #0]
 8002b2e:	075b      	lsls	r3, r3, #29
 8002b30:	d523      	bpl.n	8002b7a <UART_CheckIdleState+0xae>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8002b32:	2180      	movs	r1, #128	@ 0x80
 8002b34:	4b15      	ldr	r3, [pc, #84]	@ (8002b8c <UART_CheckIdleState+0xc0>)
 8002b36:	2200      	movs	r2, #0
 8002b38:	9300      	str	r3, [sp, #0]
 8002b3a:	0020      	movs	r0, r4
 8002b3c:	002b      	movs	r3, r5
 8002b3e:	03c9      	lsls	r1, r1, #15
 8002b40:	f7ff ff10 	bl	8002964 <UART_WaitOnFlagUntilTimeout>
 8002b44:	2800      	cmp	r0, #0
 8002b46:	d018      	beq.n	8002b7a <UART_CheckIdleState+0xae>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002b48:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002b4c:	2201      	movs	r2, #1
 8002b4e:	f382 8810 	msr	PRIMASK, r2
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8002b52:	6821      	ldr	r1, [r4, #0]
 8002b54:	4d0e      	ldr	r5, [pc, #56]	@ (8002b90 <UART_CheckIdleState+0xc4>)
 8002b56:	680b      	ldr	r3, [r1, #0]
 8002b58:	402b      	ands	r3, r5
 8002b5a:	600b      	str	r3, [r1, #0]
 8002b5c:	f380 8810 	msr	PRIMASK, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002b60:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002b64:	f382 8810 	msr	PRIMASK, r2
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002b68:	6821      	ldr	r1, [r4, #0]
 8002b6a:	688b      	ldr	r3, [r1, #8]
 8002b6c:	4393      	bics	r3, r2
 8002b6e:	608b      	str	r3, [r1, #8]
 8002b70:	f380 8810 	msr	PRIMASK, r0
      huart->RxState = HAL_UART_STATE_READY;
 8002b74:	2320      	movs	r3, #32
 8002b76:	6033      	str	r3, [r6, #0]
      return HAL_TIMEOUT;
 8002b78:	e7d0      	b.n	8002b1c <UART_CheckIdleState+0x50>
  huart->gState = HAL_UART_STATE_READY;
 8002b7a:	0023      	movs	r3, r4
 8002b7c:	2220      	movs	r2, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002b7e:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8002b80:	3388      	adds	r3, #136	@ 0x88
 8002b82:	601a      	str	r2, [r3, #0]
  huart->RxState = HAL_UART_STATE_READY;
 8002b84:	6032      	str	r2, [r6, #0]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002b86:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8002b88:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
 8002b8a:	e7c8      	b.n	8002b1e <UART_CheckIdleState+0x52>
 8002b8c:	01ffffff 	.word	0x01ffffff
 8002b90:	fffffedf 	.word	0xfffffedf

08002b94 <HAL_UART_Init>:
{
 8002b94:	b570      	push	{r4, r5, r6, lr}
 8002b96:	1e04      	subs	r4, r0, #0
  if (huart == NULL)
 8002b98:	d101      	bne.n	8002b9e <HAL_UART_Init+0xa>
    return HAL_ERROR;
 8002b9a:	2001      	movs	r0, #1
}
 8002b9c:	bd70      	pop	{r4, r5, r6, pc}
  if (huart->gState == HAL_UART_STATE_RESET)
 8002b9e:	0005      	movs	r5, r0
 8002ba0:	3588      	adds	r5, #136	@ 0x88
 8002ba2:	682b      	ldr	r3, [r5, #0]
 8002ba4:	2b00      	cmp	r3, #0
 8002ba6:	d104      	bne.n	8002bb2 <HAL_UART_Init+0x1e>
    huart->Lock = HAL_UNLOCKED;
 8002ba8:	0002      	movs	r2, r0
 8002baa:	3284      	adds	r2, #132	@ 0x84
 8002bac:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 8002bae:	f7fd fe1f 	bl	80007f0 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 8002bb2:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 8002bb4:	2101      	movs	r1, #1
 8002bb6:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002bb8:	602b      	str	r3, [r5, #0]
  __HAL_UART_DISABLE(huart);
 8002bba:	6813      	ldr	r3, [r2, #0]
 8002bbc:	438b      	bics	r3, r1
 8002bbe:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8002bc0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8002bc2:	2b00      	cmp	r3, #0
 8002bc4:	d002      	beq.n	8002bcc <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 8002bc6:	0020      	movs	r0, r4
 8002bc8:	f7ff fe64 	bl	8002894 <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
 8002bcc:	0020      	movs	r0, r4
 8002bce:	f7ff fd9f 	bl	8002710 <UART_SetConfig>
 8002bd2:	2801      	cmp	r0, #1
 8002bd4:	d0e1      	beq.n	8002b9a <HAL_UART_Init+0x6>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002bd6:	6823      	ldr	r3, [r4, #0]
 8002bd8:	4907      	ldr	r1, [pc, #28]	@ (8002bf8 <HAL_UART_Init+0x64>)
 8002bda:	685a      	ldr	r2, [r3, #4]
  return (UART_CheckIdleState(huart));
 8002bdc:	0020      	movs	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002bde:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002be0:	212a      	movs	r1, #42	@ 0x2a
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002be2:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002be4:	689a      	ldr	r2, [r3, #8]
 8002be6:	438a      	bics	r2, r1
 8002be8:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8002bea:	2201      	movs	r2, #1
 8002bec:	6819      	ldr	r1, [r3, #0]
 8002bee:	430a      	orrs	r2, r1
 8002bf0:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 8002bf2:	f7ff ff6b 	bl	8002acc <UART_CheckIdleState>
 8002bf6:	e7d1      	b.n	8002b9c <HAL_UART_Init+0x8>
 8002bf8:	ffffb7ff 	.word	0xffffb7ff

08002bfc <UART_Start_Receive_IT>:
  huart->RxXferSize  = Size;
 8002bfc:	0003      	movs	r3, r0
 8002bfe:	335c      	adds	r3, #92	@ 0x5c
{
 8002c00:	b570      	push	{r4, r5, r6, lr}
  huart->pRxBuffPtr  = pData;
 8002c02:	6581      	str	r1, [r0, #88]	@ 0x58
  UART_MASK_COMPUTATION(huart);
 8002c04:	2480      	movs	r4, #128	@ 0x80
  huart->RxXferSize  = Size;
 8002c06:	801a      	strh	r2, [r3, #0]
  huart->RxXferCount = Size;
 8002c08:	805a      	strh	r2, [r3, #2]
  huart->RxISR       = NULL;
 8002c0a:	2300      	movs	r3, #0
  UART_MASK_COMPUTATION(huart);
 8002c0c:	6881      	ldr	r1, [r0, #8]
  huart->RxISR       = NULL;
 8002c0e:	6743      	str	r3, [r0, #116]	@ 0x74
  UART_MASK_COMPUTATION(huart);
 8002c10:	0164      	lsls	r4, r4, #5
 8002c12:	42a1      	cmp	r1, r4
 8002c14:	d13c      	bne.n	8002c90 <UART_Start_Receive_IT+0x94>
 8002c16:	6903      	ldr	r3, [r0, #16]
 8002c18:	4259      	negs	r1, r3
 8002c1a:	414b      	adcs	r3, r1
 8002c1c:	021b      	lsls	r3, r3, #8
 8002c1e:	33ff      	adds	r3, #255	@ 0xff
 8002c20:	0001      	movs	r1, r0
 8002c22:	3160      	adds	r1, #96	@ 0x60
 8002c24:	800b      	strh	r3, [r1, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002c26:	0003      	movs	r3, r0
 8002c28:	2100      	movs	r1, #0
 8002c2a:	3390      	adds	r3, #144	@ 0x90
 8002c2c:	6019      	str	r1, [r3, #0]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002c2e:	3122      	adds	r1, #34	@ 0x22
 8002c30:	3b04      	subs	r3, #4
 8002c32:	6019      	str	r1, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002c34:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002c38:	2301      	movs	r3, #1
 8002c3a:	f383 8810 	msr	PRIMASK, r3
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002c3e:	6801      	ldr	r1, [r0, #0]
 8002c40:	688d      	ldr	r5, [r1, #8]
 8002c42:	432b      	orrs	r3, r5
 8002c44:	608b      	str	r3, [r1, #8]
 8002c46:	f384 8810 	msr	PRIMASK, r4
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 8002c4a:	2580      	movs	r5, #128	@ 0x80
 8002c4c:	2180      	movs	r1, #128	@ 0x80
 8002c4e:	6e46      	ldr	r6, [r0, #100]	@ 0x64
 8002c50:	6884      	ldr	r4, [r0, #8]
 8002c52:	6903      	ldr	r3, [r0, #16]
 8002c54:	05ad      	lsls	r5, r5, #22
 8002c56:	0149      	lsls	r1, r1, #5
 8002c58:	42ae      	cmp	r6, r5
 8002c5a:	d13f      	bne.n	8002cdc <UART_Start_Receive_IT+0xe0>
 8002c5c:	0005      	movs	r5, r0
 8002c5e:	3568      	adds	r5, #104	@ 0x68
 8002c60:	882d      	ldrh	r5, [r5, #0]
 8002c62:	4295      	cmp	r5, r2
 8002c64:	d83a      	bhi.n	8002cdc <UART_Start_Receive_IT+0xe0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002c66:	428c      	cmp	r4, r1
 8002c68:	d133      	bne.n	8002cd2 <UART_Start_Receive_IT+0xd6>
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	d122      	bne.n	8002cb4 <UART_Start_Receive_IT+0xb8>
 8002c6e:	4b2c      	ldr	r3, [pc, #176]	@ (8002d20 <UART_Start_Receive_IT+0x124>)
 8002c70:	6743      	str	r3, [r0, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002c72:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002c76:	2301      	movs	r3, #1
 8002c78:	f383 8810 	msr	PRIMASK, r3
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8002c7c:	2380      	movs	r3, #128	@ 0x80
 8002c7e:	6802      	ldr	r2, [r0, #0]
 8002c80:	055b      	lsls	r3, r3, #21
 8002c82:	6890      	ldr	r0, [r2, #8]
 8002c84:	4303      	orrs	r3, r0
 8002c86:	6093      	str	r3, [r2, #8]
 8002c88:	f381 8810 	msr	PRIMASK, r1
}
 8002c8c:	2000      	movs	r0, #0
 8002c8e:	bd70      	pop	{r4, r5, r6, pc}
  UART_MASK_COMPUTATION(huart);
 8002c90:	2900      	cmp	r1, #0
 8002c92:	d105      	bne.n	8002ca0 <UART_Start_Receive_IT+0xa4>
 8002c94:	6901      	ldr	r1, [r0, #16]
 8002c96:	23ff      	movs	r3, #255	@ 0xff
 8002c98:	2900      	cmp	r1, #0
 8002c9a:	d0c1      	beq.n	8002c20 <UART_Start_Receive_IT+0x24>
 8002c9c:	3b80      	subs	r3, #128	@ 0x80
 8002c9e:	e7bf      	b.n	8002c20 <UART_Start_Receive_IT+0x24>
 8002ca0:	2480      	movs	r4, #128	@ 0x80
 8002ca2:	0564      	lsls	r4, r4, #21
 8002ca4:	42a1      	cmp	r1, r4
 8002ca6:	d1bb      	bne.n	8002c20 <UART_Start_Receive_IT+0x24>
 8002ca8:	6901      	ldr	r1, [r0, #16]
 8002caa:	237f      	movs	r3, #127	@ 0x7f
 8002cac:	2900      	cmp	r1, #0
 8002cae:	d0b7      	beq.n	8002c20 <UART_Start_Receive_IT+0x24>
 8002cb0:	3b40      	subs	r3, #64	@ 0x40
 8002cb2:	e7b5      	b.n	8002c20 <UART_Start_Receive_IT+0x24>
 8002cb4:	4b1b      	ldr	r3, [pc, #108]	@ (8002d24 <UART_Start_Receive_IT+0x128>)
 8002cb6:	6743      	str	r3, [r0, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002cb8:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002cbc:	2301      	movs	r3, #1
 8002cbe:	f383 8810 	msr	PRIMASK, r3
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8002cc2:	6802      	ldr	r2, [r0, #0]
 8002cc4:	33ff      	adds	r3, #255	@ 0xff
 8002cc6:	6814      	ldr	r4, [r2, #0]
 8002cc8:	4323      	orrs	r3, r4
 8002cca:	6013      	str	r3, [r2, #0]
 8002ccc:	f381 8810 	msr	PRIMASK, r1
}
 8002cd0:	e7cf      	b.n	8002c72 <UART_Start_Receive_IT+0x76>
 8002cd2:	4a14      	ldr	r2, [pc, #80]	@ (8002d24 <UART_Start_Receive_IT+0x128>)
 8002cd4:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 8002cd6:	2b00      	cmp	r3, #0
 8002cd8:	d0cb      	beq.n	8002c72 <UART_Start_Receive_IT+0x76>
 8002cda:	e7ed      	b.n	8002cb8 <UART_Start_Receive_IT+0xbc>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002cdc:	428c      	cmp	r4, r1
 8002cde:	d11a      	bne.n	8002d16 <UART_Start_Receive_IT+0x11a>
 8002ce0:	2b00      	cmp	r3, #0
 8002ce2:	d10a      	bne.n	8002cfa <UART_Start_Receive_IT+0xfe>
 8002ce4:	4b10      	ldr	r3, [pc, #64]	@ (8002d28 <UART_Start_Receive_IT+0x12c>)
 8002ce6:	6743      	str	r3, [r0, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002ce8:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002cec:	2301      	movs	r3, #1
 8002cee:	f383 8810 	msr	PRIMASK, r3
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8002cf2:	6802      	ldr	r2, [r0, #0]
 8002cf4:	331f      	adds	r3, #31
 8002cf6:	6810      	ldr	r0, [r2, #0]
 8002cf8:	e00a      	b.n	8002d10 <UART_Start_Receive_IT+0x114>
 8002cfa:	4b0c      	ldr	r3, [pc, #48]	@ (8002d2c <UART_Start_Receive_IT+0x130>)
 8002cfc:	6743      	str	r3, [r0, #116]	@ 0x74
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002cfe:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002d02:	2301      	movs	r3, #1
 8002d04:	f383 8810 	msr	PRIMASK, r3
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8002d08:	6802      	ldr	r2, [r0, #0]
 8002d0a:	3320      	adds	r3, #32
 8002d0c:	6810      	ldr	r0, [r2, #0]
 8002d0e:	33ff      	adds	r3, #255	@ 0xff
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8002d10:	4303      	orrs	r3, r0
 8002d12:	6013      	str	r3, [r2, #0]
 8002d14:	e7b8      	b.n	8002c88 <UART_Start_Receive_IT+0x8c>
 8002d16:	4a05      	ldr	r2, [pc, #20]	@ (8002d2c <UART_Start_Receive_IT+0x130>)
 8002d18:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 8002d1a:	2b00      	cmp	r3, #0
 8002d1c:	d1ef      	bne.n	8002cfe <UART_Start_Receive_IT+0x102>
 8002d1e:	e7e3      	b.n	8002ce8 <UART_Start_Receive_IT+0xec>
 8002d20:	08002549 	.word	0x08002549
 8002d24:	0800237d 	.word	0x0800237d
 8002d28:	080022a9 	.word	0x080022a9
 8002d2c:	080021d1 	.word	0x080021d1

08002d30 <HAL_UART_Receive_IT>:
{
 8002d30:	0003      	movs	r3, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 8002d32:	308c      	adds	r0, #140	@ 0x8c
{
 8002d34:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 8002d36:	6804      	ldr	r4, [r0, #0]
    return HAL_BUSY;
 8002d38:	2002      	movs	r0, #2
  if (huart->RxState == HAL_UART_STATE_READY)
 8002d3a:	2c20      	cmp	r4, #32
 8002d3c:	d125      	bne.n	8002d8a <HAL_UART_Receive_IT+0x5a>
      return HAL_ERROR;
 8002d3e:	3801      	subs	r0, #1
    if ((pData == NULL) || (Size == 0U))
 8002d40:	2900      	cmp	r1, #0
 8002d42:	d022      	beq.n	8002d8a <HAL_UART_Receive_IT+0x5a>
 8002d44:	2a00      	cmp	r2, #0
 8002d46:	d020      	beq.n	8002d8a <HAL_UART_Receive_IT+0x5a>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002d48:	2080      	movs	r0, #128	@ 0x80
 8002d4a:	689c      	ldr	r4, [r3, #8]
 8002d4c:	0140      	lsls	r0, r0, #5
 8002d4e:	4284      	cmp	r4, r0
 8002d50:	d105      	bne.n	8002d5e <HAL_UART_Receive_IT+0x2e>
 8002d52:	6918      	ldr	r0, [r3, #16]
 8002d54:	2800      	cmp	r0, #0
 8002d56:	d102      	bne.n	8002d5e <HAL_UART_Receive_IT+0x2e>
      return HAL_ERROR;
 8002d58:	3001      	adds	r0, #1
      if ((((uint32_t)pData) & 1U) != 0U)
 8002d5a:	4201      	tst	r1, r0
 8002d5c:	d115      	bne.n	8002d8a <HAL_UART_Receive_IT+0x5a>
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8002d5e:	2000      	movs	r0, #0
 8002d60:	66d8      	str	r0, [r3, #108]	@ 0x6c
    if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8002d62:	6818      	ldr	r0, [r3, #0]
 8002d64:	6840      	ldr	r0, [r0, #4]
 8002d66:	0200      	lsls	r0, r0, #8
 8002d68:	d50c      	bpl.n	8002d84 <HAL_UART_Receive_IT+0x54>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002d6a:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002d6e:	2001      	movs	r0, #1
 8002d70:	f380 8810 	msr	PRIMASK, r0
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8002d74:	2080      	movs	r0, #128	@ 0x80
 8002d76:	681c      	ldr	r4, [r3, #0]
 8002d78:	04c0      	lsls	r0, r0, #19
 8002d7a:	6826      	ldr	r6, [r4, #0]
 8002d7c:	4330      	orrs	r0, r6
 8002d7e:	6020      	str	r0, [r4, #0]
 8002d80:	f385 8810 	msr	PRIMASK, r5
    return (UART_Start_Receive_IT(huart, pData, Size));
 8002d84:	0018      	movs	r0, r3
 8002d86:	f7ff ff39 	bl	8002bfc <UART_Start_Receive_IT>
}
 8002d8a:	bd70      	pop	{r4, r5, r6, pc}

08002d8c <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8002d8c:	4770      	bx	lr

08002d8e <HAL_UARTEx_RxFifoFullCallback>:
/**
  * @brief  UART RX Fifo full callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
 8002d8e:	4770      	bx	lr

08002d90 <HAL_UARTEx_TxFifoEmptyCallback>:
/**
  * @brief  UART TX Fifo empty callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
 8002d90:	4770      	bx	lr

08002d92 <IRQ_Context>:
#endif

/*
  Determine if CPU executes from interrupt context or if interrupts are masked.
*/
__STATIC_INLINE uint32_t IRQ_Context (void) {
 8002d92:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8002d94:	f3ef 8405 	mrs	r4, IPSR
  uint32_t irq;
  BaseType_t state;

  irq = 0U;

  if (IS_IRQ_MODE()) {
 8002d98:	2c00      	cmp	r4, #0
 8002d9a:	d109      	bne.n	8002db0 <IRQ_Context+0x1e>
    /* Called from interrupt context */
    irq = 1U;
  }
  else {
    /* Get FreeRTOS scheduler state */
    state = xTaskGetSchedulerState();
 8002d9c:	f001 fa42 	bl	8004224 <xTaskGetSchedulerState>

    if (state != taskSCHEDULER_NOT_STARTED) {
 8002da0:	2801      	cmp	r0, #1
 8002da2:	d003      	beq.n	8002dac <IRQ_Context+0x1a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8002da4:	f3ef 8410 	mrs	r4, PRIMASK
      /* Scheduler was started */
      if (IS_IRQ_MASKED()) {
 8002da8:	1e63      	subs	r3, r4, #1
 8002daa:	419c      	sbcs	r4, r3
    }
  }

  /* Return context, 0: thread context, 1: IRQ context */
  return (irq);
}
 8002dac:	0020      	movs	r0, r4
 8002dae:	bd10      	pop	{r4, pc}
    irq = 1U;
 8002db0:	2401      	movs	r4, #1
  return (irq);
 8002db2:	e7fb      	b.n	8002dac <IRQ_Context+0x1a>

08002db4 <SysTick_Handler>:
  SysTick->CTRL;
 8002db4:	4b04      	ldr	r3, [pc, #16]	@ (8002dc8 <SysTick_Handler+0x14>)
void SysTick_Handler (void) {
 8002db6:	b510      	push	{r4, lr}
  SysTick->CTRL;
 8002db8:	681b      	ldr	r3, [r3, #0]
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 8002dba:	f001 fa33 	bl	8004224 <xTaskGetSchedulerState>
 8002dbe:	2801      	cmp	r0, #1
 8002dc0:	d001      	beq.n	8002dc6 <SysTick_Handler+0x12>
    xPortSysTickHandler();
 8002dc2:	f001 fc87 	bl	80046d4 <xPortSysTickHandler>
}
 8002dc6:	bd10      	pop	{r4, pc}
 8002dc8:	e000e010 	.word	0xe000e010

08002dcc <osKernelInitialize>:
/* ==== Kernel Management Functions ==== */

/*
  Initialize the RTOS Kernel.
*/
osStatus_t osKernelInitialize (void) {
 8002dcc:	b510      	push	{r4, lr}
  osStatus_t stat;
  BaseType_t state;

  if (IRQ_Context() != 0U) {
 8002dce:	f7ff ffe0 	bl	8002d92 <IRQ_Context>
 8002dd2:	2800      	cmp	r0, #0
 8002dd4:	d10a      	bne.n	8002dec <osKernelInitialize+0x20>
    stat = osErrorISR;
  }
  else {
    state = xTaskGetSchedulerState();
 8002dd6:	f001 fa25 	bl	8004224 <xTaskGetSchedulerState>
 8002dda:	0003      	movs	r3, r0

    /* Initialize if scheduler not started and not initialized before */
    if ((state == taskSCHEDULER_NOT_STARTED) && (KernelState == osKernelInactive)) {
 8002ddc:	2801      	cmp	r0, #1
 8002dde:	d108      	bne.n	8002df2 <osKernelInitialize+0x26>
 8002de0:	4a05      	ldr	r2, [pc, #20]	@ (8002df8 <osKernelInitialize+0x2c>)
 8002de2:	6810      	ldr	r0, [r2, #0]
 8002de4:	2800      	cmp	r0, #0
 8002de6:	d104      	bne.n	8002df2 <osKernelInitialize+0x26>
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        /* Initialize the memory regions when using heap_5 variant */
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 8002de8:	6013      	str	r3, [r2, #0]
    }
  }

  /* Return execution status */
  return (stat);
}
 8002dea:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 8002dec:	2006      	movs	r0, #6
      stat = osError;
 8002dee:	4240      	negs	r0, r0
  return (stat);
 8002df0:	e7fb      	b.n	8002dea <osKernelInitialize+0x1e>
      stat = osError;
 8002df2:	2001      	movs	r0, #1
 8002df4:	e7fb      	b.n	8002dee <osKernelInitialize+0x22>
 8002df6:	46c0      	nop			@ (mov r8, r8)
 8002df8:	20000698 	.word	0x20000698

08002dfc <osKernelStart>:
}

/*
  Start the RTOS Kernel scheduler.
*/
osStatus_t osKernelStart (void) {
 8002dfc:	b510      	push	{r4, lr}
  osStatus_t stat;
  BaseType_t state;

  if (IRQ_Context() != 0U) {
 8002dfe:	f7ff ffc8 	bl	8002d92 <IRQ_Context>
 8002e02:	1e04      	subs	r4, r0, #0
 8002e04:	d112      	bne.n	8002e2c <osKernelStart+0x30>
    stat = osErrorISR;
  }
  else {
    state = xTaskGetSchedulerState();
 8002e06:	f001 fa0d 	bl	8004224 <xTaskGetSchedulerState>

    /* Start scheduler if initialized and not started before */
    if ((state == taskSCHEDULER_NOT_STARTED) && (KernelState == osKernelReady)) {
 8002e0a:	2801      	cmp	r0, #1
 8002e0c:	d111      	bne.n	8002e32 <osKernelStart+0x36>
 8002e0e:	4a0a      	ldr	r2, [pc, #40]	@ (8002e38 <osKernelStart+0x3c>)
 8002e10:	6813      	ldr	r3, [r2, #0]
 8002e12:	2b01      	cmp	r3, #1
 8002e14:	d10d      	bne.n	8002e32 <osKernelStart+0x36>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002e16:	4909      	ldr	r1, [pc, #36]	@ (8002e3c <osKernelStart+0x40>)
 8002e18:	69cb      	ldr	r3, [r1, #28]
 8002e1a:	021b      	lsls	r3, r3, #8
 8002e1c:	0a1b      	lsrs	r3, r3, #8
 8002e1e:	61cb      	str	r3, [r1, #28]
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
      /* Change state to ensure correct API flow */
      KernelState = osKernelRunning;
 8002e20:	2302      	movs	r3, #2
 8002e22:	6013      	str	r3, [r2, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 8002e24:	f000 ff04 	bl	8003c30 <vTaskStartScheduler>
      stat = osOK;
 8002e28:	0020      	movs	r0, r4
    }
  }

  /* Return execution status */
  return (stat);
}
 8002e2a:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 8002e2c:	2006      	movs	r0, #6
      stat = osError;
 8002e2e:	4240      	negs	r0, r0
  return (stat);
 8002e30:	e7fb      	b.n	8002e2a <osKernelStart+0x2e>
      stat = osError;
 8002e32:	2001      	movs	r0, #1
 8002e34:	e7fb      	b.n	8002e2e <osKernelStart+0x32>
 8002e36:	46c0      	nop			@ (mov r8, r8)
 8002e38:	20000698 	.word	0x20000698
 8002e3c:	e000ed00 	.word	0xe000ed00

08002e40 <osKernelGetTickCount>:
}

/*
  Get the RTOS kernel tick count.
*/
uint32_t osKernelGetTickCount (void) {
 8002e40:	b510      	push	{r4, lr}
  TickType_t ticks;

  if (IRQ_Context() != 0U) {
 8002e42:	f7ff ffa6 	bl	8002d92 <IRQ_Context>
 8002e46:	2800      	cmp	r0, #0
 8002e48:	d002      	beq.n	8002e50 <osKernelGetTickCount+0x10>
    ticks = xTaskGetTickCountFromISR();
 8002e4a:	f000 ff39 	bl	8003cc0 <xTaskGetTickCountFromISR>
    ticks = xTaskGetTickCount();
  }

  /* Return kernel tick count */
  return (ticks);
}
 8002e4e:	bd10      	pop	{r4, pc}
    ticks = xTaskGetTickCount();
 8002e50:	f000 ff30 	bl	8003cb4 <xTaskGetTickCount>
  return (ticks);
 8002e54:	e7fb      	b.n	8002e4e <osKernelGetTickCount+0xe>

08002e56 <osThreadNew>:
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 8002e56:	2300      	movs	r3, #0
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 8002e58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002e5a:	b089      	sub	sp, #36	@ 0x24
 8002e5c:	0005      	movs	r5, r0
 8002e5e:	000e      	movs	r6, r1
 8002e60:	0014      	movs	r4, r2
  hTask = NULL;
 8002e62:	9307      	str	r3, [sp, #28]

  if ((IRQ_Context() == 0U) && (func != NULL)) {
 8002e64:	f7ff ff95 	bl	8002d92 <IRQ_Context>
 8002e68:	2800      	cmp	r0, #0
 8002e6a:	d12b      	bne.n	8002ec4 <osThreadNew+0x6e>
 8002e6c:	2d00      	cmp	r5, #0
 8002e6e:	d029      	beq.n	8002ec4 <osThreadNew+0x6e>
    prio  = (UBaseType_t)osPriorityNormal;

    name = NULL;
    mem  = -1;

    if (attr != NULL) {
 8002e70:	2c00      	cmp	r4, #0
 8002e72:	d030      	beq.n	8002ed6 <osThreadNew+0x80>
      if (attr->name != NULL) {
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
 8002e74:	69a3      	ldr	r3, [r4, #24]
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d004      	beq.n	8002e84 <osThreadNew+0x2e>
        prio = (UBaseType_t)attr->priority;
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8002e7a:	1e5a      	subs	r2, r3, #1
 8002e7c:	2a37      	cmp	r2, #55	@ 0x37
 8002e7e:	d902      	bls.n	8002e86 <osThreadNew+0x30>
    }
  }

  /* Return thread ID */
  return ((osThreadId_t)hTask);
}
 8002e80:	b009      	add	sp, #36	@ 0x24
 8002e82:	bdf0      	pop	{r4, r5, r6, r7, pc}
    prio  = (UBaseType_t)osPriorityNormal;
 8002e84:	2318      	movs	r3, #24
      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8002e86:	6862      	ldr	r2, [r4, #4]
        return (NULL);
 8002e88:	2000      	movs	r0, #0
      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8002e8a:	07d2      	lsls	r2, r2, #31
 8002e8c:	d4f8      	bmi.n	8002e80 <osThreadNew+0x2a>
      if (attr->stack_size > 0U) {
 8002e8e:	6960      	ldr	r0, [r4, #20]
    stack = configMINIMAL_STACK_SIZE;
 8002e90:	2280      	movs	r2, #128	@ 0x80
      if (attr->stack_size > 0U) {
 8002e92:	2800      	cmp	r0, #0
 8002e94:	d000      	beq.n	8002e98 <osThreadNew+0x42>
        stack = attr->stack_size / sizeof(StackType_t);
 8002e96:	0882      	lsrs	r2, r0, #2
      if (attr->name != NULL) {
 8002e98:	6821      	ldr	r1, [r4, #0]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8002e9a:	68a7      	ldr	r7, [r4, #8]
      if (attr->name != NULL) {
 8002e9c:	9105      	str	r1, [sp, #20]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8002e9e:	68e1      	ldr	r1, [r4, #12]
 8002ea0:	2f00      	cmp	r7, #0
 8002ea2:	d011      	beq.n	8002ec8 <osThreadNew+0x72>
 8002ea4:	295b      	cmp	r1, #91	@ 0x5b
 8002ea6:	d90d      	bls.n	8002ec4 <osThreadNew+0x6e>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8002ea8:	6924      	ldr	r4, [r4, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8002eaa:	2c00      	cmp	r4, #0
 8002eac:	d00a      	beq.n	8002ec4 <osThreadNew+0x6e>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8002eae:	2800      	cmp	r0, #0
 8002eb0:	d008      	beq.n	8002ec4 <osThreadNew+0x6e>
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8002eb2:	9300      	str	r3, [sp, #0]
 8002eb4:	0028      	movs	r0, r5
 8002eb6:	0033      	movs	r3, r6
 8002eb8:	9905      	ldr	r1, [sp, #20]
 8002eba:	9702      	str	r7, [sp, #8]
 8002ebc:	9401      	str	r4, [sp, #4]
 8002ebe:	f000 fe14 	bl	8003aea <xTaskCreateStatic>
 8002ec2:	9007      	str	r0, [sp, #28]
  return ((osThreadId_t)hTask);
 8002ec4:	9807      	ldr	r0, [sp, #28]
 8002ec6:	e7db      	b.n	8002e80 <osThreadNew+0x2a>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 8002ec8:	2900      	cmp	r1, #0
 8002eca:	d1fb      	bne.n	8002ec4 <osThreadNew+0x6e>
 8002ecc:	6920      	ldr	r0, [r4, #16]
 8002ece:	2800      	cmp	r0, #0
 8002ed0:	d1f8      	bne.n	8002ec4 <osThreadNew+0x6e>
 8002ed2:	9c05      	ldr	r4, [sp, #20]
 8002ed4:	e001      	b.n	8002eda <osThreadNew+0x84>
    prio  = (UBaseType_t)osPriorityNormal;
 8002ed6:	2318      	movs	r3, #24
    stack = configMINIMAL_STACK_SIZE;
 8002ed8:	2280      	movs	r2, #128	@ 0x80
          if (xTaskCreate ((TaskFunction_t)func, name, (configSTACK_DEPTH_TYPE)stack, argument, prio, &hTask) != pdPASS) {
 8002eda:	a907      	add	r1, sp, #28
 8002edc:	9101      	str	r1, [sp, #4]
 8002ede:	9300      	str	r3, [sp, #0]
 8002ee0:	0021      	movs	r1, r4
 8002ee2:	0033      	movs	r3, r6
 8002ee4:	0028      	movs	r0, r5
 8002ee6:	b292      	uxth	r2, r2
 8002ee8:	f000 fe32 	bl	8003b50 <xTaskCreate>
 8002eec:	2801      	cmp	r0, #1
 8002eee:	d0e9      	beq.n	8002ec4 <osThreadNew+0x6e>
            hTask = NULL;
 8002ef0:	2300      	movs	r3, #0
 8002ef2:	9307      	str	r3, [sp, #28]
 8002ef4:	e7e6      	b.n	8002ec4 <osThreadNew+0x6e>

08002ef6 <osThreadSuspend>:

#if (configUSE_OS2_THREAD_SUSPEND_RESUME == 1)
/*
  Suspend execution of a thread.
*/
osStatus_t osThreadSuspend (osThreadId_t thread_id) {
 8002ef6:	b570      	push	{r4, r5, r6, lr}
 8002ef8:	0005      	movs	r5, r0
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
  osStatus_t stat;

  if (IRQ_Context() != 0U) {
 8002efa:	f7ff ff4a 	bl	8002d92 <IRQ_Context>
 8002efe:	1e04      	subs	r4, r0, #0
 8002f00:	d106      	bne.n	8002f10 <osThreadSuspend+0x1a>
    stat = osErrorISR;
  }
  else if (hTask == NULL) {
 8002f02:	2d00      	cmp	r5, #0
 8002f04:	d007      	beq.n	8002f16 <osThreadSuspend+0x20>
    stat = osErrorParameter;
  }
  else {
    stat = osOK;
    vTaskSuspend (hTask);
 8002f06:	0028      	movs	r0, r5
 8002f08:	f001 f868 	bl	8003fdc <vTaskSuspend>
    stat = osOK;
 8002f0c:	0020      	movs	r0, r4
  }

  /* Return execution status */
  return (stat);
}
 8002f0e:	bd70      	pop	{r4, r5, r6, pc}
    stat = osErrorISR;
 8002f10:	2006      	movs	r0, #6
    stat = osErrorParameter;
 8002f12:	4240      	negs	r0, r0
  return (stat);
 8002f14:	e7fb      	b.n	8002f0e <osThreadSuspend+0x18>
    stat = osErrorParameter;
 8002f16:	2004      	movs	r0, #4
 8002f18:	e7fb      	b.n	8002f12 <osThreadSuspend+0x1c>

08002f1a <osThreadResume>:

/*
  Resume execution of a thread.
*/
osStatus_t osThreadResume (osThreadId_t thread_id) {
 8002f1a:	b570      	push	{r4, r5, r6, lr}
 8002f1c:	0005      	movs	r5, r0
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
  osStatus_t stat;

  if (IRQ_Context() != 0U) {
 8002f1e:	f7ff ff38 	bl	8002d92 <IRQ_Context>
 8002f22:	1e04      	subs	r4, r0, #0
 8002f24:	d106      	bne.n	8002f34 <osThreadResume+0x1a>
    stat = osErrorISR;
  }
  else if (hTask == NULL) {
 8002f26:	2d00      	cmp	r5, #0
 8002f28:	d007      	beq.n	8002f3a <osThreadResume+0x20>
    stat = osErrorParameter;
  }
  else {
    stat = osOK;
    vTaskResume (hTask);
 8002f2a:	0028      	movs	r0, r5
 8002f2c:	f000 fe3e 	bl	8003bac <vTaskResume>
    stat = osOK;
 8002f30:	0020      	movs	r0, r4
  }

  /* Return execution status */
  return (stat);
}
 8002f32:	bd70      	pop	{r4, r5, r6, pc}
    stat = osErrorISR;
 8002f34:	2006      	movs	r0, #6
    stat = osErrorParameter;
 8002f36:	4240      	negs	r0, r0
  return (stat);
 8002f38:	e7fb      	b.n	8002f32 <osThreadResume+0x18>
    stat = osErrorParameter;
 8002f3a:	2004      	movs	r0, #4
 8002f3c:	e7fb      	b.n	8002f36 <osThreadResume+0x1c>

08002f3e <osDelay>:
/* ==== Generic Wait Functions ==== */

/*
  Wait for Timeout (Time Delay).
*/
osStatus_t osDelay (uint32_t ticks) {
 8002f3e:	b510      	push	{r4, lr}
 8002f40:	0004      	movs	r4, r0
  osStatus_t stat;

  if (IRQ_Context() != 0U) {
 8002f42:	f7ff ff26 	bl	8002d92 <IRQ_Context>
 8002f46:	2800      	cmp	r0, #0
 8002f48:	d106      	bne.n	8002f58 <osDelay+0x1a>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
 8002f4a:	2c00      	cmp	r4, #0
 8002f4c:	d002      	beq.n	8002f54 <osDelay+0x16>
      vTaskDelay(ticks);
 8002f4e:	0020      	movs	r0, r4
 8002f50:	f000 fff4 	bl	8003f3c <vTaskDelay>
    stat = osOK;
 8002f54:	2000      	movs	r0, #0
    }
  }

  /* Return execution status */
  return (stat);
}
 8002f56:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 8002f58:	2006      	movs	r0, #6
 8002f5a:	4240      	negs	r0, r0
  return (stat);
 8002f5c:	e7fb      	b.n	8002f56 <osDelay+0x18>

08002f5e <osSemaphoreGetCount>:
}

/*
  Get current Semaphore token count.
*/
uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
 8002f5e:	b510      	push	{r4, lr}
 8002f60:	0004      	movs	r4, r0
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
  uint32_t count;

  if (hSemaphore == NULL) {
    count = 0U;
 8002f62:	2000      	movs	r0, #0
  if (hSemaphore == NULL) {
 8002f64:	4284      	cmp	r4, r0
 8002f66:	d006      	beq.n	8002f76 <osSemaphoreGetCount+0x18>
  }
  else if (IRQ_Context() != 0U) {
 8002f68:	f7ff ff13 	bl	8002d92 <IRQ_Context>
 8002f6c:	2800      	cmp	r0, #0
 8002f6e:	d003      	beq.n	8002f78 <osSemaphoreGetCount+0x1a>
    count = (uint32_t)uxSemaphoreGetCountFromISR (hSemaphore);
 8002f70:	0020      	movs	r0, r4
 8002f72:	f000 fc1b 	bl	80037ac <uxQueueMessagesWaitingFromISR>
    count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
  }

  /* Return number of tokens */
  return (count);
}
 8002f76:	bd10      	pop	{r4, pc}
    count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
 8002f78:	0020      	movs	r0, r4
 8002f7a:	f000 fc0b 	bl	8003794 <uxQueueMessagesWaiting>
 8002f7e:	e7fa      	b.n	8002f76 <osSemaphoreGetCount+0x18>

08002f80 <osMessageQueueNew>:

  Limitations:
  - The memory for control block and and message data must be provided in the
    osThreadAttr_t structure in order to allocate object statically.
*/
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
 8002f80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8002f82:	0005      	movs	r5, r0
 8002f84:	000e      	movs	r6, r1
 8002f86:	0014      	movs	r4, r2
  QueueHandle_t hQueue;
  int32_t mem;

  hQueue = NULL;

  if ((IRQ_Context() == 0U) && (msg_count > 0U) && (msg_size > 0U)) {
 8002f88:	f7ff ff03 	bl	8002d92 <IRQ_Context>
 8002f8c:	2800      	cmp	r0, #0
 8002f8e:	d002      	beq.n	8002f96 <osMessageQueueNew+0x16>
  hQueue = NULL;
 8002f90:	2500      	movs	r5, #0

  }

  /* Return message queue ID */
  return ((osMessageQueueId_t)hQueue);
}
 8002f92:	0028      	movs	r0, r5
 8002f94:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if ((IRQ_Context() == 0U) && (msg_count > 0U) && (msg_size > 0U)) {
 8002f96:	2d00      	cmp	r5, #0
 8002f98:	d0fa      	beq.n	8002f90 <osMessageQueueNew+0x10>
 8002f9a:	2e00      	cmp	r6, #0
 8002f9c:	d0f8      	beq.n	8002f90 <osMessageQueueNew+0x10>
    if (attr != NULL) {
 8002f9e:	2c00      	cmp	r4, #0
 8002fa0:	d023      	beq.n	8002fea <osMessageQueueNew+0x6a>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 8002fa2:	68a3      	ldr	r3, [r4, #8]
 8002fa4:	68e2      	ldr	r2, [r4, #12]
 8002fa6:	2b00      	cmp	r3, #0
 8002fa8:	d017      	beq.n	8002fda <osMessageQueueNew+0x5a>
 8002faa:	2a4f      	cmp	r2, #79	@ 0x4f
 8002fac:	d9f0      	bls.n	8002f90 <osMessageQueueNew+0x10>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 8002fae:	6922      	ldr	r2, [r4, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 8002fb0:	2a00      	cmp	r2, #0
 8002fb2:	d0ed      	beq.n	8002f90 <osMessageQueueNew+0x10>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 8002fb4:	0031      	movs	r1, r6
 8002fb6:	4369      	muls	r1, r5
 8002fb8:	6967      	ldr	r7, [r4, #20]
 8002fba:	428f      	cmp	r7, r1
 8002fbc:	d3e8      	bcc.n	8002f90 <osMessageQueueNew+0x10>
        hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
 8002fbe:	9000      	str	r0, [sp, #0]
 8002fc0:	0031      	movs	r1, r6
 8002fc2:	0028      	movs	r0, r5
 8002fc4:	f000 f9d3 	bl	800336e <xQueueGenericCreateStatic>
 8002fc8:	1e05      	subs	r5, r0, #0
    if (hQueue != NULL) {
 8002fca:	d0e1      	beq.n	8002f90 <osMessageQueueNew+0x10>
      if ((attr != NULL) && (attr->name != NULL)) {
 8002fcc:	6821      	ldr	r1, [r4, #0]
 8002fce:	2900      	cmp	r1, #0
 8002fd0:	d0df      	beq.n	8002f92 <osMessageQueueNew+0x12>
        vQueueAddToRegistry (hQueue, attr->name);
 8002fd2:	0028      	movs	r0, r5
 8002fd4:	f000 fbf0 	bl	80037b8 <vQueueAddToRegistry>
 8002fd8:	e7db      	b.n	8002f92 <osMessageQueueNew+0x12>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 8002fda:	2a00      	cmp	r2, #0
 8002fdc:	d1d8      	bne.n	8002f90 <osMessageQueueNew+0x10>
 8002fde:	6923      	ldr	r3, [r4, #16]
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	d1d5      	bne.n	8002f90 <osMessageQueueNew+0x10>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 8002fe4:	6963      	ldr	r3, [r4, #20]
 8002fe6:	2b00      	cmp	r3, #0
 8002fe8:	d1d2      	bne.n	8002f90 <osMessageQueueNew+0x10>
          hQueue = xQueueCreate (msg_count, msg_size);
 8002fea:	0028      	movs	r0, r5
 8002fec:	2200      	movs	r2, #0
 8002fee:	0031      	movs	r1, r6
 8002ff0:	f000 f9ea 	bl	80033c8 <xQueueGenericCreate>
 8002ff4:	1e05      	subs	r5, r0, #0
    if (hQueue != NULL) {
 8002ff6:	d0cb      	beq.n	8002f90 <osMessageQueueNew+0x10>
      if ((attr != NULL) && (attr->name != NULL)) {
 8002ff8:	2c00      	cmp	r4, #0
 8002ffa:	d1e7      	bne.n	8002fcc <osMessageQueueNew+0x4c>
 8002ffc:	e7c9      	b.n	8002f92 <osMessageQueueNew+0x12>
	...

08003000 <osMessageQueuePut>:
  Put a Message into a Queue or timeout if Queue is full.

  Limitations:
  - Message priority is ignored
*/
osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
 8003000:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003002:	001c      	movs	r4, r3
 8003004:	0005      	movs	r5, r0
 8003006:	000e      	movs	r6, r1

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IRQ_Context() != 0U) {
 8003008:	f7ff fec3 	bl	8002d92 <IRQ_Context>
 800300c:	1e03      	subs	r3, r0, #0
 800300e:	d01b      	beq.n	8003048 <osMessageQueuePut+0x48>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 8003010:	2d00      	cmp	r5, #0
 8003012:	d028      	beq.n	8003066 <osMessageQueuePut+0x66>
 8003014:	2e00      	cmp	r6, #0
 8003016:	d026      	beq.n	8003066 <osMessageQueuePut+0x66>
 8003018:	2c00      	cmp	r4, #0
 800301a:	d124      	bne.n	8003066 <osMessageQueuePut+0x66>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 800301c:	0023      	movs	r3, r4
 800301e:	0031      	movs	r1, r6
 8003020:	0028      	movs	r0, r5
 8003022:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 8003024:	9401      	str	r4, [sp, #4]
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 8003026:	f000 fa9a 	bl	800355e <xQueueGenericSendFromISR>
 800302a:	2801      	cmp	r0, #1
 800302c:	d002      	beq.n	8003034 <osMessageQueuePut+0x34>
        stat = osErrorResource;
 800302e:	2003      	movs	r0, #3
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
      stat = osErrorParameter;
 8003030:	4240      	negs	r0, r0
      }
    }
  }

  /* Return execution status */
  return (stat);
 8003032:	e003      	b.n	800303c <osMessageQueuePut+0x3c>
        portYIELD_FROM_ISR (yield);
 8003034:	9b01      	ldr	r3, [sp, #4]
 8003036:	2b00      	cmp	r3, #0
 8003038:	d101      	bne.n	800303e <osMessageQueuePut+0x3e>
  stat = osOK;
 800303a:	2000      	movs	r0, #0
}
 800303c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        portYIELD_FROM_ISR (yield);
 800303e:	2280      	movs	r2, #128	@ 0x80
 8003040:	4b0a      	ldr	r3, [pc, #40]	@ (800306c <osMessageQueuePut+0x6c>)
 8003042:	0552      	lsls	r2, r2, #21
 8003044:	601a      	str	r2, [r3, #0]
 8003046:	e7f8      	b.n	800303a <osMessageQueuePut+0x3a>
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 8003048:	2d00      	cmp	r5, #0
 800304a:	d00c      	beq.n	8003066 <osMessageQueuePut+0x66>
 800304c:	2e00      	cmp	r6, #0
 800304e:	d00a      	beq.n	8003066 <osMessageQueuePut+0x66>
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 8003050:	0022      	movs	r2, r4
 8003052:	0031      	movs	r1, r6
 8003054:	0028      	movs	r0, r5
 8003056:	f000 f9f3 	bl	8003440 <xQueueGenericSend>
 800305a:	2801      	cmp	r0, #1
 800305c:	d0ed      	beq.n	800303a <osMessageQueuePut+0x3a>
          stat = osErrorTimeout;
 800305e:	2002      	movs	r0, #2
        if (timeout != 0U) {
 8003060:	2c00      	cmp	r4, #0
 8003062:	d1e5      	bne.n	8003030 <osMessageQueuePut+0x30>
 8003064:	e7e3      	b.n	800302e <osMessageQueuePut+0x2e>
      stat = osErrorParameter;
 8003066:	2004      	movs	r0, #4
 8003068:	e7e2      	b.n	8003030 <osMessageQueuePut+0x30>
 800306a:	46c0      	nop			@ (mov r8, r8)
 800306c:	e000ed04 	.word	0xe000ed04

08003070 <osMessageQueueGet>:
  Get a Message from a Queue or timeout if Queue is empty.

  Limitations:
  - Message priority is ignored
*/
osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
 8003070:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003072:	0005      	movs	r5, r0
 8003074:	000e      	movs	r6, r1
 8003076:	001c      	movs	r4, r3

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IRQ_Context() != 0U) {
 8003078:	f7ff fe8b 	bl	8002d92 <IRQ_Context>
 800307c:	2800      	cmp	r0, #0
 800307e:	d01a      	beq.n	80030b6 <osMessageQueueGet+0x46>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 8003080:	2d00      	cmp	r5, #0
 8003082:	d027      	beq.n	80030d4 <osMessageQueueGet+0x64>
 8003084:	2e00      	cmp	r6, #0
 8003086:	d025      	beq.n	80030d4 <osMessageQueueGet+0x64>
 8003088:	2c00      	cmp	r4, #0
 800308a:	d123      	bne.n	80030d4 <osMessageQueueGet+0x64>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 800308c:	0031      	movs	r1, r6
 800308e:	0028      	movs	r0, r5
 8003090:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 8003092:	9401      	str	r4, [sp, #4]
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 8003094:	f000 fb39 	bl	800370a <xQueueReceiveFromISR>
 8003098:	2801      	cmp	r0, #1
 800309a:	d002      	beq.n	80030a2 <osMessageQueueGet+0x32>
        stat = osErrorResource;
 800309c:	2003      	movs	r0, #3
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
      stat = osErrorParameter;
 800309e:	4240      	negs	r0, r0
      }
    }
  }

  /* Return execution status */
  return (stat);
 80030a0:	e003      	b.n	80030aa <osMessageQueueGet+0x3a>
        portYIELD_FROM_ISR (yield);
 80030a2:	9b01      	ldr	r3, [sp, #4]
 80030a4:	2b00      	cmp	r3, #0
 80030a6:	d101      	bne.n	80030ac <osMessageQueueGet+0x3c>
  stat = osOK;
 80030a8:	2000      	movs	r0, #0
}
 80030aa:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        portYIELD_FROM_ISR (yield);
 80030ac:	2280      	movs	r2, #128	@ 0x80
 80030ae:	4b0a      	ldr	r3, [pc, #40]	@ (80030d8 <osMessageQueueGet+0x68>)
 80030b0:	0552      	lsls	r2, r2, #21
 80030b2:	601a      	str	r2, [r3, #0]
 80030b4:	e7f8      	b.n	80030a8 <osMessageQueueGet+0x38>
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 80030b6:	2d00      	cmp	r5, #0
 80030b8:	d00c      	beq.n	80030d4 <osMessageQueueGet+0x64>
 80030ba:	2e00      	cmp	r6, #0
 80030bc:	d00a      	beq.n	80030d4 <osMessageQueueGet+0x64>
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 80030be:	0022      	movs	r2, r4
 80030c0:	0031      	movs	r1, r6
 80030c2:	0028      	movs	r0, r5
 80030c4:	f000 fa9c 	bl	8003600 <xQueueReceive>
 80030c8:	2801      	cmp	r0, #1
 80030ca:	d0ed      	beq.n	80030a8 <osMessageQueueGet+0x38>
          stat = osErrorTimeout;
 80030cc:	2002      	movs	r0, #2
        if (timeout != 0U) {
 80030ce:	2c00      	cmp	r4, #0
 80030d0:	d1e5      	bne.n	800309e <osMessageQueueGet+0x2e>
 80030d2:	e7e3      	b.n	800309c <osMessageQueueGet+0x2c>
      stat = osErrorParameter;
 80030d4:	2004      	movs	r0, #4
 80030d6:	e7e2      	b.n	800309e <osMessageQueueGet+0x2e>
 80030d8:	e000ed04 	.word	0xe000ed04

080030dc <osMessageQueueGetCount>:
}

/*
  Get number of queued messages in a Message Queue.
*/
uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
 80030dc:	b510      	push	{r4, lr}
 80030de:	f7ff ff3e 	bl	8002f5e <osSemaphoreGetCount>
 80030e2:	bd10      	pop	{r4, pc}

080030e4 <osMessageQueueReset>:
}

/*
  Reset a Message Queue to initial empty state.
*/
osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
 80030e4:	b570      	push	{r4, r5, r6, lr}
 80030e6:	0005      	movs	r5, r0
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
  osStatus_t stat;

  if (IRQ_Context() != 0U) {
 80030e8:	f7ff fe53 	bl	8002d92 <IRQ_Context>
 80030ec:	1e04      	subs	r4, r0, #0
 80030ee:	d107      	bne.n	8003100 <osMessageQueueReset+0x1c>
    stat = osErrorISR;
  }
  else if (hQueue == NULL) {
 80030f0:	2d00      	cmp	r5, #0
 80030f2:	d008      	beq.n	8003106 <osMessageQueueReset+0x22>
    stat = osErrorParameter;
  }
  else {
    stat = osOK;
    (void)xQueueReset (hQueue);
 80030f4:	0001      	movs	r1, r0
 80030f6:	0028      	movs	r0, r5
 80030f8:	f000 f8e9 	bl	80032ce <xQueueGenericReset>
    stat = osOK;
 80030fc:	0020      	movs	r0, r4
  }

  /* Return execution status */
  return (stat);
}
 80030fe:	bd70      	pop	{r4, r5, r6, pc}
    stat = osErrorISR;
 8003100:	2006      	movs	r0, #6
    stat = osErrorParameter;
 8003102:	4240      	negs	r0, r0
  return (stat);
 8003104:	e7fb      	b.n	80030fe <osMessageQueueReset+0x1a>
    stat = osErrorParameter;
 8003106:	2004      	movs	r0, #4
 8003108:	e7fb      	b.n	8003102 <osMessageQueueReset+0x1e>
	...

0800310c <vApplicationGetIdleTaskMemory>:
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 800310c:	4b03      	ldr	r3, [pc, #12]	@ (800311c <vApplicationGetIdleTaskMemory+0x10>)
 800310e:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 8003110:	4b03      	ldr	r3, [pc, #12]	@ (8003120 <vApplicationGetIdleTaskMemory+0x14>)
 8003112:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 8003114:	2380      	movs	r3, #128	@ 0x80
 8003116:	6013      	str	r3, [r2, #0]
}
 8003118:	4770      	bx	lr
 800311a:	46c0      	nop			@ (mov r8, r8)
 800311c:	2000063c 	.word	0x2000063c
 8003120:	2000043c 	.word	0x2000043c

08003124 <vApplicationGetTimerTaskMemory>:
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 8003124:	4b03      	ldr	r3, [pc, #12]	@ (8003134 <vApplicationGetTimerTaskMemory+0x10>)
 8003126:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 8003128:	4b03      	ldr	r3, [pc, #12]	@ (8003138 <vApplicationGetTimerTaskMemory+0x14>)
 800312a:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 800312c:	2380      	movs	r3, #128	@ 0x80
 800312e:	6013      	str	r3, [r2, #0]
}
 8003130:	4770      	bx	lr
 8003132:	46c0      	nop			@ (mov r8, r8)
 8003134:	200003e0 	.word	0x200003e0
 8003138:	200001e0 	.word	0x200001e0

0800313c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800313c:	0003      	movs	r3, r0
 800313e:	3308      	adds	r3, #8

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003140:	2201      	movs	r2, #1
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003142:	6043      	str	r3, [r0, #4]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003144:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003146:	6103      	str	r3, [r0, #16]
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003148:	2300      	movs	r3, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 800314a:	4252      	negs	r2, r2
 800314c:	6082      	str	r2, [r0, #8]
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800314e:	6003      	str	r3, [r0, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003150:	4770      	bx	lr

08003152 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8003152:	2300      	movs	r3, #0
 8003154:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003156:	4770      	bx	lr

08003158 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
 8003158:	6843      	ldr	r3, [r0, #4]

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800315a:	689a      	ldr	r2, [r3, #8]
    pxNewListItem->pxNext = pxIndex;
 800315c:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800315e:	608a      	str	r2, [r1, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003160:	6051      	str	r1, [r2, #4]
    pxIndex->pxPrevious = pxNewListItem;
 8003162:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 8003164:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 8003166:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 8003168:	3301      	adds	r3, #1
 800316a:	6003      	str	r3, [r0, #0]
}
 800316c:	4770      	bx	lr

0800316e <vListInsert>:
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800316e:	0002      	movs	r2, r0
{
 8003170:	b530      	push	{r4, r5, lr}
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003172:	680c      	ldr	r4, [r1, #0]
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8003174:	3208      	adds	r2, #8
    if( xValueOfInsertion == portMAX_DELAY )
 8003176:	1c63      	adds	r3, r4, #1
 8003178:	d10a      	bne.n	8003190 <vListInsert+0x22>
        pxIterator = pxList->xListEnd.pxPrevious;
 800317a:	6903      	ldr	r3, [r0, #16]
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 800317c:	685a      	ldr	r2, [r3, #4]
 800317e:	604a      	str	r2, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003180:	6091      	str	r1, [r2, #8]
    pxNewListItem->pxPrevious = pxIterator;
 8003182:	608b      	str	r3, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 8003184:	6059      	str	r1, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 8003186:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 8003188:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 800318a:	3301      	adds	r3, #1
 800318c:	6003      	str	r3, [r0, #0]
}
 800318e:	bd30      	pop	{r4, r5, pc}
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8003190:	0013      	movs	r3, r2
 8003192:	6852      	ldr	r2, [r2, #4]
 8003194:	6815      	ldr	r5, [r2, #0]
 8003196:	42a5      	cmp	r5, r4
 8003198:	d9fa      	bls.n	8003190 <vListInsert+0x22>
 800319a:	e7ef      	b.n	800317c <vListInsert+0xe>

0800319c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 800319c:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800319e:	6841      	ldr	r1, [r0, #4]
 80031a0:	6882      	ldr	r2, [r0, #8]
 80031a2:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80031a4:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 80031a6:	6859      	ldr	r1, [r3, #4]
 80031a8:	4281      	cmp	r1, r0
 80031aa:	d100      	bne.n	80031ae <uxListRemove+0x12>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 80031ac:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 80031ae:	2200      	movs	r2, #0
 80031b0:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 80031b2:	681a      	ldr	r2, [r3, #0]
 80031b4:	3a01      	subs	r2, #1
 80031b6:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 80031b8:	6818      	ldr	r0, [r3, #0]
}
 80031ba:	4770      	bx	lr

080031bc <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 80031bc:	b510      	push	{r4, lr}
 80031be:	0004      	movs	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 80031c0:	f001 fa3e 	bl	8004640 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80031c4:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 80031c6:	f001 fa47 	bl	8004658 <vPortExitCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80031ca:	4260      	negs	r0, r4
 80031cc:	4160      	adcs	r0, r4

    return xReturn;
}
 80031ce:	bd10      	pop	{r4, pc}

080031d0 <prvCopyDataToQueue>:
{
 80031d0:	b570      	push	{r4, r5, r6, lr}
 80031d2:	0016      	movs	r6, r2
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80031d4:	6c02      	ldr	r2, [r0, #64]	@ 0x40
{
 80031d6:	0004      	movs	r4, r0
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80031d8:	6b85      	ldr	r5, [r0, #56]	@ 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80031da:	2a00      	cmp	r2, #0
 80031dc:	d109      	bne.n	80031f2 <prvCopyDataToQueue+0x22>
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80031de:	6806      	ldr	r6, [r0, #0]
 80031e0:	2e00      	cmp	r6, #0
 80031e2:	d112      	bne.n	800320a <prvCopyDataToQueue+0x3a>
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 80031e4:	6880      	ldr	r0, [r0, #8]
 80031e6:	f001 f82d 	bl	8004244 <xTaskPriorityDisinherit>
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 80031ea:	60a6      	str	r6, [r4, #8]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80031ec:	3501      	adds	r5, #1
 80031ee:	63a5      	str	r5, [r4, #56]	@ 0x38
}
 80031f0:	bd70      	pop	{r4, r5, r6, pc}
    else if( xPosition == queueSEND_TO_BACK )
 80031f2:	2e00      	cmp	r6, #0
 80031f4:	d10e      	bne.n	8003214 <prvCopyDataToQueue+0x44>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80031f6:	6840      	ldr	r0, [r0, #4]
 80031f8:	f001 fb7e 	bl	80048f8 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80031fc:	6863      	ldr	r3, [r4, #4]
 80031fe:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8003200:	189b      	adds	r3, r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003202:	68a2      	ldr	r2, [r4, #8]
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8003204:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003206:	4293      	cmp	r3, r2
 8003208:	d201      	bcs.n	800320e <prvCopyDataToQueue+0x3e>
    BaseType_t xReturn = pdFALSE;
 800320a:	2000      	movs	r0, #0
 800320c:	e7ee      	b.n	80031ec <prvCopyDataToQueue+0x1c>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 800320e:	6823      	ldr	r3, [r4, #0]
 8003210:	6063      	str	r3, [r4, #4]
 8003212:	e7fa      	b.n	800320a <prvCopyDataToQueue+0x3a>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8003214:	68c0      	ldr	r0, [r0, #12]
 8003216:	f001 fb6f 	bl	80048f8 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800321a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800321c:	68e3      	ldr	r3, [r4, #12]
 800321e:	4251      	negs	r1, r2
 8003220:	1a9b      	subs	r3, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003222:	6822      	ldr	r2, [r4, #0]
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8003224:	60e3      	str	r3, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003226:	4293      	cmp	r3, r2
 8003228:	d202      	bcs.n	8003230 <prvCopyDataToQueue+0x60>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 800322a:	68a3      	ldr	r3, [r4, #8]
 800322c:	185b      	adds	r3, r3, r1
 800322e:	60e3      	str	r3, [r4, #12]
    BaseType_t xReturn = pdFALSE;
 8003230:	2000      	movs	r0, #0
        if( xPosition == queueOVERWRITE )
 8003232:	2e02      	cmp	r6, #2
 8003234:	d1da      	bne.n	80031ec <prvCopyDataToQueue+0x1c>
                --uxMessagesWaiting;
 8003236:	002b      	movs	r3, r5
 8003238:	1e5a      	subs	r2, r3, #1
 800323a:	4193      	sbcs	r3, r2
 800323c:	1aed      	subs	r5, r5, r3
 800323e:	e7d5      	b.n	80031ec <prvCopyDataToQueue+0x1c>

08003240 <prvCopyDataFromQueue>:
{
 8003240:	0003      	movs	r3, r0
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8003242:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
{
 8003244:	0008      	movs	r0, r1
 8003246:	b510      	push	{r4, lr}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8003248:	2a00      	cmp	r2, #0
 800324a:	d00a      	beq.n	8003262 <prvCopyDataFromQueue+0x22>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800324c:	68dc      	ldr	r4, [r3, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800324e:	6899      	ldr	r1, [r3, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8003250:	18a4      	adds	r4, r4, r2
 8003252:	60dc      	str	r4, [r3, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8003254:	428c      	cmp	r4, r1
 8003256:	d301      	bcc.n	800325c <prvCopyDataFromQueue+0x1c>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8003258:	6819      	ldr	r1, [r3, #0]
 800325a:	60d9      	str	r1, [r3, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800325c:	68d9      	ldr	r1, [r3, #12]
 800325e:	f001 fb4b 	bl	80048f8 <memcpy>
}
 8003262:	bd10      	pop	{r4, pc}

08003264 <prvUnlockQueue>:
{
 8003264:	b570      	push	{r4, r5, r6, lr}
 8003266:	0004      	movs	r4, r0
        int8_t cTxLock = pxQueue->cTxLock;
 8003268:	0026      	movs	r6, r4
 800326a:	3645      	adds	r6, #69	@ 0x45
    taskENTER_CRITICAL();
 800326c:	f001 f9e8 	bl	8004640 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8003270:	7835      	ldrb	r5, [r6, #0]
            --cTxLock;
 8003272:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8003274:	2d00      	cmp	r5, #0
 8003276:	dd02      	ble.n	800327e <prvUnlockQueue+0x1a>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003278:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800327a:	2b00      	cmp	r3, #0
 800327c:	d113      	bne.n	80032a6 <prvUnlockQueue+0x42>
        pxQueue->cTxLock = queueUNLOCKED;
 800327e:	23ff      	movs	r3, #255	@ 0xff
 8003280:	7033      	strb	r3, [r6, #0]
        int8_t cRxLock = pxQueue->cRxLock;
 8003282:	0026      	movs	r6, r4
 8003284:	3644      	adds	r6, #68	@ 0x44
    taskEXIT_CRITICAL();
 8003286:	f001 f9e7 	bl	8004658 <vPortExitCritical>
    taskENTER_CRITICAL();
 800328a:	f001 f9d9 	bl	8004640 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 800328e:	7835      	ldrb	r5, [r6, #0]
                --cRxLock;
 8003290:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8003292:	2d00      	cmp	r5, #0
 8003294:	dd02      	ble.n	800329c <prvUnlockQueue+0x38>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003296:	6923      	ldr	r3, [r4, #16]
 8003298:	2b00      	cmp	r3, #0
 800329a:	d10e      	bne.n	80032ba <prvUnlockQueue+0x56>
        pxQueue->cRxLock = queueUNLOCKED;
 800329c:	23ff      	movs	r3, #255	@ 0xff
 800329e:	7033      	strb	r3, [r6, #0]
    taskEXIT_CRITICAL();
 80032a0:	f001 f9da 	bl	8004658 <vPortExitCritical>
}
 80032a4:	bd70      	pop	{r4, r5, r6, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80032a6:	0020      	movs	r0, r4
 80032a8:	3024      	adds	r0, #36	@ 0x24
 80032aa:	f000 ff1b 	bl	80040e4 <xTaskRemoveFromEventList>
 80032ae:	2800      	cmp	r0, #0
 80032b0:	d001      	beq.n	80032b6 <prvUnlockQueue+0x52>
                        vTaskMissedYield();
 80032b2:	f000 ffb1 	bl	8004218 <vTaskMissedYield>
            --cTxLock;
 80032b6:	3d01      	subs	r5, #1
 80032b8:	e7db      	b.n	8003272 <prvUnlockQueue+0xe>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80032ba:	0020      	movs	r0, r4
 80032bc:	3010      	adds	r0, #16
 80032be:	f000 ff11 	bl	80040e4 <xTaskRemoveFromEventList>
 80032c2:	2800      	cmp	r0, #0
 80032c4:	d001      	beq.n	80032ca <prvUnlockQueue+0x66>
                    vTaskMissedYield();
 80032c6:	f000 ffa7 	bl	8004218 <vTaskMissedYield>
                --cRxLock;
 80032ca:	3d01      	subs	r5, #1
 80032cc:	e7e0      	b.n	8003290 <prvUnlockQueue+0x2c>

080032ce <xQueueGenericReset>:
{
 80032ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80032d0:	0004      	movs	r4, r0
 80032d2:	000d      	movs	r5, r1
    configASSERT( pxQueue );
 80032d4:	2800      	cmp	r0, #0
 80032d6:	d101      	bne.n	80032dc <xQueueGenericReset+0xe>
 80032d8:	b672      	cpsid	i
 80032da:	e7fe      	b.n	80032da <xQueueGenericReset+0xc>
        ( pxQueue->uxLength >= 1U ) &&
 80032dc:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
    if( ( pxQueue != NULL ) &&
 80032de:	2900      	cmp	r1, #0
 80032e0:	d043      	beq.n	800336a <xQueueGenericReset+0x9c>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 80032e2:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 80032e4:	0c0b      	lsrs	r3, r1, #16
 80032e6:	0c17      	lsrs	r7, r2, #16
 80032e8:	2b00      	cmp	r3, #0
 80032ea:	d131      	bne.n	8003350 <xQueueGenericReset+0x82>
 80032ec:	2f00      	cmp	r7, #0
 80032ee:	d00b      	beq.n	8003308 <xQueueGenericReset+0x3a>
 80032f0:	1c3b      	adds	r3, r7, #0
 80032f2:	1c08      	adds	r0, r1, #0
 80032f4:	b289      	uxth	r1, r1
 80032f6:	b292      	uxth	r2, r2
 80032f8:	434a      	muls	r2, r1
 80032fa:	b280      	uxth	r0, r0
 80032fc:	b29b      	uxth	r3, r3
 80032fe:	4343      	muls	r3, r0
 8003300:	0c12      	lsrs	r2, r2, #16
 8003302:	189b      	adds	r3, r3, r2
 8003304:	0c1b      	lsrs	r3, r3, #16
 8003306:	d130      	bne.n	800336a <xQueueGenericReset+0x9c>
        taskENTER_CRITICAL();
 8003308:	f001 f99a 	bl	8004640 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800330c:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 800330e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003310:	6822      	ldr	r2, [r4, #0]
 8003312:	434b      	muls	r3, r1
 8003314:	18d0      	adds	r0, r2, r3
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8003316:	1a5b      	subs	r3, r3, r1
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8003318:	6062      	str	r2, [r4, #4]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800331a:	18d2      	adds	r2, r2, r3
            pxQueue->cRxLock = queueUNLOCKED;
 800331c:	0023      	movs	r3, r4
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800331e:	60a0      	str	r0, [r4, #8]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8003320:	60e2      	str	r2, [r4, #12]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8003322:	2000      	movs	r0, #0
            pxQueue->cRxLock = queueUNLOCKED;
 8003324:	22ff      	movs	r2, #255	@ 0xff
 8003326:	3344      	adds	r3, #68	@ 0x44
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8003328:	63a0      	str	r0, [r4, #56]	@ 0x38
            pxQueue->cRxLock = queueUNLOCKED;
 800332a:	701a      	strb	r2, [r3, #0]
            pxQueue->cTxLock = queueUNLOCKED;
 800332c:	705a      	strb	r2, [r3, #1]
            if( xNewQueue == pdFALSE )
 800332e:	4285      	cmp	r5, r0
 8003330:	d112      	bne.n	8003358 <xQueueGenericReset+0x8a>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003332:	6923      	ldr	r3, [r4, #16]
 8003334:	4283      	cmp	r3, r0
 8003336:	d007      	beq.n	8003348 <xQueueGenericReset+0x7a>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003338:	0020      	movs	r0, r4
 800333a:	3010      	adds	r0, #16
 800333c:	f000 fed2 	bl	80040e4 <xTaskRemoveFromEventList>
 8003340:	2800      	cmp	r0, #0
 8003342:	d001      	beq.n	8003348 <xQueueGenericReset+0x7a>
                        queueYIELD_IF_USING_PREEMPTION();
 8003344:	f001 f970 	bl	8004628 <vPortYield>
        taskEXIT_CRITICAL();
 8003348:	f001 f986 	bl	8004658 <vPortExitCritical>
}
 800334c:	2001      	movs	r0, #1
 800334e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 8003350:	2f00      	cmp	r7, #0
 8003352:	d10a      	bne.n	800336a <xQueueGenericReset+0x9c>
 8003354:	1c10      	adds	r0, r2, #0
 8003356:	e7cd      	b.n	80032f4 <xQueueGenericReset+0x26>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8003358:	0020      	movs	r0, r4
 800335a:	3010      	adds	r0, #16
 800335c:	f7ff feee 	bl	800313c <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8003360:	0020      	movs	r0, r4
 8003362:	3024      	adds	r0, #36	@ 0x24
 8003364:	f7ff feea 	bl	800313c <vListInitialise>
 8003368:	e7ee      	b.n	8003348 <xQueueGenericReset+0x7a>
    configASSERT( xReturn != pdFAIL );
 800336a:	b672      	cpsid	i
 800336c:	e7fe      	b.n	800336c <xQueueGenericReset+0x9e>

0800336e <xQueueGenericCreateStatic>:
    {
 800336e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003370:	001c      	movs	r4, r3
 8003372:	ab06      	add	r3, sp, #24
 8003374:	781d      	ldrb	r5, [r3, #0]
        configASSERT( pxStaticQueue );
 8003376:	2c00      	cmp	r4, #0
 8003378:	d101      	bne.n	800337e <xQueueGenericCreateStatic+0x10>
 800337a:	b672      	cpsid	i
 800337c:	e7fe      	b.n	800337c <xQueueGenericCreateStatic+0xe>
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 800337e:	2800      	cmp	r0, #0
 8003380:	d003      	beq.n	800338a <xQueueGenericCreateStatic+0x1c>
            ( pxStaticQueue != NULL ) &&
 8003382:	2a00      	cmp	r2, #0
 8003384:	d003      	beq.n	800338e <xQueueGenericCreateStatic+0x20>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 8003386:	2900      	cmp	r1, #0
 8003388:	d103      	bne.n	8003392 <xQueueGenericCreateStatic+0x24>
            configASSERT( pxNewQueue );
 800338a:	b672      	cpsid	i
 800338c:	e7fe      	b.n	800338c <xQueueGenericCreateStatic+0x1e>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
 800338e:	2900      	cmp	r1, #0
 8003390:	d1fb      	bne.n	800338a <xQueueGenericCreateStatic+0x1c>
                volatile size_t xSize = sizeof( StaticQueue_t );
 8003392:	2350      	movs	r3, #80	@ 0x50
 8003394:	9301      	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 8003396:	9b01      	ldr	r3, [sp, #4]
 8003398:	2b50      	cmp	r3, #80	@ 0x50
 800339a:	d001      	beq.n	80033a0 <xQueueGenericCreateStatic+0x32>
 800339c:	b672      	cpsid	i
 800339e:	e7fe      	b.n	800339e <xQueueGenericCreateStatic+0x30>
                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 80033a0:	9b01      	ldr	r3, [sp, #4]
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80033a2:	0023      	movs	r3, r4
 80033a4:	2601      	movs	r6, #1
 80033a6:	3346      	adds	r3, #70	@ 0x46
 80033a8:	701e      	strb	r6, [r3, #0]
    if( uxItemSize == ( UBaseType_t ) 0 )
 80033aa:	2900      	cmp	r1, #0
 80033ac:	d100      	bne.n	80033b0 <xQueueGenericCreateStatic+0x42>
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80033ae:	0022      	movs	r2, r4
    pxNewQueue->uxLength = uxQueueLength;
 80033b0:	63e0      	str	r0, [r4, #60]	@ 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 80033b2:	6421      	str	r1, [r4, #64]	@ 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80033b4:	0020      	movs	r0, r4
 80033b6:	2101      	movs	r1, #1
 80033b8:	6022      	str	r2, [r4, #0]
 80033ba:	f7ff ff88 	bl	80032ce <xQueueGenericReset>
        pxNewQueue->ucQueueType = ucQueueType;
 80033be:	0023      	movs	r3, r4
 80033c0:	334c      	adds	r3, #76	@ 0x4c
    }
 80033c2:	0020      	movs	r0, r4
        pxNewQueue->ucQueueType = ucQueueType;
 80033c4:	701d      	strb	r5, [r3, #0]
    }
 80033c6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080033c8 <xQueueGenericCreate>:
    {
 80033c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80033ca:	0006      	movs	r6, r0
 80033cc:	000d      	movs	r5, r1
 80033ce:	0017      	movs	r7, r2
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 80033d0:	2800      	cmp	r0, #0
 80033d2:	d033      	beq.n	800343c <xQueueGenericCreate+0x74>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 80033d4:	0c03      	lsrs	r3, r0, #16
 80033d6:	0c08      	lsrs	r0, r1, #16
 80033d8:	2b00      	cmp	r3, #0
 80033da:	d12b      	bne.n	8003434 <xQueueGenericCreate+0x6c>
 80033dc:	2800      	cmp	r0, #0
 80033de:	d00b      	beq.n	80033f8 <xQueueGenericCreate+0x30>
 80033e0:	1c03      	adds	r3, r0, #0
 80033e2:	1c31      	adds	r1, r6, #0
 80033e4:	b2b0      	uxth	r0, r6
 80033e6:	b2aa      	uxth	r2, r5
 80033e8:	4342      	muls	r2, r0
 80033ea:	b289      	uxth	r1, r1
 80033ec:	b29b      	uxth	r3, r3
 80033ee:	434b      	muls	r3, r1
 80033f0:	0c12      	lsrs	r2, r2, #16
 80033f2:	189b      	adds	r3, r3, r2
 80033f4:	0c1b      	lsrs	r3, r3, #16
 80033f6:	d121      	bne.n	800343c <xQueueGenericCreate+0x74>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 80033f8:	0028      	movs	r0, r5
 80033fa:	4370      	muls	r0, r6
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 80033fc:	0003      	movs	r3, r0
 80033fe:	3351      	adds	r3, #81	@ 0x51
 8003400:	d81c      	bhi.n	800343c <xQueueGenericCreate+0x74>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8003402:	3050      	adds	r0, #80	@ 0x50
 8003404:	f001 f9b0 	bl	8004768 <pvPortMalloc>
 8003408:	1e04      	subs	r4, r0, #0
            if( pxNewQueue != NULL )
 800340a:	d011      	beq.n	8003430 <xQueueGenericCreate+0x68>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800340c:	0003      	movs	r3, r0
 800340e:	2200      	movs	r2, #0
 8003410:	3346      	adds	r3, #70	@ 0x46
 8003412:	701a      	strb	r2, [r3, #0]
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8003414:	0003      	movs	r3, r0
    if( uxItemSize == ( UBaseType_t ) 0 )
 8003416:	4295      	cmp	r5, r2
 8003418:	d000      	beq.n	800341c <xQueueGenericCreate+0x54>
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800341a:	3350      	adds	r3, #80	@ 0x50
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800341c:	6023      	str	r3, [r4, #0]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800341e:	2101      	movs	r1, #1
 8003420:	0020      	movs	r0, r4
    pxNewQueue->uxLength = uxQueueLength;
 8003422:	63e6      	str	r6, [r4, #60]	@ 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 8003424:	6425      	str	r5, [r4, #64]	@ 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8003426:	f7ff ff52 	bl	80032ce <xQueueGenericReset>
        pxNewQueue->ucQueueType = ucQueueType;
 800342a:	0023      	movs	r3, r4
 800342c:	334c      	adds	r3, #76	@ 0x4c
 800342e:	701f      	strb	r7, [r3, #0]
    }
 8003430:	0020      	movs	r0, r4
 8003432:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 8003434:	2800      	cmp	r0, #0
 8003436:	d101      	bne.n	800343c <xQueueGenericCreate+0x74>
 8003438:	1c29      	adds	r1, r5, #0
 800343a:	e7d3      	b.n	80033e4 <xQueueGenericCreate+0x1c>
            configASSERT( pxNewQueue );
 800343c:	b672      	cpsid	i
 800343e:	e7fe      	b.n	800343e <xQueueGenericCreate+0x76>

08003440 <xQueueGenericSend>:
{
 8003440:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003442:	b085      	sub	sp, #20
 8003444:	0004      	movs	r4, r0
 8003446:	000f      	movs	r7, r1
 8003448:	001e      	movs	r6, r3
 800344a:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
 800344c:	2800      	cmp	r0, #0
 800344e:	d101      	bne.n	8003454 <xQueueGenericSend+0x14>
 8003450:	b672      	cpsid	i
 8003452:	e7fe      	b.n	8003452 <xQueueGenericSend+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8003454:	2900      	cmp	r1, #0
 8003456:	d104      	bne.n	8003462 <xQueueGenericSend+0x22>
 8003458:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800345a:	2b00      	cmp	r3, #0
 800345c:	d001      	beq.n	8003462 <xQueueGenericSend+0x22>
 800345e:	b672      	cpsid	i
 8003460:	e7fe      	b.n	8003460 <xQueueGenericSend+0x20>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8003462:	2e02      	cmp	r6, #2
 8003464:	d104      	bne.n	8003470 <xQueueGenericSend+0x30>
 8003466:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003468:	2b01      	cmp	r3, #1
 800346a:	d001      	beq.n	8003470 <xQueueGenericSend+0x30>
 800346c:	b672      	cpsid	i
 800346e:	e7fe      	b.n	800346e <xQueueGenericSend+0x2e>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003470:	f000 fed8 	bl	8004224 <xTaskGetSchedulerState>
 8003474:	1e05      	subs	r5, r0, #0
 8003476:	d01b      	beq.n	80034b0 <xQueueGenericSend+0x70>
 8003478:	2500      	movs	r5, #0
        taskENTER_CRITICAL();
 800347a:	f001 f8e1 	bl	8004640 <vPortEnterCritical>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800347e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8003480:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003482:	429a      	cmp	r2, r3
 8003484:	d219      	bcs.n	80034ba <xQueueGenericSend+0x7a>
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8003486:	0032      	movs	r2, r6
 8003488:	0039      	movs	r1, r7
 800348a:	0020      	movs	r0, r4
 800348c:	f7ff fea0 	bl	80031d0 <prvCopyDataToQueue>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003490:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8003492:	2b00      	cmp	r3, #0
 8003494:	d003      	beq.n	800349e <xQueueGenericSend+0x5e>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8003496:	0020      	movs	r0, r4
 8003498:	3024      	adds	r0, #36	@ 0x24
 800349a:	f000 fe23 	bl	80040e4 <xTaskRemoveFromEventList>
 800349e:	2800      	cmp	r0, #0
 80034a0:	d001      	beq.n	80034a6 <xQueueGenericSend+0x66>
                            queueYIELD_IF_USING_PREEMPTION();
 80034a2:	f001 f8c1 	bl	8004628 <vPortYield>
                taskEXIT_CRITICAL();
 80034a6:	f001 f8d7 	bl	8004658 <vPortExitCritical>
                return pdPASS;
 80034aa:	2001      	movs	r0, #1
}
 80034ac:	b005      	add	sp, #20
 80034ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80034b0:	9b01      	ldr	r3, [sp, #4]
 80034b2:	2b00      	cmp	r3, #0
 80034b4:	d0e1      	beq.n	800347a <xQueueGenericSend+0x3a>
 80034b6:	b672      	cpsid	i
 80034b8:	e7fe      	b.n	80034b8 <xQueueGenericSend+0x78>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80034ba:	2e02      	cmp	r6, #2
 80034bc:	d0e3      	beq.n	8003486 <xQueueGenericSend+0x46>
                if( xTicksToWait == ( TickType_t ) 0 )
 80034be:	9b01      	ldr	r3, [sp, #4]
 80034c0:	2b00      	cmp	r3, #0
 80034c2:	d103      	bne.n	80034cc <xQueueGenericSend+0x8c>
                    taskEXIT_CRITICAL();
 80034c4:	f001 f8c8 	bl	8004658 <vPortExitCritical>
                    return errQUEUE_FULL;
 80034c8:	2000      	movs	r0, #0
 80034ca:	e7ef      	b.n	80034ac <xQueueGenericSend+0x6c>
                else if( xEntryTimeSet == pdFALSE )
 80034cc:	2d00      	cmp	r5, #0
 80034ce:	d102      	bne.n	80034d6 <xQueueGenericSend+0x96>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 80034d0:	a802      	add	r0, sp, #8
 80034d2:	f000 fe65 	bl	80041a0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 80034d6:	f001 f8bf 	bl	8004658 <vPortExitCritical>
        vTaskSuspendAll();
 80034da:	f000 fbe3 	bl	8003ca4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 80034de:	f001 f8af 	bl	8004640 <vPortEnterCritical>
 80034e2:	0022      	movs	r2, r4
 80034e4:	3244      	adds	r2, #68	@ 0x44
 80034e6:	7813      	ldrb	r3, [r2, #0]
 80034e8:	b25b      	sxtb	r3, r3
 80034ea:	3301      	adds	r3, #1
 80034ec:	d101      	bne.n	80034f2 <xQueueGenericSend+0xb2>
 80034ee:	2300      	movs	r3, #0
 80034f0:	7013      	strb	r3, [r2, #0]
 80034f2:	0022      	movs	r2, r4
 80034f4:	3245      	adds	r2, #69	@ 0x45
 80034f6:	7813      	ldrb	r3, [r2, #0]
 80034f8:	b25b      	sxtb	r3, r3
 80034fa:	3301      	adds	r3, #1
 80034fc:	d101      	bne.n	8003502 <xQueueGenericSend+0xc2>
 80034fe:	2300      	movs	r3, #0
 8003500:	7013      	strb	r3, [r2, #0]
 8003502:	f001 f8a9 	bl	8004658 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8003506:	a901      	add	r1, sp, #4
 8003508:	a802      	add	r0, sp, #8
 800350a:	f000 fe55 	bl	80041b8 <xTaskCheckForTimeOut>
 800350e:	2800      	cmp	r0, #0
 8003510:	d11f      	bne.n	8003552 <xQueueGenericSend+0x112>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8003512:	f001 f895 	bl	8004640 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8003516:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8003518:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800351a:	429a      	cmp	r2, r3
 800351c:	d110      	bne.n	8003540 <xQueueGenericSend+0x100>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 800351e:	f001 f89b 	bl	8004658 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8003522:	0020      	movs	r0, r4
 8003524:	9901      	ldr	r1, [sp, #4]
 8003526:	3010      	adds	r0, #16
 8003528:	f000 fda6 	bl	8004078 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 800352c:	0020      	movs	r0, r4
 800352e:	f7ff fe99 	bl	8003264 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 8003532:	f000 fc7d 	bl	8003e30 <xTaskResumeAll>
 8003536:	2800      	cmp	r0, #0
 8003538:	d109      	bne.n	800354e <xQueueGenericSend+0x10e>
                    portYIELD_WITHIN_API();
 800353a:	f001 f875 	bl	8004628 <vPortYield>
 800353e:	e006      	b.n	800354e <xQueueGenericSend+0x10e>
    taskEXIT_CRITICAL();
 8003540:	f001 f88a 	bl	8004658 <vPortExitCritical>
                prvUnlockQueue( pxQueue );
 8003544:	0020      	movs	r0, r4
 8003546:	f7ff fe8d 	bl	8003264 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 800354a:	f000 fc71 	bl	8003e30 <xTaskResumeAll>
 800354e:	2501      	movs	r5, #1
 8003550:	e793      	b.n	800347a <xQueueGenericSend+0x3a>
            prvUnlockQueue( pxQueue );
 8003552:	0020      	movs	r0, r4
 8003554:	f7ff fe86 	bl	8003264 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8003558:	f000 fc6a 	bl	8003e30 <xTaskResumeAll>
            return errQUEUE_FULL;
 800355c:	e7b4      	b.n	80034c8 <xQueueGenericSend+0x88>

0800355e <xQueueGenericSendFromISR>:
{
 800355e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003560:	b085      	sub	sp, #20
 8003562:	0004      	movs	r4, r0
 8003564:	0017      	movs	r7, r2
 8003566:	001e      	movs	r6, r3
 8003568:	9101      	str	r1, [sp, #4]
    configASSERT( pxQueue );
 800356a:	2800      	cmp	r0, #0
 800356c:	d101      	bne.n	8003572 <xQueueGenericSendFromISR+0x14>
 800356e:	b672      	cpsid	i
 8003570:	e7fe      	b.n	8003570 <xQueueGenericSendFromISR+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8003572:	9b01      	ldr	r3, [sp, #4]
 8003574:	2b00      	cmp	r3, #0
 8003576:	d104      	bne.n	8003582 <xQueueGenericSendFromISR+0x24>
 8003578:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800357a:	2b00      	cmp	r3, #0
 800357c:	d001      	beq.n	8003582 <xQueueGenericSendFromISR+0x24>
 800357e:	b672      	cpsid	i
 8003580:	e7fe      	b.n	8003580 <xQueueGenericSendFromISR+0x22>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8003582:	2e02      	cmp	r6, #2
 8003584:	d104      	bne.n	8003590 <xQueueGenericSendFromISR+0x32>
 8003586:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003588:	2b01      	cmp	r3, #1
 800358a:	d001      	beq.n	8003590 <xQueueGenericSendFromISR+0x32>
 800358c:	b672      	cpsid	i
 800358e:	e7fe      	b.n	800358e <xQueueGenericSendFromISR+0x30>
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003590:	f001 f870 	bl	8004674 <ulSetInterruptMaskFromISR>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8003594:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8003596:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003598:	9003      	str	r0, [sp, #12]
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800359a:	429a      	cmp	r2, r3
 800359c:	d302      	bcc.n	80035a4 <xQueueGenericSendFromISR+0x46>
            xReturn = errQUEUE_FULL;
 800359e:	2500      	movs	r5, #0
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80035a0:	2e02      	cmp	r6, #2
 80035a2:	d11a      	bne.n	80035da <xQueueGenericSendFromISR+0x7c>
            const int8_t cTxLock = pxQueue->cTxLock;
 80035a4:	0023      	movs	r3, r4
 80035a6:	3345      	adds	r3, #69	@ 0x45
 80035a8:	9302      	str	r3, [sp, #8]
 80035aa:	781d      	ldrb	r5, [r3, #0]
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80035ac:	0032      	movs	r2, r6
            const int8_t cTxLock = pxQueue->cTxLock;
 80035ae:	b26d      	sxtb	r5, r5
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80035b0:	0020      	movs	r0, r4
 80035b2:	9901      	ldr	r1, [sp, #4]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 80035b4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80035b6:	f7ff fe0b 	bl	80031d0 <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
 80035ba:	1c6b      	adds	r3, r5, #1
 80035bc:	d113      	bne.n	80035e6 <xQueueGenericSendFromISR+0x88>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80035be:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80035c0:	2b00      	cmp	r3, #0
 80035c2:	d009      	beq.n	80035d8 <xQueueGenericSendFromISR+0x7a>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80035c4:	0020      	movs	r0, r4
 80035c6:	3024      	adds	r0, #36	@ 0x24
 80035c8:	f000 fd8c 	bl	80040e4 <xTaskRemoveFromEventList>
 80035cc:	2800      	cmp	r0, #0
 80035ce:	d003      	beq.n	80035d8 <xQueueGenericSendFromISR+0x7a>
                            if( pxHigherPriorityTaskWoken != NULL )
 80035d0:	2f00      	cmp	r7, #0
 80035d2:	d001      	beq.n	80035d8 <xQueueGenericSendFromISR+0x7a>
                                *pxHigherPriorityTaskWoken = pdTRUE;
 80035d4:	2301      	movs	r3, #1
 80035d6:	603b      	str	r3, [r7, #0]
            xReturn = pdPASS;
 80035d8:	2501      	movs	r5, #1
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80035da:	9803      	ldr	r0, [sp, #12]
 80035dc:	f001 f84e 	bl	800467c <vClearInterruptMaskFromISR>
}
 80035e0:	0028      	movs	r0, r5
 80035e2:	b005      	add	sp, #20
 80035e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 80035e6:	f000 fb71 	bl	8003ccc <uxTaskGetNumberOfTasks>
 80035ea:	4285      	cmp	r5, r0
 80035ec:	d2f4      	bcs.n	80035d8 <xQueueGenericSendFromISR+0x7a>
 80035ee:	2d7f      	cmp	r5, #127	@ 0x7f
 80035f0:	d101      	bne.n	80035f6 <xQueueGenericSendFromISR+0x98>
 80035f2:	b672      	cpsid	i
 80035f4:	e7fe      	b.n	80035f4 <xQueueGenericSendFromISR+0x96>
 80035f6:	9b02      	ldr	r3, [sp, #8]
 80035f8:	3501      	adds	r5, #1
 80035fa:	b26d      	sxtb	r5, r5
 80035fc:	701d      	strb	r5, [r3, #0]
 80035fe:	e7eb      	b.n	80035d8 <xQueueGenericSendFromISR+0x7a>

08003600 <xQueueReceive>:
{
 8003600:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003602:	b085      	sub	sp, #20
 8003604:	0004      	movs	r4, r0
 8003606:	000e      	movs	r6, r1
 8003608:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 800360a:	2800      	cmp	r0, #0
 800360c:	d101      	bne.n	8003612 <xQueueReceive+0x12>
 800360e:	b672      	cpsid	i
 8003610:	e7fe      	b.n	8003610 <xQueueReceive+0x10>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8003612:	2900      	cmp	r1, #0
 8003614:	d104      	bne.n	8003620 <xQueueReceive+0x20>
 8003616:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8003618:	2b00      	cmp	r3, #0
 800361a:	d001      	beq.n	8003620 <xQueueReceive+0x20>
 800361c:	b672      	cpsid	i
 800361e:	e7fe      	b.n	800361e <xQueueReceive+0x1e>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003620:	f000 fe00 	bl	8004224 <xTaskGetSchedulerState>
 8003624:	1e05      	subs	r5, r0, #0
 8003626:	d01b      	beq.n	8003660 <xQueueReceive+0x60>
 8003628:	2500      	movs	r5, #0
        taskENTER_CRITICAL();
 800362a:	f001 f809 	bl	8004640 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800362e:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8003630:	2f00      	cmp	r7, #0
 8003632:	d01a      	beq.n	800366a <xQueueReceive+0x6a>
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8003634:	0031      	movs	r1, r6
 8003636:	0020      	movs	r0, r4
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8003638:	3f01      	subs	r7, #1
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 800363a:	f7ff fe01 	bl	8003240 <prvCopyDataFromQueue>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800363e:	63a7      	str	r7, [r4, #56]	@ 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003640:	6923      	ldr	r3, [r4, #16]
 8003642:	2b00      	cmp	r3, #0
 8003644:	d007      	beq.n	8003656 <xQueueReceive+0x56>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003646:	0020      	movs	r0, r4
 8003648:	3010      	adds	r0, #16
 800364a:	f000 fd4b 	bl	80040e4 <xTaskRemoveFromEventList>
 800364e:	2800      	cmp	r0, #0
 8003650:	d001      	beq.n	8003656 <xQueueReceive+0x56>
                        queueYIELD_IF_USING_PREEMPTION();
 8003652:	f000 ffe9 	bl	8004628 <vPortYield>
                taskEXIT_CRITICAL();
 8003656:	f000 ffff 	bl	8004658 <vPortExitCritical>
                return pdPASS;
 800365a:	2001      	movs	r0, #1
}
 800365c:	b005      	add	sp, #20
 800365e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003660:	9b01      	ldr	r3, [sp, #4]
 8003662:	2b00      	cmp	r3, #0
 8003664:	d0e1      	beq.n	800362a <xQueueReceive+0x2a>
 8003666:	b672      	cpsid	i
 8003668:	e7fe      	b.n	8003668 <xQueueReceive+0x68>
                if( xTicksToWait == ( TickType_t ) 0 )
 800366a:	9b01      	ldr	r3, [sp, #4]
 800366c:	2b00      	cmp	r3, #0
 800366e:	d103      	bne.n	8003678 <xQueueReceive+0x78>
                    taskEXIT_CRITICAL();
 8003670:	f000 fff2 	bl	8004658 <vPortExitCritical>
                    return errQUEUE_EMPTY;
 8003674:	2000      	movs	r0, #0
 8003676:	e7f1      	b.n	800365c <xQueueReceive+0x5c>
                else if( xEntryTimeSet == pdFALSE )
 8003678:	2d00      	cmp	r5, #0
 800367a:	d102      	bne.n	8003682 <xQueueReceive+0x82>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 800367c:	a802      	add	r0, sp, #8
 800367e:	f000 fd8f 	bl	80041a0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 8003682:	f000 ffe9 	bl	8004658 <vPortExitCritical>
        vTaskSuspendAll();
 8003686:	f000 fb0d 	bl	8003ca4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 800368a:	f000 ffd9 	bl	8004640 <vPortEnterCritical>
 800368e:	0022      	movs	r2, r4
 8003690:	3244      	adds	r2, #68	@ 0x44
 8003692:	7813      	ldrb	r3, [r2, #0]
 8003694:	b25b      	sxtb	r3, r3
 8003696:	3301      	adds	r3, #1
 8003698:	d101      	bne.n	800369e <xQueueReceive+0x9e>
 800369a:	2300      	movs	r3, #0
 800369c:	7013      	strb	r3, [r2, #0]
 800369e:	0022      	movs	r2, r4
 80036a0:	3245      	adds	r2, #69	@ 0x45
 80036a2:	7813      	ldrb	r3, [r2, #0]
 80036a4:	b25b      	sxtb	r3, r3
 80036a6:	3301      	adds	r3, #1
 80036a8:	d101      	bne.n	80036ae <xQueueReceive+0xae>
 80036aa:	2300      	movs	r3, #0
 80036ac:	7013      	strb	r3, [r2, #0]
 80036ae:	f000 ffd3 	bl	8004658 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80036b2:	a901      	add	r1, sp, #4
 80036b4:	a802      	add	r0, sp, #8
 80036b6:	f000 fd7f 	bl	80041b8 <xTaskCheckForTimeOut>
 80036ba:	2800      	cmp	r0, #0
 80036bc:	d11a      	bne.n	80036f4 <xQueueReceive+0xf4>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80036be:	0020      	movs	r0, r4
 80036c0:	f7ff fd7c 	bl	80031bc <prvIsQueueEmpty>
 80036c4:	2800      	cmp	r0, #0
 80036c6:	d00f      	beq.n	80036e8 <xQueueReceive+0xe8>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80036c8:	0020      	movs	r0, r4
 80036ca:	9901      	ldr	r1, [sp, #4]
 80036cc:	3024      	adds	r0, #36	@ 0x24
 80036ce:	f000 fcd3 	bl	8004078 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 80036d2:	0020      	movs	r0, r4
 80036d4:	f7ff fdc6 	bl	8003264 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 80036d8:	f000 fbaa 	bl	8003e30 <xTaskResumeAll>
 80036dc:	2800      	cmp	r0, #0
 80036de:	d101      	bne.n	80036e4 <xQueueReceive+0xe4>
                    portYIELD_WITHIN_API();
 80036e0:	f000 ffa2 	bl	8004628 <vPortYield>
 80036e4:	2501      	movs	r5, #1
 80036e6:	e7a0      	b.n	800362a <xQueueReceive+0x2a>
                prvUnlockQueue( pxQueue );
 80036e8:	0020      	movs	r0, r4
 80036ea:	f7ff fdbb 	bl	8003264 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 80036ee:	f000 fb9f 	bl	8003e30 <xTaskResumeAll>
 80036f2:	e7f7      	b.n	80036e4 <xQueueReceive+0xe4>
            prvUnlockQueue( pxQueue );
 80036f4:	0020      	movs	r0, r4
 80036f6:	f7ff fdb5 	bl	8003264 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 80036fa:	f000 fb99 	bl	8003e30 <xTaskResumeAll>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80036fe:	0020      	movs	r0, r4
 8003700:	f7ff fd5c 	bl	80031bc <prvIsQueueEmpty>
 8003704:	2800      	cmp	r0, #0
 8003706:	d0ed      	beq.n	80036e4 <xQueueReceive+0xe4>
 8003708:	e7b4      	b.n	8003674 <xQueueReceive+0x74>

0800370a <xQueueReceiveFromISR>:
{
 800370a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800370c:	b085      	sub	sp, #20
 800370e:	0004      	movs	r4, r0
 8003710:	0017      	movs	r7, r2
 8003712:	9101      	str	r1, [sp, #4]
    configASSERT( pxQueue );
 8003714:	2800      	cmp	r0, #0
 8003716:	d101      	bne.n	800371c <xQueueReceiveFromISR+0x12>
 8003718:	b672      	cpsid	i
 800371a:	e7fe      	b.n	800371a <xQueueReceiveFromISR+0x10>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800371c:	9b01      	ldr	r3, [sp, #4]
 800371e:	2b00      	cmp	r3, #0
 8003720:	d104      	bne.n	800372c <xQueueReceiveFromISR+0x22>
 8003722:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8003724:	2b00      	cmp	r3, #0
 8003726:	d001      	beq.n	800372c <xQueueReceiveFromISR+0x22>
 8003728:	b672      	cpsid	i
 800372a:	e7fe      	b.n	800372a <xQueueReceiveFromISR+0x20>
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800372c:	f000 ffa2 	bl	8004674 <ulSetInterruptMaskFromISR>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8003730:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003732:	9003      	str	r0, [sp, #12]
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8003734:	2e00      	cmp	r6, #0
 8003736:	d01a      	beq.n	800376e <xQueueReceiveFromISR+0x64>
            const int8_t cRxLock = pxQueue->cRxLock;
 8003738:	0023      	movs	r3, r4
 800373a:	3344      	adds	r3, #68	@ 0x44
 800373c:	9302      	str	r3, [sp, #8]
 800373e:	781d      	ldrb	r5, [r3, #0]
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 8003740:	0020      	movs	r0, r4
 8003742:	9901      	ldr	r1, [sp, #4]
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8003744:	3e01      	subs	r6, #1
            const int8_t cRxLock = pxQueue->cRxLock;
 8003746:	b26d      	sxtb	r5, r5
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 8003748:	f7ff fd7a 	bl	8003240 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800374c:	63a6      	str	r6, [r4, #56]	@ 0x38
            if( cRxLock == queueUNLOCKED )
 800374e:	1c6b      	adds	r3, r5, #1
 8003750:	d113      	bne.n	800377a <xQueueReceiveFromISR+0x70>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003752:	6923      	ldr	r3, [r4, #16]
 8003754:	2b00      	cmp	r3, #0
 8003756:	d009      	beq.n	800376c <xQueueReceiveFromISR+0x62>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003758:	0020      	movs	r0, r4
 800375a:	3010      	adds	r0, #16
 800375c:	f000 fcc2 	bl	80040e4 <xTaskRemoveFromEventList>
 8003760:	2800      	cmp	r0, #0
 8003762:	d003      	beq.n	800376c <xQueueReceiveFromISR+0x62>
                        if( pxHigherPriorityTaskWoken != NULL )
 8003764:	2f00      	cmp	r7, #0
 8003766:	d001      	beq.n	800376c <xQueueReceiveFromISR+0x62>
                            *pxHigherPriorityTaskWoken = pdTRUE;
 8003768:	2301      	movs	r3, #1
 800376a:	603b      	str	r3, [r7, #0]
            xReturn = pdPASS;
 800376c:	2601      	movs	r6, #1
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800376e:	9803      	ldr	r0, [sp, #12]
 8003770:	f000 ff84 	bl	800467c <vClearInterruptMaskFromISR>
}
 8003774:	0030      	movs	r0, r6
 8003776:	b005      	add	sp, #20
 8003778:	bdf0      	pop	{r4, r5, r6, r7, pc}
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 800377a:	f000 faa7 	bl	8003ccc <uxTaskGetNumberOfTasks>
 800377e:	4285      	cmp	r5, r0
 8003780:	d2f4      	bcs.n	800376c <xQueueReceiveFromISR+0x62>
 8003782:	2d7f      	cmp	r5, #127	@ 0x7f
 8003784:	d101      	bne.n	800378a <xQueueReceiveFromISR+0x80>
 8003786:	b672      	cpsid	i
 8003788:	e7fe      	b.n	8003788 <xQueueReceiveFromISR+0x7e>
 800378a:	9b02      	ldr	r3, [sp, #8]
 800378c:	3501      	adds	r5, #1
 800378e:	b26d      	sxtb	r5, r5
 8003790:	701d      	strb	r5, [r3, #0]
 8003792:	e7eb      	b.n	800376c <xQueueReceiveFromISR+0x62>

08003794 <uxQueueMessagesWaiting>:
{
 8003794:	b510      	push	{r4, lr}
 8003796:	1e04      	subs	r4, r0, #0
    configASSERT( xQueue );
 8003798:	d101      	bne.n	800379e <uxQueueMessagesWaiting+0xa>
 800379a:	b672      	cpsid	i
 800379c:	e7fe      	b.n	800379c <uxQueueMessagesWaiting+0x8>
    taskENTER_CRITICAL();
 800379e:	f000 ff4f 	bl	8004640 <vPortEnterCritical>
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 80037a2:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
    taskEXIT_CRITICAL();
 80037a4:	f000 ff58 	bl	8004658 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80037a8:	0020      	movs	r0, r4
 80037aa:	bd10      	pop	{r4, pc}

080037ac <uxQueueMessagesWaitingFromISR>:
    configASSERT( pxQueue );
 80037ac:	2800      	cmp	r0, #0
 80037ae:	d101      	bne.n	80037b4 <uxQueueMessagesWaitingFromISR+0x8>
 80037b0:	b672      	cpsid	i
 80037b2:	e7fe      	b.n	80037b2 <uxQueueMessagesWaitingFromISR+0x6>
    uxReturn = pxQueue->uxMessagesWaiting;
 80037b4:	6b80      	ldr	r0, [r0, #56]	@ 0x38
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80037b6:	4770      	bx	lr

080037b8 <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
 80037b8:	b570      	push	{r4, r5, r6, lr}
        UBaseType_t ux;
        QueueRegistryItem_t * pxEntryToWrite = NULL;

        configASSERT( xQueue );
 80037ba:	2800      	cmp	r0, #0
 80037bc:	d101      	bne.n	80037c2 <vQueueAddToRegistry+0xa>
 80037be:	b672      	cpsid	i
 80037c0:	e7fe      	b.n	80037c0 <vQueueAddToRegistry+0x8>

        if( pcQueueName != NULL )
 80037c2:	2900      	cmp	r1, #0
 80037c4:	d017      	beq.n	80037f6 <vQueueAddToRegistry+0x3e>
        QueueRegistryItem_t * pxEntryToWrite = NULL;
 80037c6:	2300      	movs	r3, #0
 80037c8:	4c0b      	ldr	r4, [pc, #44]	@ (80037f8 <vQueueAddToRegistry+0x40>)
        {
            /* See if there is an empty space in the registry.  A NULL name denotes
             * a free slot. */
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80037ca:	001a      	movs	r2, r3
 80037cc:	0025      	movs	r5, r4
            {
                /* Replace an existing entry if the queue is already in the registry. */
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 80037ce:	6866      	ldr	r6, [r4, #4]
 80037d0:	4286      	cmp	r6, r0
 80037d2:	d104      	bne.n	80037de <vQueueAddToRegistry+0x26>
                {
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 80037d4:	00d2      	lsls	r2, r2, #3
 80037d6:	18ab      	adds	r3, r5, r2
        }

        if( pxEntryToWrite != NULL )
        {
            /* Store the information on this queue. */
            pxEntryToWrite->pcQueueName = pcQueueName;
 80037d8:	6019      	str	r1, [r3, #0]
            pxEntryToWrite->xHandle = xQueue;
 80037da:	6058      	str	r0, [r3, #4]

            traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
        }
    }
 80037dc:	e00b      	b.n	80037f6 <vQueueAddToRegistry+0x3e>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 80037de:	2b00      	cmp	r3, #0
 80037e0:	d103      	bne.n	80037ea <vQueueAddToRegistry+0x32>
 80037e2:	6826      	ldr	r6, [r4, #0]
 80037e4:	2e00      	cmp	r6, #0
 80037e6:	d100      	bne.n	80037ea <vQueueAddToRegistry+0x32>
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 80037e8:	0023      	movs	r3, r4
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80037ea:	3201      	adds	r2, #1
 80037ec:	3408      	adds	r4, #8
 80037ee:	2a08      	cmp	r2, #8
 80037f0:	d1ed      	bne.n	80037ce <vQueueAddToRegistry+0x16>
        if( pxEntryToWrite != NULL )
 80037f2:	2b00      	cmp	r3, #0
 80037f4:	d1f0      	bne.n	80037d8 <vQueueAddToRegistry+0x20>
    }
 80037f6:	bd70      	pop	{r4, r5, r6, pc}
 80037f8:	2000069c 	.word	0x2000069c

080037fc <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 80037fc:	b570      	push	{r4, r5, r6, lr}
 80037fe:	0004      	movs	r4, r0
 8003800:	0016      	movs	r6, r2
 8003802:	000d      	movs	r5, r1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 8003804:	f000 ff1c 	bl	8004640 <vPortEnterCritical>
 8003808:	0022      	movs	r2, r4
 800380a:	3244      	adds	r2, #68	@ 0x44
 800380c:	7813      	ldrb	r3, [r2, #0]
 800380e:	b25b      	sxtb	r3, r3
 8003810:	3301      	adds	r3, #1
 8003812:	d101      	bne.n	8003818 <vQueueWaitForMessageRestricted+0x1c>
 8003814:	2300      	movs	r3, #0
 8003816:	7013      	strb	r3, [r2, #0]
 8003818:	0022      	movs	r2, r4
 800381a:	3245      	adds	r2, #69	@ 0x45
 800381c:	7813      	ldrb	r3, [r2, #0]
 800381e:	b25b      	sxtb	r3, r3
 8003820:	3301      	adds	r3, #1
 8003822:	d101      	bne.n	8003828 <vQueueWaitForMessageRestricted+0x2c>
 8003824:	2300      	movs	r3, #0
 8003826:	7013      	strb	r3, [r2, #0]
 8003828:	f000 ff16 	bl	8004658 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800382c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800382e:	2b00      	cmp	r3, #0
 8003830:	d105      	bne.n	800383e <vQueueWaitForMessageRestricted+0x42>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8003832:	0020      	movs	r0, r4
 8003834:	0032      	movs	r2, r6
 8003836:	0029      	movs	r1, r5
 8003838:	3024      	adds	r0, #36	@ 0x24
 800383a:	f000 fc2f 	bl	800409c <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
 800383e:	0020      	movs	r0, r4
 8003840:	f7ff fd10 	bl	8003264 <prvUnlockQueue>
    }
 8003844:	bd70      	pop	{r4, r5, r6, pc}
	...

08003848 <prvAddNewTaskToReadyList>:
    }
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 8003848:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800384a:	0004      	movs	r4, r0
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 800384c:	f000 fef8 	bl	8004640 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 8003850:	4b2e      	ldr	r3, [pc, #184]	@ (800390c <prvAddNewTaskToReadyList+0xc4>)

        if( pxCurrentTCB == NULL )
 8003852:	4d2f      	ldr	r5, [pc, #188]	@ (8003910 <prvAddNewTaskToReadyList+0xc8>)
        uxCurrentNumberOfTasks++;
 8003854:	681a      	ldr	r2, [r3, #0]
 8003856:	4e2f      	ldr	r6, [pc, #188]	@ (8003914 <prvAddNewTaskToReadyList+0xcc>)
 8003858:	3201      	adds	r2, #1
 800385a:	601a      	str	r2, [r3, #0]
        if( pxCurrentTCB == NULL )
 800385c:	682f      	ldr	r7, [r5, #0]
 800385e:	2f00      	cmp	r7, #0
 8003860:	d149      	bne.n	80038f6 <prvAddNewTaskToReadyList+0xae>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 8003862:	602c      	str	r4, [r5, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8003864:	681b      	ldr	r3, [r3, #0]
 8003866:	2b01      	cmp	r3, #1
 8003868:	d11e      	bne.n	80038a8 <prvAddNewTaskToReadyList+0x60>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800386a:	2014      	movs	r0, #20
 800386c:	4378      	muls	r0, r7
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800386e:	3701      	adds	r7, #1
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003870:	1830      	adds	r0, r6, r0
 8003872:	f7ff fc63 	bl	800313c <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8003876:	2f38      	cmp	r7, #56	@ 0x38
 8003878:	d1f7      	bne.n	800386a <prvAddNewTaskToReadyList+0x22>
    }

    vListInitialise( &xDelayedTaskList1 );
 800387a:	4f27      	ldr	r7, [pc, #156]	@ (8003918 <prvAddNewTaskToReadyList+0xd0>)
 800387c:	0038      	movs	r0, r7
 800387e:	f7ff fc5d 	bl	800313c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8003882:	4b26      	ldr	r3, [pc, #152]	@ (800391c <prvAddNewTaskToReadyList+0xd4>)
 8003884:	0018      	movs	r0, r3
 8003886:	9301      	str	r3, [sp, #4]
 8003888:	f7ff fc58 	bl	800313c <vListInitialise>
    vListInitialise( &xPendingReadyList );
 800388c:	4824      	ldr	r0, [pc, #144]	@ (8003920 <prvAddNewTaskToReadyList+0xd8>)
 800388e:	f7ff fc55 	bl	800313c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 8003892:	4824      	ldr	r0, [pc, #144]	@ (8003924 <prvAddNewTaskToReadyList+0xdc>)
 8003894:	f7ff fc52 	bl	800313c <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 8003898:	4823      	ldr	r0, [pc, #140]	@ (8003928 <prvAddNewTaskToReadyList+0xe0>)
 800389a:	f7ff fc4f 	bl	800313c <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 800389e:	4b23      	ldr	r3, [pc, #140]	@ (800392c <prvAddNewTaskToReadyList+0xe4>)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80038a0:	9a01      	ldr	r2, [sp, #4]
    pxDelayedTaskList = &xDelayedTaskList1;
 80038a2:	601f      	str	r7, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80038a4:	4b22      	ldr	r3, [pc, #136]	@ (8003930 <prvAddNewTaskToReadyList+0xe8>)
 80038a6:	601a      	str	r2, [r3, #0]
        uxTaskNumber++;
 80038a8:	4a22      	ldr	r2, [pc, #136]	@ (8003934 <prvAddNewTaskToReadyList+0xec>)
 80038aa:	6813      	ldr	r3, [r2, #0]
 80038ac:	3301      	adds	r3, #1
 80038ae:	6013      	str	r3, [r2, #0]
            pxNewTCB->uxTCBNumber = uxTaskNumber;
 80038b0:	6463      	str	r3, [r4, #68]	@ 0x44
        prvAddTaskToReadyList( pxNewTCB );
 80038b2:	4b21      	ldr	r3, [pc, #132]	@ (8003938 <prvAddNewTaskToReadyList+0xf0>)
 80038b4:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80038b6:	6819      	ldr	r1, [r3, #0]
 80038b8:	428a      	cmp	r2, r1
 80038ba:	d900      	bls.n	80038be <prvAddNewTaskToReadyList+0x76>
 80038bc:	601a      	str	r2, [r3, #0]
 80038be:	2314      	movs	r3, #20
 80038c0:	4353      	muls	r3, r2
 80038c2:	18f1      	adds	r1, r6, r3
 80038c4:	684a      	ldr	r2, [r1, #4]
 80038c6:	1d20      	adds	r0, r4, #4
 80038c8:	6897      	ldr	r7, [r2, #8]
 80038ca:	60a2      	str	r2, [r4, #8]
 80038cc:	60e7      	str	r7, [r4, #12]
 80038ce:	6078      	str	r0, [r7, #4]
 80038d0:	6090      	str	r0, [r2, #8]
 80038d2:	58f2      	ldr	r2, [r6, r3]
 80038d4:	6161      	str	r1, [r4, #20]
 80038d6:	3201      	adds	r2, #1
 80038d8:	50f2      	str	r2, [r6, r3]
    taskEXIT_CRITICAL();
 80038da:	f000 febd 	bl	8004658 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 80038de:	4b17      	ldr	r3, [pc, #92]	@ (800393c <prvAddNewTaskToReadyList+0xf4>)
 80038e0:	681b      	ldr	r3, [r3, #0]
 80038e2:	2b00      	cmp	r3, #0
 80038e4:	d006      	beq.n	80038f4 <prvAddNewTaskToReadyList+0xac>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80038e6:	682b      	ldr	r3, [r5, #0]
 80038e8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80038ea:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80038ec:	429a      	cmp	r2, r3
 80038ee:	d201      	bcs.n	80038f4 <prvAddNewTaskToReadyList+0xac>
            taskYIELD_IF_USING_PREEMPTION();
 80038f0:	f000 fe9a 	bl	8004628 <vPortYield>
}
 80038f4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            if( xSchedulerRunning == pdFALSE )
 80038f6:	4b11      	ldr	r3, [pc, #68]	@ (800393c <prvAddNewTaskToReadyList+0xf4>)
 80038f8:	681a      	ldr	r2, [r3, #0]
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80038fa:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
            if( xSchedulerRunning == pdFALSE )
 80038fc:	2a00      	cmp	r2, #0
 80038fe:	d1d3      	bne.n	80038a8 <prvAddNewTaskToReadyList+0x60>
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8003900:	682a      	ldr	r2, [r5, #0]
 8003902:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8003904:	429a      	cmp	r2, r3
 8003906:	d8cf      	bhi.n	80038a8 <prvAddNewTaskToReadyList+0x60>
                    pxCurrentTCB = pxNewTCB;
 8003908:	602c      	str	r4, [r5, #0]
 800390a:	e7cd      	b.n	80038a8 <prvAddNewTaskToReadyList+0x60>
 800390c:	20000700 	.word	0x20000700
 8003910:	20000bd4 	.word	0x20000bd4
 8003914:	20000774 	.word	0x20000774
 8003918:	20000760 	.word	0x20000760
 800391c:	2000074c 	.word	0x2000074c
 8003920:	20000730 	.word	0x20000730
 8003924:	2000071c 	.word	0x2000071c
 8003928:	20000704 	.word	0x20000704
 800392c:	20000748 	.word	0x20000748
 8003930:	20000744 	.word	0x20000744
 8003934:	200006e4 	.word	0x200006e4
 8003938:	200006f8 	.word	0x200006f8
 800393c:	200006f4 	.word	0x200006f4

08003940 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8003940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003942:	0004      	movs	r4, r0
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8003944:	4b1b      	ldr	r3, [pc, #108]	@ (80039b4 <prvAddCurrentTaskToDelayedList+0x74>)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003946:	4d1c      	ldr	r5, [pc, #112]	@ (80039b8 <prvAddCurrentTaskToDelayedList+0x78>)
    const TickType_t xConstTickCount = xTickCount;
 8003948:	681e      	ldr	r6, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800394a:	6828      	ldr	r0, [r5, #0]
{
 800394c:	000f      	movs	r7, r1
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800394e:	3004      	adds	r0, #4
 8003950:	f7ff fc24 	bl	800319c <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8003954:	1c63      	adds	r3, r4, #1
 8003956:	d114      	bne.n	8003982 <prvAddCurrentTaskToDelayedList+0x42>
 8003958:	2f00      	cmp	r7, #0
 800395a:	d012      	beq.n	8003982 <prvAddCurrentTaskToDelayedList+0x42>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800395c:	4b17      	ldr	r3, [pc, #92]	@ (80039bc <prvAddCurrentTaskToDelayedList+0x7c>)
 800395e:	6829      	ldr	r1, [r5, #0]
 8003960:	685a      	ldr	r2, [r3, #4]
 8003962:	608a      	str	r2, [r1, #8]
 8003964:	6890      	ldr	r0, [r2, #8]
 8003966:	6829      	ldr	r1, [r5, #0]
 8003968:	60c8      	str	r0, [r1, #12]
 800396a:	6829      	ldr	r1, [r5, #0]
 800396c:	3104      	adds	r1, #4
 800396e:	6041      	str	r1, [r0, #4]
 8003970:	6829      	ldr	r1, [r5, #0]
 8003972:	3104      	adds	r1, #4
 8003974:	6091      	str	r1, [r2, #8]
 8003976:	682a      	ldr	r2, [r5, #0]
 8003978:	6153      	str	r3, [r2, #20]
 800397a:	681a      	ldr	r2, [r3, #0]
 800397c:	3201      	adds	r2, #1
 800397e:	601a      	str	r2, [r3, #0]

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 8003980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8003982:	682b      	ldr	r3, [r5, #0]
            xTimeToWake = xConstTickCount + xTicksToWait;
 8003984:	1934      	adds	r4, r6, r4
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8003986:	605c      	str	r4, [r3, #4]
            if( xTimeToWake < xConstTickCount )
 8003988:	42a6      	cmp	r6, r4
 800398a:	d906      	bls.n	800399a <prvAddCurrentTaskToDelayedList+0x5a>
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800398c:	4b0c      	ldr	r3, [pc, #48]	@ (80039c0 <prvAddCurrentTaskToDelayedList+0x80>)
 800398e:	6818      	ldr	r0, [r3, #0]
 8003990:	6829      	ldr	r1, [r5, #0]
 8003992:	3104      	adds	r1, #4
 8003994:	f7ff fbeb 	bl	800316e <vListInsert>
 8003998:	e7f2      	b.n	8003980 <prvAddCurrentTaskToDelayedList+0x40>
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800399a:	4b0a      	ldr	r3, [pc, #40]	@ (80039c4 <prvAddCurrentTaskToDelayedList+0x84>)
 800399c:	6818      	ldr	r0, [r3, #0]
 800399e:	6829      	ldr	r1, [r5, #0]
 80039a0:	3104      	adds	r1, #4
 80039a2:	f7ff fbe4 	bl	800316e <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
 80039a6:	4b08      	ldr	r3, [pc, #32]	@ (80039c8 <prvAddCurrentTaskToDelayedList+0x88>)
 80039a8:	681a      	ldr	r2, [r3, #0]
 80039aa:	42a2      	cmp	r2, r4
 80039ac:	d9e8      	bls.n	8003980 <prvAddCurrentTaskToDelayedList+0x40>
                    xNextTaskUnblockTime = xTimeToWake;
 80039ae:	601c      	str	r4, [r3, #0]
}
 80039b0:	e7e6      	b.n	8003980 <prvAddCurrentTaskToDelayedList+0x40>
 80039b2:	46c0      	nop			@ (mov r8, r8)
 80039b4:	200006fc 	.word	0x200006fc
 80039b8:	20000bd4 	.word	0x20000bd4
 80039bc:	20000704 	.word	0x20000704
 80039c0:	20000744 	.word	0x20000744
 80039c4:	20000748 	.word	0x20000748
 80039c8:	200006e0 	.word	0x200006e0

080039cc <prvResetNextTaskUnblockTime>:
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80039cc:	4a06      	ldr	r2, [pc, #24]	@ (80039e8 <prvResetNextTaskUnblockTime+0x1c>)
 80039ce:	6813      	ldr	r3, [r2, #0]
 80039d0:	6819      	ldr	r1, [r3, #0]
 80039d2:	4b06      	ldr	r3, [pc, #24]	@ (80039ec <prvResetNextTaskUnblockTime+0x20>)
 80039d4:	2900      	cmp	r1, #0
 80039d6:	d103      	bne.n	80039e0 <prvResetNextTaskUnblockTime+0x14>
        xNextTaskUnblockTime = portMAX_DELAY;
 80039d8:	2201      	movs	r2, #1
 80039da:	4252      	negs	r2, r2
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 80039dc:	601a      	str	r2, [r3, #0]
}
 80039de:	4770      	bx	lr
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 80039e0:	6812      	ldr	r2, [r2, #0]
 80039e2:	68d2      	ldr	r2, [r2, #12]
 80039e4:	6812      	ldr	r2, [r2, #0]
 80039e6:	e7f9      	b.n	80039dc <prvResetNextTaskUnblockTime+0x10>
 80039e8:	20000748 	.word	0x20000748
 80039ec:	200006e0 	.word	0x200006e0

080039f0 <prvDeleteTCB>:
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 80039f0:	0003      	movs	r3, r0
    {
 80039f2:	b510      	push	{r4, lr}
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 80039f4:	3359      	adds	r3, #89	@ 0x59
 80039f6:	781b      	ldrb	r3, [r3, #0]
    {
 80039f8:	0004      	movs	r4, r0
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 80039fa:	2b00      	cmp	r3, #0
 80039fc:	d106      	bne.n	8003a0c <prvDeleteTCB+0x1c>
                vPortFreeStack( pxTCB->pxStack );
 80039fe:	6b00      	ldr	r0, [r0, #48]	@ 0x30
 8003a00:	f000 fee2 	bl	80047c8 <vPortFree>
                vPortFree( pxTCB );
 8003a04:	0020      	movs	r0, r4
 8003a06:	f000 fedf 	bl	80047c8 <vPortFree>
    }
 8003a0a:	bd10      	pop	{r4, pc}
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8003a0c:	2b01      	cmp	r3, #1
 8003a0e:	d0f9      	beq.n	8003a04 <prvDeleteTCB+0x14>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 8003a10:	2b02      	cmp	r3, #2
 8003a12:	d0fa      	beq.n	8003a0a <prvDeleteTCB+0x1a>
 8003a14:	b672      	cpsid	i
 8003a16:	e7fe      	b.n	8003a16 <prvDeleteTCB+0x26>

08003a18 <prvIdleTask>:
{
 8003a18:	b570      	push	{r4, r5, r6, lr}
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8003a1a:	4c10      	ldr	r4, [pc, #64]	@ (8003a5c <prvIdleTask+0x44>)
 8003a1c:	6823      	ldr	r3, [r4, #0]
 8003a1e:	2b00      	cmp	r3, #0
 8003a20:	d106      	bne.n	8003a30 <prvIdleTask+0x18>
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8003a22:	4b0f      	ldr	r3, [pc, #60]	@ (8003a60 <prvIdleTask+0x48>)
 8003a24:	681b      	ldr	r3, [r3, #0]
 8003a26:	2b01      	cmp	r3, #1
 8003a28:	d9f7      	bls.n	8003a1a <prvIdleTask+0x2>
                taskYIELD();
 8003a2a:	f000 fdfd 	bl	8004628 <vPortYield>
 8003a2e:	e7f4      	b.n	8003a1a <prvIdleTask+0x2>
            taskENTER_CRITICAL();
 8003a30:	f000 fe06 	bl	8004640 <vPortEnterCritical>
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003a34:	4b0b      	ldr	r3, [pc, #44]	@ (8003a64 <prvIdleTask+0x4c>)
 8003a36:	68db      	ldr	r3, [r3, #12]
 8003a38:	68dd      	ldr	r5, [r3, #12]
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003a3a:	1d28      	adds	r0, r5, #4
 8003a3c:	f7ff fbae 	bl	800319c <uxListRemove>
                --uxCurrentNumberOfTasks;
 8003a40:	4a09      	ldr	r2, [pc, #36]	@ (8003a68 <prvIdleTask+0x50>)
 8003a42:	6813      	ldr	r3, [r2, #0]
 8003a44:	3b01      	subs	r3, #1
 8003a46:	6013      	str	r3, [r2, #0]
                --uxDeletedTasksWaitingCleanUp;
 8003a48:	6823      	ldr	r3, [r4, #0]
 8003a4a:	3b01      	subs	r3, #1
 8003a4c:	6023      	str	r3, [r4, #0]
            taskEXIT_CRITICAL();
 8003a4e:	f000 fe03 	bl	8004658 <vPortExitCritical>
            prvDeleteTCB( pxTCB );
 8003a52:	0028      	movs	r0, r5
 8003a54:	f7ff ffcc 	bl	80039f0 <prvDeleteTCB>
 8003a58:	e7df      	b.n	8003a1a <prvIdleTask+0x2>
 8003a5a:	46c0      	nop			@ (mov r8, r8)
 8003a5c:	20000718 	.word	0x20000718
 8003a60:	20000774 	.word	0x20000774
 8003a64:	2000071c 	.word	0x2000071c
 8003a68:	20000700 	.word	0x20000700

08003a6c <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 8003a6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003a6e:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003a70:	0095      	lsls	r5, r2, #2
static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 8003a72:	9000      	str	r0, [sp, #0]
 8003a74:	000e      	movs	r6, r1
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003a76:	002a      	movs	r2, r5
 8003a78:	21a5      	movs	r1, #165	@ 0xa5
 8003a7a:	6b20      	ldr	r0, [r4, #48]	@ 0x30
static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 8003a7c:	9301      	str	r3, [sp, #4]
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003a7e:	f000 fef9 	bl	8004874 <memset>
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8003a82:	6b27      	ldr	r7, [r4, #48]	@ 0x30
    if( pcName != NULL )
 8003a84:	2e00      	cmp	r6, #0
 8003a86:	d00d      	beq.n	8003aa4 <prvInitialiseNewTask.constprop.0+0x38>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003a88:	0021      	movs	r1, r4
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8003a8a:	2300      	movs	r3, #0
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003a8c:	3134      	adds	r1, #52	@ 0x34
 8003a8e:	5cf2      	ldrb	r2, [r6, r3]
 8003a90:	54ca      	strb	r2, [r1, r3]
            if( pcName[ x ] == ( char ) 0x00 )
 8003a92:	2a00      	cmp	r2, #0
 8003a94:	d002      	beq.n	8003a9c <prvInitialiseNewTask.constprop.0+0x30>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8003a96:	3301      	adds	r3, #1
 8003a98:	2b10      	cmp	r3, #16
 8003a9a:	d1f8      	bne.n	8003a8e <prvInitialiseNewTask.constprop.0+0x22>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8003a9c:	0023      	movs	r3, r4
 8003a9e:	2200      	movs	r2, #0
 8003aa0:	3343      	adds	r3, #67	@ 0x43
 8003aa2:	701a      	strb	r2, [r3, #0]
    configASSERT( uxPriority < configMAX_PRIORITIES );
 8003aa4:	9b08      	ldr	r3, [sp, #32]
 8003aa6:	2b37      	cmp	r3, #55	@ 0x37
 8003aa8:	d901      	bls.n	8003aae <prvInitialiseNewTask.constprop.0+0x42>
 8003aaa:	b672      	cpsid	i
 8003aac:	e7fe      	b.n	8003aac <prvInitialiseNewTask.constprop.0+0x40>
    pxNewTCB->uxPriority = uxPriority;
 8003aae:	9b08      	ldr	r3, [sp, #32]
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8003ab0:	1d20      	adds	r0, r4, #4
    pxNewTCB->uxPriority = uxPriority;
 8003ab2:	62e3      	str	r3, [r4, #44]	@ 0x2c
        pxNewTCB->uxBasePriority = uxPriority;
 8003ab4:	64e3      	str	r3, [r4, #76]	@ 0x4c
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8003ab6:	f7ff fb4c 	bl	8003152 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8003aba:	0020      	movs	r0, r4
 8003abc:	3018      	adds	r0, #24
 8003abe:	f7ff fb48 	bl	8003152 <vListInitialiseItem>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003ac2:	2338      	movs	r3, #56	@ 0x38
 8003ac4:	9a08      	ldr	r2, [sp, #32]
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8003ac6:	1f28      	subs	r0, r5, #4
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003ac8:	1a9b      	subs	r3, r3, r2
 8003aca:	61a3      	str	r3, [r4, #24]
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8003acc:	2307      	movs	r3, #7
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8003ace:	1838      	adds	r0, r7, r0
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8003ad0:	4398      	bics	r0, r3
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003ad2:	9a01      	ldr	r2, [sp, #4]
 8003ad4:	9900      	ldr	r1, [sp, #0]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8003ad6:	6124      	str	r4, [r4, #16]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8003ad8:	6264      	str	r4, [r4, #36]	@ 0x24
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003ada:	f000 fd93 	bl	8004604 <pxPortInitialiseStack>
    if( pxCreatedTask != NULL )
 8003ade:	9b09      	ldr	r3, [sp, #36]	@ 0x24
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003ae0:	6020      	str	r0, [r4, #0]
    if( pxCreatedTask != NULL )
 8003ae2:	2b00      	cmp	r3, #0
 8003ae4:	d000      	beq.n	8003ae8 <prvInitialiseNewTask.constprop.0+0x7c>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8003ae6:	601c      	str	r4, [r3, #0]
}
 8003ae8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003aea <xTaskCreateStatic>:
    {
 8003aea:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003aec:	b089      	sub	sp, #36	@ 0x24
 8003aee:	9305      	str	r3, [sp, #20]
        configASSERT( puxStackBuffer != NULL );
 8003af0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
    {
 8003af2:	0007      	movs	r7, r0
 8003af4:	000d      	movs	r5, r1
 8003af6:	0016      	movs	r6, r2
 8003af8:	9c10      	ldr	r4, [sp, #64]	@ 0x40
        configASSERT( puxStackBuffer != NULL );
 8003afa:	2b00      	cmp	r3, #0
 8003afc:	d101      	bne.n	8003b02 <xTaskCreateStatic+0x18>
 8003afe:	b672      	cpsid	i
 8003b00:	e7fe      	b.n	8003b00 <xTaskCreateStatic+0x16>
        configASSERT( pxTaskBuffer != NULL );
 8003b02:	2c00      	cmp	r4, #0
 8003b04:	d101      	bne.n	8003b0a <xTaskCreateStatic+0x20>
 8003b06:	b672      	cpsid	i
 8003b08:	e7fe      	b.n	8003b08 <xTaskCreateStatic+0x1e>
            volatile size_t xSize = sizeof( StaticTask_t );
 8003b0a:	235c      	movs	r3, #92	@ 0x5c
 8003b0c:	9307      	str	r3, [sp, #28]
            configASSERT( xSize == sizeof( TCB_t ) );
 8003b0e:	9a07      	ldr	r2, [sp, #28]
 8003b10:	429a      	cmp	r2, r3
 8003b12:	d001      	beq.n	8003b18 <xTaskCreateStatic+0x2e>
 8003b14:	b672      	cpsid	i
 8003b16:	e7fe      	b.n	8003b16 <xTaskCreateStatic+0x2c>
            memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 8003b18:	2100      	movs	r1, #0
 8003b1a:	0020      	movs	r0, r4
            ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8003b1c:	9b07      	ldr	r3, [sp, #28]
            memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 8003b1e:	f000 fea9 	bl	8004874 <memset>
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8003b22:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8003b24:	2202      	movs	r2, #2
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8003b26:	6323      	str	r3, [r4, #48]	@ 0x30
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8003b28:	0023      	movs	r3, r4
 8003b2a:	3359      	adds	r3, #89	@ 0x59
 8003b2c:	701a      	strb	r2, [r3, #0]
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8003b2e:	ab06      	add	r3, sp, #24
 8003b30:	9301      	str	r3, [sp, #4]
 8003b32:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8003b34:	0032      	movs	r2, r6
 8003b36:	0029      	movs	r1, r5
 8003b38:	0038      	movs	r0, r7
 8003b3a:	9300      	str	r3, [sp, #0]
 8003b3c:	9402      	str	r4, [sp, #8]
 8003b3e:	9b05      	ldr	r3, [sp, #20]
 8003b40:	f7ff ff94 	bl	8003a6c <prvInitialiseNewTask.constprop.0>
            prvAddNewTaskToReadyList( pxNewTCB );
 8003b44:	0020      	movs	r0, r4
 8003b46:	f7ff fe7f 	bl	8003848 <prvAddNewTaskToReadyList>
        return xReturn;
 8003b4a:	9806      	ldr	r0, [sp, #24]
    }
 8003b4c:	b009      	add	sp, #36	@ 0x24
 8003b4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003b50 <xTaskCreate>:
    {
 8003b50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b52:	b087      	sub	sp, #28
 8003b54:	9004      	str	r0, [sp, #16]
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8003b56:	0090      	lsls	r0, r2, #2
    {
 8003b58:	000f      	movs	r7, r1
 8003b5a:	0016      	movs	r6, r2
 8003b5c:	9305      	str	r3, [sp, #20]
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8003b5e:	f000 fe03 	bl	8004768 <pvPortMalloc>
 8003b62:	1e05      	subs	r5, r0, #0
            if( pxStack != NULL )
 8003b64:	d103      	bne.n	8003b6e <xTaskCreate+0x1e>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003b66:	2001      	movs	r0, #1
 8003b68:	4240      	negs	r0, r0
    }
 8003b6a:	b007      	add	sp, #28
 8003b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8003b6e:	205c      	movs	r0, #92	@ 0x5c
 8003b70:	f000 fdfa 	bl	8004768 <pvPortMalloc>
 8003b74:	1e04      	subs	r4, r0, #0
                if( pxNewTCB != NULL )
 8003b76:	d014      	beq.n	8003ba2 <xTaskCreate+0x52>
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 8003b78:	225c      	movs	r2, #92	@ 0x5c
 8003b7a:	2100      	movs	r1, #0
 8003b7c:	f000 fe7a 	bl	8004874 <memset>
            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003b80:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
                    pxNewTCB->pxStack = pxStack;
 8003b82:	6325      	str	r5, [r4, #48]	@ 0x30
            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003b84:	9301      	str	r3, [sp, #4]
 8003b86:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8003b88:	0032      	movs	r2, r6
 8003b8a:	0039      	movs	r1, r7
 8003b8c:	9804      	ldr	r0, [sp, #16]
 8003b8e:	9300      	str	r3, [sp, #0]
 8003b90:	9402      	str	r4, [sp, #8]
 8003b92:	9b05      	ldr	r3, [sp, #20]
 8003b94:	f7ff ff6a 	bl	8003a6c <prvInitialiseNewTask.constprop.0>
            prvAddNewTaskToReadyList( pxNewTCB );
 8003b98:	0020      	movs	r0, r4
 8003b9a:	f7ff fe55 	bl	8003848 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 8003b9e:	2001      	movs	r0, #1
 8003ba0:	e7e3      	b.n	8003b6a <xTaskCreate+0x1a>
                    vPortFreeStack( pxStack );
 8003ba2:	0028      	movs	r0, r5
 8003ba4:	f000 fe10 	bl	80047c8 <vPortFree>
        if( pxNewTCB != NULL )
 8003ba8:	e7dd      	b.n	8003b66 <xTaskCreate+0x16>
	...

08003bac <vTaskResume>:
    {
 8003bac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003bae:	1e04      	subs	r4, r0, #0
        configASSERT( xTaskToResume );
 8003bb0:	d101      	bne.n	8003bb6 <vTaskResume+0xa>
 8003bb2:	b672      	cpsid	i
 8003bb4:	e7fe      	b.n	8003bb4 <vTaskResume+0x8>
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 8003bb6:	4b19      	ldr	r3, [pc, #100]	@ (8003c1c <vTaskResume+0x70>)
 8003bb8:	9301      	str	r3, [sp, #4]
 8003bba:	681b      	ldr	r3, [r3, #0]
 8003bbc:	4283      	cmp	r3, r0
 8003bbe:	d02c      	beq.n	8003c1a <vTaskResume+0x6e>
            taskENTER_CRITICAL();
 8003bc0:	f000 fd3e 	bl	8004640 <vPortEnterCritical>
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003bc4:	4b16      	ldr	r3, [pc, #88]	@ (8003c20 <vTaskResume+0x74>)
 8003bc6:	6962      	ldr	r2, [r4, #20]
 8003bc8:	429a      	cmp	r2, r3
 8003bca:	d124      	bne.n	8003c16 <vTaskResume+0x6a>
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8003bcc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8003bce:	4a15      	ldr	r2, [pc, #84]	@ (8003c24 <vTaskResume+0x78>)
 8003bd0:	4293      	cmp	r3, r2
 8003bd2:	d020      	beq.n	8003c16 <vTaskResume+0x6a>
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 8003bd4:	2b00      	cmp	r3, #0
 8003bd6:	d11e      	bne.n	8003c16 <vTaskResume+0x6a>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003bd8:	1d25      	adds	r5, r4, #4
 8003bda:	0028      	movs	r0, r5
 8003bdc:	f7ff fade 	bl	800319c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8003be0:	4b11      	ldr	r3, [pc, #68]	@ (8003c28 <vTaskResume+0x7c>)
 8003be2:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8003be4:	681a      	ldr	r2, [r3, #0]
 8003be6:	4291      	cmp	r1, r2
 8003be8:	d900      	bls.n	8003bec <vTaskResume+0x40>
 8003bea:	6019      	str	r1, [r3, #0]
 8003bec:	2214      	movs	r2, #20
 8003bee:	434a      	muls	r2, r1
 8003bf0:	4b0e      	ldr	r3, [pc, #56]	@ (8003c2c <vTaskResume+0x80>)
 8003bf2:	189f      	adds	r7, r3, r2
 8003bf4:	6878      	ldr	r0, [r7, #4]
 8003bf6:	6886      	ldr	r6, [r0, #8]
 8003bf8:	60a0      	str	r0, [r4, #8]
 8003bfa:	60e6      	str	r6, [r4, #12]
 8003bfc:	6075      	str	r5, [r6, #4]
 8003bfe:	6085      	str	r5, [r0, #8]
 8003c00:	58d0      	ldr	r0, [r2, r3]
 8003c02:	6167      	str	r7, [r4, #20]
 8003c04:	3001      	adds	r0, #1
 8003c06:	50d0      	str	r0, [r2, r3]
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003c08:	9b01      	ldr	r3, [sp, #4]
 8003c0a:	681b      	ldr	r3, [r3, #0]
 8003c0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003c0e:	4299      	cmp	r1, r3
 8003c10:	d901      	bls.n	8003c16 <vTaskResume+0x6a>
                        taskYIELD_IF_USING_PREEMPTION();
 8003c12:	f000 fd09 	bl	8004628 <vPortYield>
            taskEXIT_CRITICAL();
 8003c16:	f000 fd1f 	bl	8004658 <vPortExitCritical>
    }
 8003c1a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003c1c:	20000bd4 	.word	0x20000bd4
 8003c20:	20000704 	.word	0x20000704
 8003c24:	20000730 	.word	0x20000730
 8003c28:	200006f8 	.word	0x200006f8
 8003c2c:	20000774 	.word	0x20000774

08003c30 <vTaskStartScheduler>:
{
 8003c30:	b510      	push	{r4, lr}
        StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 8003c32:	2400      	movs	r4, #0
{
 8003c34:	b088      	sub	sp, #32
        vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8003c36:	aa07      	add	r2, sp, #28
 8003c38:	a906      	add	r1, sp, #24
 8003c3a:	a805      	add	r0, sp, #20
        StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 8003c3c:	9405      	str	r4, [sp, #20]
        StackType_t * pxIdleTaskStackBuffer = NULL;
 8003c3e:	9406      	str	r4, [sp, #24]
        vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8003c40:	f7ff fa64 	bl	800310c <vApplicationGetIdleTaskMemory>
        xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 8003c44:	9b05      	ldr	r3, [sp, #20]
 8003c46:	4911      	ldr	r1, [pc, #68]	@ (8003c8c <vTaskStartScheduler+0x5c>)
 8003c48:	9302      	str	r3, [sp, #8]
 8003c4a:	9b06      	ldr	r3, [sp, #24]
 8003c4c:	4810      	ldr	r0, [pc, #64]	@ (8003c90 <vTaskStartScheduler+0x60>)
 8003c4e:	9301      	str	r3, [sp, #4]
 8003c50:	9a07      	ldr	r2, [sp, #28]
 8003c52:	0023      	movs	r3, r4
 8003c54:	9400      	str	r4, [sp, #0]
 8003c56:	f7ff ff48 	bl	8003aea <xTaskCreateStatic>
        if( xIdleTaskHandle != NULL )
 8003c5a:	42a0      	cmp	r0, r4
 8003c5c:	d00e      	beq.n	8003c7c <vTaskStartScheduler+0x4c>
            xReturn = xTimerCreateTimerTask();
 8003c5e:	f000 fc75 	bl	800454c <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 8003c62:	2801      	cmp	r0, #1
 8003c64:	d10e      	bne.n	8003c84 <vTaskStartScheduler+0x54>
        portDISABLE_INTERRUPTS();
 8003c66:	b672      	cpsid	i
        xNextTaskUnblockTime = portMAX_DELAY;
 8003c68:	2201      	movs	r2, #1
 8003c6a:	4b0a      	ldr	r3, [pc, #40]	@ (8003c94 <vTaskStartScheduler+0x64>)
 8003c6c:	4252      	negs	r2, r2
 8003c6e:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8003c70:	4b09      	ldr	r3, [pc, #36]	@ (8003c98 <vTaskStartScheduler+0x68>)
 8003c72:	6018      	str	r0, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8003c74:	4b09      	ldr	r3, [pc, #36]	@ (8003c9c <vTaskStartScheduler+0x6c>)
 8003c76:	601c      	str	r4, [r3, #0]
        xPortStartScheduler();
 8003c78:	f000 fd58 	bl	800472c <xPortStartScheduler>
    ( void ) uxTopUsedPriority;
 8003c7c:	4b08      	ldr	r3, [pc, #32]	@ (8003ca0 <vTaskStartScheduler+0x70>)
 8003c7e:	681b      	ldr	r3, [r3, #0]
}
 8003c80:	b008      	add	sp, #32
 8003c82:	bd10      	pop	{r4, pc}
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8003c84:	3001      	adds	r0, #1
 8003c86:	d1f9      	bne.n	8003c7c <vTaskStartScheduler+0x4c>
 8003c88:	b672      	cpsid	i
 8003c8a:	e7fe      	b.n	8003c8a <vTaskStartScheduler+0x5a>
 8003c8c:	0800494c 	.word	0x0800494c
 8003c90:	08003a19 	.word	0x08003a19
 8003c94:	200006e0 	.word	0x200006e0
 8003c98:	200006f4 	.word	0x200006f4
 8003c9c:	200006fc 	.word	0x200006fc
 8003ca0:	08004a30 	.word	0x08004a30

08003ca4 <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 8003ca4:	4a02      	ldr	r2, [pc, #8]	@ (8003cb0 <vTaskSuspendAll+0xc>)
 8003ca6:	6813      	ldr	r3, [r2, #0]
 8003ca8:	3301      	adds	r3, #1
 8003caa:	6013      	str	r3, [r2, #0]
}
 8003cac:	4770      	bx	lr
 8003cae:	46c0      	nop			@ (mov r8, r8)
 8003cb0:	200006dc 	.word	0x200006dc

08003cb4 <xTaskGetTickCount>:
        xTicks = xTickCount;
 8003cb4:	4b01      	ldr	r3, [pc, #4]	@ (8003cbc <xTaskGetTickCount+0x8>)
 8003cb6:	6818      	ldr	r0, [r3, #0]
}
 8003cb8:	4770      	bx	lr
 8003cba:	46c0      	nop			@ (mov r8, r8)
 8003cbc:	200006fc 	.word	0x200006fc

08003cc0 <xTaskGetTickCountFromISR>:
TickType_t xTaskGetTickCountFromISR( void )
 8003cc0:	4b01      	ldr	r3, [pc, #4]	@ (8003cc8 <xTaskGetTickCountFromISR+0x8>)
 8003cc2:	6818      	ldr	r0, [r3, #0]
 8003cc4:	4770      	bx	lr
 8003cc6:	46c0      	nop			@ (mov r8, r8)
 8003cc8:	200006fc 	.word	0x200006fc

08003ccc <uxTaskGetNumberOfTasks>:
    return uxCurrentNumberOfTasks;
 8003ccc:	4b01      	ldr	r3, [pc, #4]	@ (8003cd4 <uxTaskGetNumberOfTasks+0x8>)
 8003cce:	6818      	ldr	r0, [r3, #0]
}
 8003cd0:	4770      	bx	lr
 8003cd2:	46c0      	nop			@ (mov r8, r8)
 8003cd4:	20000700 	.word	0x20000700

08003cd8 <xTaskIncrementTick>:
{
 8003cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8003cda:	4b4a      	ldr	r3, [pc, #296]	@ (8003e04 <xTaskIncrementTick+0x12c>)
{
 8003cdc:	b085      	sub	sp, #20
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8003cde:	681b      	ldr	r3, [r3, #0]
 8003ce0:	2b00      	cmp	r3, #0
 8003ce2:	d000      	beq.n	8003ce6 <xTaskIncrementTick+0xe>
 8003ce4:	e085      	b.n	8003df2 <xTaskIncrementTick+0x11a>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8003ce6:	4b48      	ldr	r3, [pc, #288]	@ (8003e08 <xTaskIncrementTick+0x130>)
 8003ce8:	681f      	ldr	r7, [r3, #0]
 8003cea:	3701      	adds	r7, #1
        xTickCount = xConstTickCount;
 8003cec:	601f      	str	r7, [r3, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8003cee:	2f00      	cmp	r7, #0
 8003cf0:	d111      	bne.n	8003d16 <xTaskIncrementTick+0x3e>
            taskSWITCH_DELAYED_LISTS();
 8003cf2:	4b46      	ldr	r3, [pc, #280]	@ (8003e0c <xTaskIncrementTick+0x134>)
 8003cf4:	681a      	ldr	r2, [r3, #0]
 8003cf6:	6812      	ldr	r2, [r2, #0]
 8003cf8:	2a00      	cmp	r2, #0
 8003cfa:	d001      	beq.n	8003d00 <xTaskIncrementTick+0x28>
 8003cfc:	b672      	cpsid	i
 8003cfe:	e7fe      	b.n	8003cfe <xTaskIncrementTick+0x26>
 8003d00:	4a43      	ldr	r2, [pc, #268]	@ (8003e10 <xTaskIncrementTick+0x138>)
 8003d02:	6819      	ldr	r1, [r3, #0]
 8003d04:	6810      	ldr	r0, [r2, #0]
 8003d06:	6018      	str	r0, [r3, #0]
 8003d08:	6011      	str	r1, [r2, #0]
 8003d0a:	4a42      	ldr	r2, [pc, #264]	@ (8003e14 <xTaskIncrementTick+0x13c>)
 8003d0c:	6813      	ldr	r3, [r2, #0]
 8003d0e:	3301      	adds	r3, #1
 8003d10:	6013      	str	r3, [r2, #0]
 8003d12:	f7ff fe5b 	bl	80039cc <prvResetNextTaskUnblockTime>
        if( xConstTickCount >= xNextTaskUnblockTime )
 8003d16:	4b40      	ldr	r3, [pc, #256]	@ (8003e18 <xTaskIncrementTick+0x140>)
    BaseType_t xSwitchRequired = pdFALSE;
 8003d18:	2000      	movs	r0, #0
        if( xConstTickCount >= xNextTaskUnblockTime )
 8003d1a:	681b      	ldr	r3, [r3, #0]
 8003d1c:	429f      	cmp	r7, r3
 8003d1e:	d20f      	bcs.n	8003d40 <xTaskIncrementTick+0x68>
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8003d20:	2214      	movs	r2, #20
 8003d22:	4b3e      	ldr	r3, [pc, #248]	@ (8003e1c <xTaskIncrementTick+0x144>)
 8003d24:	681b      	ldr	r3, [r3, #0]
 8003d26:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8003d28:	4b3d      	ldr	r3, [pc, #244]	@ (8003e20 <xTaskIncrementTick+0x148>)
 8003d2a:	434a      	muls	r2, r1
 8003d2c:	58d3      	ldr	r3, [r2, r3]
 8003d2e:	2b01      	cmp	r3, #1
 8003d30:	d900      	bls.n	8003d34 <xTaskIncrementTick+0x5c>
                xSwitchRequired = pdTRUE;
 8003d32:	2001      	movs	r0, #1
            if( xYieldPending != pdFALSE )
 8003d34:	4b3b      	ldr	r3, [pc, #236]	@ (8003e24 <xTaskIncrementTick+0x14c>)
 8003d36:	681b      	ldr	r3, [r3, #0]
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d160      	bne.n	8003dfe <xTaskIncrementTick+0x126>
}
 8003d3c:	b005      	add	sp, #20
 8003d3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003d40:	4b32      	ldr	r3, [pc, #200]	@ (8003e0c <xTaskIncrementTick+0x134>)
 8003d42:	9302      	str	r3, [sp, #8]
 8003d44:	e04b      	b.n	8003dde <xTaskIncrementTick+0x106>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003d46:	9b02      	ldr	r3, [sp, #8]
 8003d48:	681b      	ldr	r3, [r3, #0]
 8003d4a:	68db      	ldr	r3, [r3, #12]
 8003d4c:	68db      	ldr	r3, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8003d4e:	685a      	ldr	r2, [r3, #4]
                    if( xConstTickCount < xItemValue )
 8003d50:	4297      	cmp	r7, r2
 8003d52:	d201      	bcs.n	8003d58 <xTaskIncrementTick+0x80>
                        xNextTaskUnblockTime = xItemValue;
 8003d54:	4b30      	ldr	r3, [pc, #192]	@ (8003e18 <xTaskIncrementTick+0x140>)
 8003d56:	e04a      	b.n	8003dee <xTaskIncrementTick+0x116>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003d58:	689c      	ldr	r4, [r3, #8]
 8003d5a:	68d9      	ldr	r1, [r3, #12]
 8003d5c:	695a      	ldr	r2, [r3, #20]
 8003d5e:	60a1      	str	r1, [r4, #8]
 8003d60:	604c      	str	r4, [r1, #4]
 8003d62:	1d1c      	adds	r4, r3, #4
 8003d64:	9401      	str	r4, [sp, #4]
 8003d66:	6854      	ldr	r4, [r2, #4]
 8003d68:	1d1d      	adds	r5, r3, #4
 8003d6a:	42ac      	cmp	r4, r5
 8003d6c:	d100      	bne.n	8003d70 <xTaskIncrementTick+0x98>
 8003d6e:	6051      	str	r1, [r2, #4]
 8003d70:	2100      	movs	r1, #0
 8003d72:	6159      	str	r1, [r3, #20]
 8003d74:	6811      	ldr	r1, [r2, #0]
 8003d76:	3901      	subs	r1, #1
 8003d78:	6011      	str	r1, [r2, #0]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003d7a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8003d7c:	2a00      	cmp	r2, #0
 8003d7e:	d00e      	beq.n	8003d9e <xTaskIncrementTick+0xc6>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8003d80:	69dc      	ldr	r4, [r3, #28]
 8003d82:	6a19      	ldr	r1, [r3, #32]
 8003d84:	6855      	ldr	r5, [r2, #4]
 8003d86:	60a1      	str	r1, [r4, #8]
 8003d88:	604c      	str	r4, [r1, #4]
 8003d8a:	001c      	movs	r4, r3
 8003d8c:	3418      	adds	r4, #24
 8003d8e:	42a5      	cmp	r5, r4
 8003d90:	d100      	bne.n	8003d94 <xTaskIncrementTick+0xbc>
 8003d92:	6051      	str	r1, [r2, #4]
 8003d94:	2100      	movs	r1, #0
 8003d96:	6299      	str	r1, [r3, #40]	@ 0x28
 8003d98:	6811      	ldr	r1, [r2, #0]
 8003d9a:	3901      	subs	r1, #1
 8003d9c:	6011      	str	r1, [r2, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003d9e:	4a22      	ldr	r2, [pc, #136]	@ (8003e28 <xTaskIncrementTick+0x150>)
 8003da0:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8003da2:	6814      	ldr	r4, [r2, #0]
 8003da4:	42a1      	cmp	r1, r4
 8003da6:	d900      	bls.n	8003daa <xTaskIncrementTick+0xd2>
 8003da8:	6011      	str	r1, [r2, #0]
 8003daa:	2414      	movs	r4, #20
 8003dac:	434c      	muls	r4, r1
 8003dae:	4a1c      	ldr	r2, [pc, #112]	@ (8003e20 <xTaskIncrementTick+0x148>)
 8003db0:	1915      	adds	r5, r2, r4
 8003db2:	9503      	str	r5, [sp, #12]
 8003db4:	686d      	ldr	r5, [r5, #4]
 8003db6:	9201      	str	r2, [sp, #4]
 8003db8:	68ae      	ldr	r6, [r5, #8]
 8003dba:	1d1a      	adds	r2, r3, #4
 8003dbc:	609d      	str	r5, [r3, #8]
 8003dbe:	60de      	str	r6, [r3, #12]
 8003dc0:	6072      	str	r2, [r6, #4]
 8003dc2:	60aa      	str	r2, [r5, #8]
 8003dc4:	9a03      	ldr	r2, [sp, #12]
 8003dc6:	615a      	str	r2, [r3, #20]
 8003dc8:	9b01      	ldr	r3, [sp, #4]
 8003dca:	9a01      	ldr	r2, [sp, #4]
 8003dcc:	58e3      	ldr	r3, [r4, r3]
 8003dce:	3301      	adds	r3, #1
 8003dd0:	50a3      	str	r3, [r4, r2]
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003dd2:	4b12      	ldr	r3, [pc, #72]	@ (8003e1c <xTaskIncrementTick+0x144>)
 8003dd4:	681b      	ldr	r3, [r3, #0]
 8003dd6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003dd8:	4299      	cmp	r1, r3
 8003dda:	d900      	bls.n	8003dde <xTaskIncrementTick+0x106>
                            xSwitchRequired = pdTRUE;
 8003ddc:	2001      	movs	r0, #1
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003dde:	9b02      	ldr	r3, [sp, #8]
 8003de0:	681b      	ldr	r3, [r3, #0]
 8003de2:	681b      	ldr	r3, [r3, #0]
 8003de4:	2b00      	cmp	r3, #0
 8003de6:	d1ae      	bne.n	8003d46 <xTaskIncrementTick+0x6e>
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003de8:	2201      	movs	r2, #1
 8003dea:	4b0b      	ldr	r3, [pc, #44]	@ (8003e18 <xTaskIncrementTick+0x140>)
 8003dec:	4252      	negs	r2, r2
                        xNextTaskUnblockTime = xItemValue;
 8003dee:	601a      	str	r2, [r3, #0]
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 8003df0:	e796      	b.n	8003d20 <xTaskIncrementTick+0x48>
        ++xPendedTicks;
 8003df2:	4a0e      	ldr	r2, [pc, #56]	@ (8003e2c <xTaskIncrementTick+0x154>)
    BaseType_t xSwitchRequired = pdFALSE;
 8003df4:	2000      	movs	r0, #0
        ++xPendedTicks;
 8003df6:	6813      	ldr	r3, [r2, #0]
 8003df8:	3301      	adds	r3, #1
 8003dfa:	6013      	str	r3, [r2, #0]
 8003dfc:	e79e      	b.n	8003d3c <xTaskIncrementTick+0x64>
                xSwitchRequired = pdTRUE;
 8003dfe:	2001      	movs	r0, #1
    return xSwitchRequired;
 8003e00:	e79c      	b.n	8003d3c <xTaskIncrementTick+0x64>
 8003e02:	46c0      	nop			@ (mov r8, r8)
 8003e04:	200006dc 	.word	0x200006dc
 8003e08:	200006fc 	.word	0x200006fc
 8003e0c:	20000748 	.word	0x20000748
 8003e10:	20000744 	.word	0x20000744
 8003e14:	200006e8 	.word	0x200006e8
 8003e18:	200006e0 	.word	0x200006e0
 8003e1c:	20000bd4 	.word	0x20000bd4
 8003e20:	20000774 	.word	0x20000774
 8003e24:	200006ec 	.word	0x200006ec
 8003e28:	200006f8 	.word	0x200006f8
 8003e2c:	200006f0 	.word	0x200006f0

08003e30 <xTaskResumeAll>:
{
 8003e30:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 8003e32:	4c3a      	ldr	r4, [pc, #232]	@ (8003f1c <xTaskResumeAll+0xec>)
 8003e34:	6823      	ldr	r3, [r4, #0]
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d101      	bne.n	8003e3e <xTaskResumeAll+0xe>
 8003e3a:	b672      	cpsid	i
 8003e3c:	e7fe      	b.n	8003e3c <xTaskResumeAll+0xc>
    taskENTER_CRITICAL();
 8003e3e:	f000 fbff 	bl	8004640 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8003e42:	6823      	ldr	r3, [r4, #0]
 8003e44:	3b01      	subs	r3, #1
 8003e46:	6023      	str	r3, [r4, #0]
        if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8003e48:	6823      	ldr	r3, [r4, #0]
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d004      	beq.n	8003e58 <xTaskResumeAll+0x28>
    BaseType_t xAlreadyYielded = pdFALSE;
 8003e4e:	2400      	movs	r4, #0
    taskEXIT_CRITICAL();
 8003e50:	f000 fc02 	bl	8004658 <vPortExitCritical>
}
 8003e54:	0020      	movs	r0, r4
 8003e56:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8003e58:	4a31      	ldr	r2, [pc, #196]	@ (8003f20 <xTaskResumeAll+0xf0>)
 8003e5a:	6812      	ldr	r2, [r2, #0]
 8003e5c:	2a00      	cmp	r2, #0
 8003e5e:	d0f6      	beq.n	8003e4e <xTaskResumeAll+0x1e>
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003e60:	4a30      	ldr	r2, [pc, #192]	@ (8003f24 <xTaskResumeAll+0xf4>)
 8003e62:	9201      	str	r2, [sp, #4]
 8003e64:	e03b      	b.n	8003ede <xTaskResumeAll+0xae>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003e66:	9b01      	ldr	r3, [sp, #4]
 8003e68:	68db      	ldr	r3, [r3, #12]
 8003e6a:	68db      	ldr	r3, [r3, #12]
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8003e6c:	69d8      	ldr	r0, [r3, #28]
 8003e6e:	6a19      	ldr	r1, [r3, #32]
 8003e70:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8003e72:	6081      	str	r1, [r0, #8]
 8003e74:	6048      	str	r0, [r1, #4]
 8003e76:	0018      	movs	r0, r3
 8003e78:	6854      	ldr	r4, [r2, #4]
 8003e7a:	3018      	adds	r0, #24
 8003e7c:	4284      	cmp	r4, r0
 8003e7e:	d100      	bne.n	8003e82 <xTaskResumeAll+0x52>
 8003e80:	6051      	str	r1, [r2, #4]
 8003e82:	2100      	movs	r1, #0
 8003e84:	6299      	str	r1, [r3, #40]	@ 0x28
 8003e86:	6811      	ldr	r1, [r2, #0]
 8003e88:	3901      	subs	r1, #1
 8003e8a:	6011      	str	r1, [r2, #0]
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003e8c:	695a      	ldr	r2, [r3, #20]
 8003e8e:	6898      	ldr	r0, [r3, #8]
 8003e90:	68d9      	ldr	r1, [r3, #12]
 8003e92:	1d1d      	adds	r5, r3, #4
 8003e94:	6081      	str	r1, [r0, #8]
 8003e96:	6048      	str	r0, [r1, #4]
 8003e98:	6850      	ldr	r0, [r2, #4]
 8003e9a:	42a8      	cmp	r0, r5
 8003e9c:	d100      	bne.n	8003ea0 <xTaskResumeAll+0x70>
 8003e9e:	6051      	str	r1, [r2, #4]
 8003ea0:	6811      	ldr	r1, [r2, #0]
 8003ea2:	3901      	subs	r1, #1
 8003ea4:	6011      	str	r1, [r2, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003ea6:	4a20      	ldr	r2, [pc, #128]	@ (8003f28 <xTaskResumeAll+0xf8>)
 8003ea8:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8003eaa:	6810      	ldr	r0, [r2, #0]
 8003eac:	4281      	cmp	r1, r0
 8003eae:	d900      	bls.n	8003eb2 <xTaskResumeAll+0x82>
 8003eb0:	6011      	str	r1, [r2, #0]
 8003eb2:	2014      	movs	r0, #20
 8003eb4:	4348      	muls	r0, r1
 8003eb6:	4a1d      	ldr	r2, [pc, #116]	@ (8003f2c <xTaskResumeAll+0xfc>)
 8003eb8:	1817      	adds	r7, r2, r0
 8003eba:	687c      	ldr	r4, [r7, #4]
 8003ebc:	68a6      	ldr	r6, [r4, #8]
 8003ebe:	609c      	str	r4, [r3, #8]
 8003ec0:	60de      	str	r6, [r3, #12]
 8003ec2:	6075      	str	r5, [r6, #4]
 8003ec4:	60a5      	str	r5, [r4, #8]
 8003ec6:	5884      	ldr	r4, [r0, r2]
 8003ec8:	615f      	str	r7, [r3, #20]
 8003eca:	3401      	adds	r4, #1
 8003ecc:	5084      	str	r4, [r0, r2]
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003ece:	4a18      	ldr	r2, [pc, #96]	@ (8003f30 <xTaskResumeAll+0x100>)
 8003ed0:	6812      	ldr	r2, [r2, #0]
 8003ed2:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8003ed4:	4291      	cmp	r1, r2
 8003ed6:	d902      	bls.n	8003ede <xTaskResumeAll+0xae>
                        xYieldPending = pdTRUE;
 8003ed8:	2101      	movs	r1, #1
 8003eda:	4a16      	ldr	r2, [pc, #88]	@ (8003f34 <xTaskResumeAll+0x104>)
 8003edc:	6011      	str	r1, [r2, #0]
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003ede:	9a01      	ldr	r2, [sp, #4]
 8003ee0:	6812      	ldr	r2, [r2, #0]
 8003ee2:	2a00      	cmp	r2, #0
 8003ee4:	d1bf      	bne.n	8003e66 <xTaskResumeAll+0x36>
                if( pxTCB != NULL )
 8003ee6:	2b00      	cmp	r3, #0
 8003ee8:	d001      	beq.n	8003eee <xTaskResumeAll+0xbe>
                    prvResetNextTaskUnblockTime();
 8003eea:	f7ff fd6f 	bl	80039cc <prvResetNextTaskUnblockTime>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8003eee:	4d12      	ldr	r5, [pc, #72]	@ (8003f38 <xTaskResumeAll+0x108>)
 8003ef0:	682c      	ldr	r4, [r5, #0]
                    if( xPendedCounts > ( TickType_t ) 0U )
 8003ef2:	2c00      	cmp	r4, #0
 8003ef4:	d00a      	beq.n	8003f0c <xTaskResumeAll+0xdc>
                                xYieldPending = pdTRUE;
 8003ef6:	2601      	movs	r6, #1
                            if( xTaskIncrementTick() != pdFALSE )
 8003ef8:	f7ff feee 	bl	8003cd8 <xTaskIncrementTick>
 8003efc:	2800      	cmp	r0, #0
 8003efe:	d001      	beq.n	8003f04 <xTaskResumeAll+0xd4>
                                xYieldPending = pdTRUE;
 8003f00:	4b0c      	ldr	r3, [pc, #48]	@ (8003f34 <xTaskResumeAll+0x104>)
 8003f02:	601e      	str	r6, [r3, #0]
                            --xPendedCounts;
 8003f04:	3c01      	subs	r4, #1
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8003f06:	2c00      	cmp	r4, #0
 8003f08:	d1f6      	bne.n	8003ef8 <xTaskResumeAll+0xc8>
                        xPendedTicks = 0;
 8003f0a:	602c      	str	r4, [r5, #0]
                if( xYieldPending != pdFALSE )
 8003f0c:	4b09      	ldr	r3, [pc, #36]	@ (8003f34 <xTaskResumeAll+0x104>)
 8003f0e:	681b      	ldr	r3, [r3, #0]
 8003f10:	2b00      	cmp	r3, #0
 8003f12:	d09c      	beq.n	8003e4e <xTaskResumeAll+0x1e>
                    taskYIELD_IF_USING_PREEMPTION();
 8003f14:	f000 fb88 	bl	8004628 <vPortYield>
                        xAlreadyYielded = pdTRUE;
 8003f18:	2401      	movs	r4, #1
 8003f1a:	e799      	b.n	8003e50 <xTaskResumeAll+0x20>
 8003f1c:	200006dc 	.word	0x200006dc
 8003f20:	20000700 	.word	0x20000700
 8003f24:	20000730 	.word	0x20000730
 8003f28:	200006f8 	.word	0x200006f8
 8003f2c:	20000774 	.word	0x20000774
 8003f30:	20000bd4 	.word	0x20000bd4
 8003f34:	200006ec 	.word	0x200006ec
 8003f38:	200006f0 	.word	0x200006f0

08003f3c <vTaskDelay>:
    {
 8003f3c:	b570      	push	{r4, r5, r6, lr}
 8003f3e:	1e04      	subs	r4, r0, #0
        if( xTicksToDelay > ( TickType_t ) 0U )
 8003f40:	d102      	bne.n	8003f48 <vTaskDelay+0xc>
            portYIELD_WITHIN_API();
 8003f42:	f000 fb71 	bl	8004628 <vPortYield>
    }
 8003f46:	bd70      	pop	{r4, r5, r6, pc}
            configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 8003f48:	4b08      	ldr	r3, [pc, #32]	@ (8003f6c <vTaskDelay+0x30>)
 8003f4a:	681d      	ldr	r5, [r3, #0]
 8003f4c:	2d00      	cmp	r5, #0
 8003f4e:	d001      	beq.n	8003f54 <vTaskDelay+0x18>
 8003f50:	b672      	cpsid	i
 8003f52:	e7fe      	b.n	8003f52 <vTaskDelay+0x16>
            vTaskSuspendAll();
 8003f54:	f7ff fea6 	bl	8003ca4 <vTaskSuspendAll>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8003f58:	0029      	movs	r1, r5
 8003f5a:	0020      	movs	r0, r4
 8003f5c:	f7ff fcf0 	bl	8003940 <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = xTaskResumeAll();
 8003f60:	f7ff ff66 	bl	8003e30 <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 8003f64:	2800      	cmp	r0, #0
 8003f66:	d0ec      	beq.n	8003f42 <vTaskDelay+0x6>
 8003f68:	e7ed      	b.n	8003f46 <vTaskDelay+0xa>
 8003f6a:	46c0      	nop			@ (mov r8, r8)
 8003f6c:	200006dc 	.word	0x200006dc

08003f70 <vTaskSwitchContext>:
    if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
 8003f70:	4b15      	ldr	r3, [pc, #84]	@ (8003fc8 <vTaskSwitchContext+0x58>)
{
 8003f72:	b530      	push	{r4, r5, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
 8003f74:	681a      	ldr	r2, [r3, #0]
 8003f76:	4b15      	ldr	r3, [pc, #84]	@ (8003fcc <vTaskSwitchContext+0x5c>)
 8003f78:	2a00      	cmp	r2, #0
 8003f7a:	d002      	beq.n	8003f82 <vTaskSwitchContext+0x12>
        xYieldPending = pdTRUE;
 8003f7c:	2201      	movs	r2, #1
 8003f7e:	601a      	str	r2, [r3, #0]
}
 8003f80:	bd30      	pop	{r4, r5, pc}
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003f82:	2514      	movs	r5, #20
 8003f84:	4c12      	ldr	r4, [pc, #72]	@ (8003fd0 <vTaskSwitchContext+0x60>)
        xYieldPending = pdFALSE;
 8003f86:	601a      	str	r2, [r3, #0]
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003f88:	6822      	ldr	r2, [r4, #0]
 8003f8a:	4912      	ldr	r1, [pc, #72]	@ (8003fd4 <vTaskSwitchContext+0x64>)
 8003f8c:	002b      	movs	r3, r5
 8003f8e:	4353      	muls	r3, r2
 8003f90:	5858      	ldr	r0, [r3, r1]
 8003f92:	2800      	cmp	r0, #0
 8003f94:	d012      	beq.n	8003fbc <vTaskSwitchContext+0x4c>
 8003f96:	18c8      	adds	r0, r1, r3
 8003f98:	6845      	ldr	r5, [r0, #4]
 8003f9a:	3308      	adds	r3, #8
 8003f9c:	686d      	ldr	r5, [r5, #4]
 8003f9e:	185b      	adds	r3, r3, r1
 8003fa0:	6045      	str	r5, [r0, #4]
 8003fa2:	429d      	cmp	r5, r3
 8003fa4:	d101      	bne.n	8003faa <vTaskSwitchContext+0x3a>
 8003fa6:	68c3      	ldr	r3, [r0, #12]
 8003fa8:	6043      	str	r3, [r0, #4]
 8003faa:	2314      	movs	r3, #20
 8003fac:	4353      	muls	r3, r2
 8003fae:	18c9      	adds	r1, r1, r3
 8003fb0:	684b      	ldr	r3, [r1, #4]
 8003fb2:	68d9      	ldr	r1, [r3, #12]
 8003fb4:	4b08      	ldr	r3, [pc, #32]	@ (8003fd8 <vTaskSwitchContext+0x68>)
 8003fb6:	6019      	str	r1, [r3, #0]
 8003fb8:	6022      	str	r2, [r4, #0]
}
 8003fba:	e7e1      	b.n	8003f80 <vTaskSwitchContext+0x10>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003fbc:	2a00      	cmp	r2, #0
 8003fbe:	d101      	bne.n	8003fc4 <vTaskSwitchContext+0x54>
 8003fc0:	b672      	cpsid	i
 8003fc2:	e7fe      	b.n	8003fc2 <vTaskSwitchContext+0x52>
 8003fc4:	3a01      	subs	r2, #1
 8003fc6:	e7e1      	b.n	8003f8c <vTaskSwitchContext+0x1c>
 8003fc8:	200006dc 	.word	0x200006dc
 8003fcc:	200006ec 	.word	0x200006ec
 8003fd0:	200006f8 	.word	0x200006f8
 8003fd4:	20000774 	.word	0x20000774
 8003fd8:	20000bd4 	.word	0x20000bd4

08003fdc <vTaskSuspend>:
    {
 8003fdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003fde:	0004      	movs	r4, r0
        taskENTER_CRITICAL();
 8003fe0:	f000 fb2e 	bl	8004640 <vPortEnterCritical>
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8003fe4:	4d1f      	ldr	r5, [pc, #124]	@ (8004064 <vTaskSuspend+0x88>)
 8003fe6:	2c00      	cmp	r4, #0
 8003fe8:	d100      	bne.n	8003fec <vTaskSuspend+0x10>
 8003fea:	682c      	ldr	r4, [r5, #0]
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003fec:	1d27      	adds	r7, r4, #4
 8003fee:	0038      	movs	r0, r7
 8003ff0:	f7ff f8d4 	bl	800319c <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003ff4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8003ff6:	2b00      	cmp	r3, #0
 8003ff8:	d003      	beq.n	8004002 <vTaskSuspend+0x26>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003ffa:	0020      	movs	r0, r4
 8003ffc:	3018      	adds	r0, #24
 8003ffe:	f7ff f8cd 	bl	800319c <uxListRemove>
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8004002:	4e19      	ldr	r6, [pc, #100]	@ (8004068 <vTaskSuspend+0x8c>)
 8004004:	0039      	movs	r1, r7
 8004006:	0030      	movs	r0, r6
 8004008:	f7ff f8a6 	bl	8003158 <vListInsertEnd>
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 800400c:	0023      	movs	r3, r4
 800400e:	3358      	adds	r3, #88	@ 0x58
 8004010:	781a      	ldrb	r2, [r3, #0]
 8004012:	2a01      	cmp	r2, #1
 8004014:	d101      	bne.n	800401a <vTaskSuspend+0x3e>
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 8004016:	2200      	movs	r2, #0
 8004018:	701a      	strb	r2, [r3, #0]
        taskEXIT_CRITICAL();
 800401a:	f000 fb1d 	bl	8004658 <vPortExitCritical>
        if( xSchedulerRunning != pdFALSE )
 800401e:	4f13      	ldr	r7, [pc, #76]	@ (800406c <vTaskSuspend+0x90>)
 8004020:	683b      	ldr	r3, [r7, #0]
 8004022:	2b00      	cmp	r3, #0
 8004024:	d005      	beq.n	8004032 <vTaskSuspend+0x56>
            taskENTER_CRITICAL();
 8004026:	f000 fb0b 	bl	8004640 <vPortEnterCritical>
                prvResetNextTaskUnblockTime();
 800402a:	f7ff fccf 	bl	80039cc <prvResetNextTaskUnblockTime>
            taskEXIT_CRITICAL();
 800402e:	f000 fb13 	bl	8004658 <vPortExitCritical>
        if( pxTCB == pxCurrentTCB )
 8004032:	682b      	ldr	r3, [r5, #0]
 8004034:	42a3      	cmp	r3, r4
 8004036:	d10a      	bne.n	800404e <vTaskSuspend+0x72>
            if( xSchedulerRunning != pdFALSE )
 8004038:	683b      	ldr	r3, [r7, #0]
 800403a:	2b00      	cmp	r3, #0
 800403c:	d008      	beq.n	8004050 <vTaskSuspend+0x74>
                configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 800403e:	4b0c      	ldr	r3, [pc, #48]	@ (8004070 <vTaskSuspend+0x94>)
 8004040:	681b      	ldr	r3, [r3, #0]
 8004042:	2b00      	cmp	r3, #0
 8004044:	d001      	beq.n	800404a <vTaskSuspend+0x6e>
 8004046:	b672      	cpsid	i
 8004048:	e7fe      	b.n	8004048 <vTaskSuspend+0x6c>
                portYIELD_WITHIN_API();
 800404a:	f000 faed 	bl	8004628 <vPortYield>
    }
 800404e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 8004050:	4a08      	ldr	r2, [pc, #32]	@ (8004074 <vTaskSuspend+0x98>)
 8004052:	6831      	ldr	r1, [r6, #0]
 8004054:	6812      	ldr	r2, [r2, #0]
 8004056:	4291      	cmp	r1, r2
 8004058:	d101      	bne.n	800405e <vTaskSuspend+0x82>
                    pxCurrentTCB = NULL;
 800405a:	602b      	str	r3, [r5, #0]
 800405c:	e7f7      	b.n	800404e <vTaskSuspend+0x72>
                    vTaskSwitchContext();
 800405e:	f7ff ff87 	bl	8003f70 <vTaskSwitchContext>
    }
 8004062:	e7f4      	b.n	800404e <vTaskSuspend+0x72>
 8004064:	20000bd4 	.word	0x20000bd4
 8004068:	20000704 	.word	0x20000704
 800406c:	200006f4 	.word	0x200006f4
 8004070:	200006dc 	.word	0x200006dc
 8004074:	20000700 	.word	0x20000700

08004078 <vTaskPlaceOnEventList>:
{
 8004078:	b510      	push	{r4, lr}
 800407a:	000c      	movs	r4, r1
    configASSERT( pxEventList );
 800407c:	2800      	cmp	r0, #0
 800407e:	d101      	bne.n	8004084 <vTaskPlaceOnEventList+0xc>
 8004080:	b672      	cpsid	i
 8004082:	e7fe      	b.n	8004082 <vTaskPlaceOnEventList+0xa>
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004084:	4b04      	ldr	r3, [pc, #16]	@ (8004098 <vTaskPlaceOnEventList+0x20>)
 8004086:	6819      	ldr	r1, [r3, #0]
 8004088:	3118      	adds	r1, #24
 800408a:	f7ff f870 	bl	800316e <vListInsert>
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800408e:	2101      	movs	r1, #1
 8004090:	0020      	movs	r0, r4
 8004092:	f7ff fc55 	bl	8003940 <prvAddCurrentTaskToDelayedList>
}
 8004096:	bd10      	pop	{r4, pc}
 8004098:	20000bd4 	.word	0x20000bd4

0800409c <vTaskPlaceOnEventListRestricted>:
    {
 800409c:	0003      	movs	r3, r0
 800409e:	b570      	push	{r4, r5, r6, lr}
 80040a0:	0008      	movs	r0, r1
 80040a2:	0011      	movs	r1, r2
        configASSERT( pxEventList );
 80040a4:	2b00      	cmp	r3, #0
 80040a6:	d101      	bne.n	80040ac <vTaskPlaceOnEventListRestricted+0x10>
 80040a8:	b672      	cpsid	i
 80040aa:	e7fe      	b.n	80040aa <vTaskPlaceOnEventListRestricted+0xe>
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80040ac:	4c0c      	ldr	r4, [pc, #48]	@ (80040e0 <vTaskPlaceOnEventListRestricted+0x44>)
 80040ae:	685a      	ldr	r2, [r3, #4]
 80040b0:	6825      	ldr	r5, [r4, #0]
 80040b2:	6896      	ldr	r6, [r2, #8]
 80040b4:	61ea      	str	r2, [r5, #28]
 80040b6:	6825      	ldr	r5, [r4, #0]
 80040b8:	622e      	str	r6, [r5, #32]
 80040ba:	6825      	ldr	r5, [r4, #0]
 80040bc:	3518      	adds	r5, #24
 80040be:	6075      	str	r5, [r6, #4]
 80040c0:	6825      	ldr	r5, [r4, #0]
 80040c2:	3518      	adds	r5, #24
 80040c4:	6095      	str	r5, [r2, #8]
 80040c6:	6822      	ldr	r2, [r4, #0]
 80040c8:	6293      	str	r3, [r2, #40]	@ 0x28
 80040ca:	681a      	ldr	r2, [r3, #0]
 80040cc:	3201      	adds	r2, #1
 80040ce:	601a      	str	r2, [r3, #0]
        if( xWaitIndefinitely != pdFALSE )
 80040d0:	2900      	cmp	r1, #0
 80040d2:	d001      	beq.n	80040d8 <vTaskPlaceOnEventListRestricted+0x3c>
            xTicksToWait = portMAX_DELAY;
 80040d4:	2001      	movs	r0, #1
 80040d6:	4240      	negs	r0, r0
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80040d8:	f7ff fc32 	bl	8003940 <prvAddCurrentTaskToDelayedList>
    }
 80040dc:	bd70      	pop	{r4, r5, r6, pc}
 80040de:	46c0      	nop			@ (mov r8, r8)
 80040e0:	20000bd4 	.word	0x20000bd4

080040e4 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80040e4:	68c3      	ldr	r3, [r0, #12]
{
 80040e6:	b5f0      	push	{r4, r5, r6, r7, lr}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80040e8:	68db      	ldr	r3, [r3, #12]
    configASSERT( pxUnblockedTCB );
 80040ea:	2b00      	cmp	r3, #0
 80040ec:	d101      	bne.n	80040f2 <xTaskRemoveFromEventList+0xe>
 80040ee:	b672      	cpsid	i
 80040f0:	e7fe      	b.n	80040f0 <xTaskRemoveFromEventList+0xc>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 80040f2:	69d8      	ldr	r0, [r3, #28]
 80040f4:	6a19      	ldr	r1, [r3, #32]
 80040f6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80040f8:	6081      	str	r1, [r0, #8]
 80040fa:	6048      	str	r0, [r1, #4]
 80040fc:	0018      	movs	r0, r3
 80040fe:	6854      	ldr	r4, [r2, #4]
 8004100:	3018      	adds	r0, #24
 8004102:	4284      	cmp	r4, r0
 8004104:	d100      	bne.n	8004108 <xTaskRemoveFromEventList+0x24>
 8004106:	6051      	str	r1, [r2, #4]
 8004108:	2100      	movs	r1, #0
 800410a:	6299      	str	r1, [r3, #40]	@ 0x28
 800410c:	6811      	ldr	r1, [r2, #0]
 800410e:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 8004110:	3901      	subs	r1, #1
 8004112:	6011      	str	r1, [r2, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8004114:	4a1c      	ldr	r2, [pc, #112]	@ (8004188 <xTaskRemoveFromEventList+0xa4>)
 8004116:	6812      	ldr	r2, [r2, #0]
 8004118:	2a00      	cmp	r2, #0
 800411a:	d129      	bne.n	8004170 <xTaskRemoveFromEventList+0x8c>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 800411c:	695a      	ldr	r2, [r3, #20]
 800411e:	6898      	ldr	r0, [r3, #8]
 8004120:	68d9      	ldr	r1, [r3, #12]
 8004122:	1d1d      	adds	r5, r3, #4
 8004124:	6081      	str	r1, [r0, #8]
 8004126:	6048      	str	r0, [r1, #4]
 8004128:	6850      	ldr	r0, [r2, #4]
 800412a:	42a8      	cmp	r0, r5
 800412c:	d100      	bne.n	8004130 <xTaskRemoveFromEventList+0x4c>
 800412e:	6051      	str	r1, [r2, #4]
 8004130:	6811      	ldr	r1, [r2, #0]
 8004132:	3901      	subs	r1, #1
 8004134:	6011      	str	r1, [r2, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
 8004136:	4a15      	ldr	r2, [pc, #84]	@ (800418c <xTaskRemoveFromEventList+0xa8>)
 8004138:	6811      	ldr	r1, [r2, #0]
 800413a:	428c      	cmp	r4, r1
 800413c:	d900      	bls.n	8004140 <xTaskRemoveFromEventList+0x5c>
 800413e:	6014      	str	r4, [r2, #0]
 8004140:	2114      	movs	r1, #20
 8004142:	4361      	muls	r1, r4
 8004144:	4a12      	ldr	r2, [pc, #72]	@ (8004190 <xTaskRemoveFromEventList+0xac>)
 8004146:	1856      	adds	r6, r2, r1
 8004148:	6870      	ldr	r0, [r6, #4]
 800414a:	6887      	ldr	r7, [r0, #8]
 800414c:	6098      	str	r0, [r3, #8]
 800414e:	60df      	str	r7, [r3, #12]
 8004150:	607d      	str	r5, [r7, #4]
 8004152:	6085      	str	r5, [r0, #8]
 8004154:	615e      	str	r6, [r3, #20]
 8004156:	588b      	ldr	r3, [r1, r2]
 8004158:	3301      	adds	r3, #1
 800415a:	508b      	str	r3, [r1, r2]
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800415c:	4b0d      	ldr	r3, [pc, #52]	@ (8004194 <xTaskRemoveFromEventList+0xb0>)
        xReturn = pdFALSE;
 800415e:	2000      	movs	r0, #0
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004160:	681b      	ldr	r3, [r3, #0]
 8004162:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004164:	429c      	cmp	r4, r3
 8004166:	d902      	bls.n	800416e <xTaskRemoveFromEventList+0x8a>
        xYieldPending = pdTRUE;
 8004168:	4b0b      	ldr	r3, [pc, #44]	@ (8004198 <xTaskRemoveFromEventList+0xb4>)
 800416a:	3001      	adds	r0, #1
 800416c:	6018      	str	r0, [r3, #0]
}
 800416e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004170:	4a0a      	ldr	r2, [pc, #40]	@ (800419c <xTaskRemoveFromEventList+0xb8>)
 8004172:	6851      	ldr	r1, [r2, #4]
 8004174:	688d      	ldr	r5, [r1, #8]
 8004176:	61d9      	str	r1, [r3, #28]
 8004178:	621d      	str	r5, [r3, #32]
 800417a:	6068      	str	r0, [r5, #4]
 800417c:	6088      	str	r0, [r1, #8]
 800417e:	629a      	str	r2, [r3, #40]	@ 0x28
 8004180:	6813      	ldr	r3, [r2, #0]
 8004182:	3301      	adds	r3, #1
 8004184:	6013      	str	r3, [r2, #0]
 8004186:	e7e9      	b.n	800415c <xTaskRemoveFromEventList+0x78>
 8004188:	200006dc 	.word	0x200006dc
 800418c:	200006f8 	.word	0x200006f8
 8004190:	20000774 	.word	0x20000774
 8004194:	20000bd4 	.word	0x20000bd4
 8004198:	200006ec 	.word	0x200006ec
 800419c:	20000730 	.word	0x20000730

080041a0 <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 80041a0:	4b03      	ldr	r3, [pc, #12]	@ (80041b0 <vTaskInternalSetTimeOutState+0x10>)
 80041a2:	681b      	ldr	r3, [r3, #0]
 80041a4:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 80041a6:	4b03      	ldr	r3, [pc, #12]	@ (80041b4 <vTaskInternalSetTimeOutState+0x14>)
 80041a8:	681b      	ldr	r3, [r3, #0]
 80041aa:	6043      	str	r3, [r0, #4]
}
 80041ac:	4770      	bx	lr
 80041ae:	46c0      	nop			@ (mov r8, r8)
 80041b0:	200006e8 	.word	0x200006e8
 80041b4:	200006fc 	.word	0x200006fc

080041b8 <xTaskCheckForTimeOut>:
{
 80041b8:	b570      	push	{r4, r5, r6, lr}
 80041ba:	0004      	movs	r4, r0
 80041bc:	000d      	movs	r5, r1
    configASSERT( pxTimeOut );
 80041be:	2800      	cmp	r0, #0
 80041c0:	d101      	bne.n	80041c6 <xTaskCheckForTimeOut+0xe>
 80041c2:	b672      	cpsid	i
 80041c4:	e7fe      	b.n	80041c4 <xTaskCheckForTimeOut+0xc>
    configASSERT( pxTicksToWait );
 80041c6:	2900      	cmp	r1, #0
 80041c8:	d101      	bne.n	80041ce <xTaskCheckForTimeOut+0x16>
 80041ca:	b672      	cpsid	i
 80041cc:	e7fe      	b.n	80041cc <xTaskCheckForTimeOut+0x14>
    taskENTER_CRITICAL();
 80041ce:	f000 fa37 	bl	8004640 <vPortEnterCritical>
        const TickType_t xConstTickCount = xTickCount;
 80041d2:	4b0f      	ldr	r3, [pc, #60]	@ (8004210 <xTaskCheckForTimeOut+0x58>)
 80041d4:	6819      	ldr	r1, [r3, #0]
            if( *pxTicksToWait == portMAX_DELAY )
 80041d6:	682b      	ldr	r3, [r5, #0]
 80041d8:	1c5a      	adds	r2, r3, #1
 80041da:	d017      	beq.n	800420c <xTaskCheckForTimeOut+0x54>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80041dc:	480d      	ldr	r0, [pc, #52]	@ (8004214 <xTaskCheckForTimeOut+0x5c>)
 80041de:	6826      	ldr	r6, [r4, #0]
 80041e0:	6800      	ldr	r0, [r0, #0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80041e2:	6862      	ldr	r2, [r4, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80041e4:	4286      	cmp	r6, r0
 80041e6:	d008      	beq.n	80041fa <xTaskCheckForTimeOut+0x42>
 80041e8:	428a      	cmp	r2, r1
 80041ea:	d806      	bhi.n	80041fa <xTaskCheckForTimeOut+0x42>
            *pxTicksToWait = ( TickType_t ) 0;
 80041ec:	2300      	movs	r3, #0
            xReturn = pdTRUE;
 80041ee:	2401      	movs	r4, #1
            *pxTicksToWait = ( TickType_t ) 0;
 80041f0:	602b      	str	r3, [r5, #0]
    taskEXIT_CRITICAL();
 80041f2:	f000 fa31 	bl	8004658 <vPortExitCritical>
}
 80041f6:	0020      	movs	r0, r4
 80041f8:	bd70      	pop	{r4, r5, r6, pc}
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80041fa:	1a88      	subs	r0, r1, r2
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80041fc:	4283      	cmp	r3, r0
 80041fe:	d9f5      	bls.n	80041ec <xTaskCheckForTimeOut+0x34>
            *pxTicksToWait -= xElapsedTime;
 8004200:	1a5b      	subs	r3, r3, r1
 8004202:	189b      	adds	r3, r3, r2
            vTaskInternalSetTimeOutState( pxTimeOut );
 8004204:	0020      	movs	r0, r4
            *pxTicksToWait -= xElapsedTime;
 8004206:	602b      	str	r3, [r5, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
 8004208:	f7ff ffca 	bl	80041a0 <vTaskInternalSetTimeOutState>
                xReturn = pdFALSE;
 800420c:	2400      	movs	r4, #0
 800420e:	e7f0      	b.n	80041f2 <xTaskCheckForTimeOut+0x3a>
 8004210:	200006fc 	.word	0x200006fc
 8004214:	200006e8 	.word	0x200006e8

08004218 <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 8004218:	2201      	movs	r2, #1
 800421a:	4b01      	ldr	r3, [pc, #4]	@ (8004220 <vTaskMissedYield+0x8>)
 800421c:	601a      	str	r2, [r3, #0]
}
 800421e:	4770      	bx	lr
 8004220:	200006ec 	.word	0x200006ec

08004224 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 8004224:	4b05      	ldr	r3, [pc, #20]	@ (800423c <xTaskGetSchedulerState+0x18>)
            xReturn = taskSCHEDULER_NOT_STARTED;
 8004226:	2001      	movs	r0, #1
        if( xSchedulerRunning == pdFALSE )
 8004228:	681b      	ldr	r3, [r3, #0]
 800422a:	2b00      	cmp	r3, #0
 800422c:	d004      	beq.n	8004238 <xTaskGetSchedulerState+0x14>
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 800422e:	4b04      	ldr	r3, [pc, #16]	@ (8004240 <xTaskGetSchedulerState+0x1c>)
 8004230:	6818      	ldr	r0, [r3, #0]
 8004232:	4243      	negs	r3, r0
 8004234:	4158      	adcs	r0, r3
 8004236:	0040      	lsls	r0, r0, #1
    }
 8004238:	4770      	bx	lr
 800423a:	46c0      	nop			@ (mov r8, r8)
 800423c:	200006f4 	.word	0x200006f4
 8004240:	200006dc 	.word	0x200006dc

08004244 <xTaskPriorityDisinherit>:
    {
 8004244:	b570      	push	{r4, r5, r6, lr}
 8004246:	1e04      	subs	r4, r0, #0
        if( pxMutexHolder != NULL )
 8004248:	d101      	bne.n	800424e <xTaskPriorityDisinherit+0xa>
        BaseType_t xReturn = pdFALSE;
 800424a:	2000      	movs	r0, #0
    }
 800424c:	bd70      	pop	{r4, r5, r6, pc}
            configASSERT( pxTCB == pxCurrentTCB );
 800424e:	4b18      	ldr	r3, [pc, #96]	@ (80042b0 <xTaskPriorityDisinherit+0x6c>)
 8004250:	681b      	ldr	r3, [r3, #0]
 8004252:	4283      	cmp	r3, r0
 8004254:	d001      	beq.n	800425a <xTaskPriorityDisinherit+0x16>
 8004256:	b672      	cpsid	i
 8004258:	e7fe      	b.n	8004258 <xTaskPriorityDisinherit+0x14>
            configASSERT( pxTCB->uxMutexesHeld );
 800425a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800425c:	2b00      	cmp	r3, #0
 800425e:	d101      	bne.n	8004264 <xTaskPriorityDisinherit+0x20>
 8004260:	b672      	cpsid	i
 8004262:	e7fe      	b.n	8004262 <xTaskPriorityDisinherit+0x1e>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8004264:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8004266:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
            ( pxTCB->uxMutexesHeld )--;
 8004268:	3b01      	subs	r3, #1
 800426a:	6503      	str	r3, [r0, #80]	@ 0x50
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800426c:	4291      	cmp	r1, r2
 800426e:	d0ec      	beq.n	800424a <xTaskPriorityDisinherit+0x6>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8004270:	2b00      	cmp	r3, #0
 8004272:	d1ea      	bne.n	800424a <xTaskPriorityDisinherit+0x6>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004274:	1d05      	adds	r5, r0, #4
 8004276:	0028      	movs	r0, r5
 8004278:	f7fe ff90 	bl	800319c <uxListRemove>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800427c:	2338      	movs	r3, #56	@ 0x38
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 800427e:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004280:	1a5b      	subs	r3, r3, r1
 8004282:	61a3      	str	r3, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
 8004284:	4b0b      	ldr	r3, [pc, #44]	@ (80042b4 <xTaskPriorityDisinherit+0x70>)
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8004286:	62e1      	str	r1, [r4, #44]	@ 0x2c
                    prvAddTaskToReadyList( pxTCB );
 8004288:	681a      	ldr	r2, [r3, #0]
 800428a:	4291      	cmp	r1, r2
 800428c:	d900      	bls.n	8004290 <xTaskPriorityDisinherit+0x4c>
 800428e:	6019      	str	r1, [r3, #0]
 8004290:	2214      	movs	r2, #20
 8004292:	434a      	muls	r2, r1
 8004294:	4b08      	ldr	r3, [pc, #32]	@ (80042b8 <xTaskPriorityDisinherit+0x74>)
 8004296:	1898      	adds	r0, r3, r2
 8004298:	6841      	ldr	r1, [r0, #4]
 800429a:	688e      	ldr	r6, [r1, #8]
 800429c:	60a1      	str	r1, [r4, #8]
 800429e:	60e6      	str	r6, [r4, #12]
 80042a0:	6075      	str	r5, [r6, #4]
 80042a2:	608d      	str	r5, [r1, #8]
 80042a4:	58d1      	ldr	r1, [r2, r3]
 80042a6:	6160      	str	r0, [r4, #20]
 80042a8:	3101      	adds	r1, #1
                    xReturn = pdTRUE;
 80042aa:	2001      	movs	r0, #1
                    prvAddTaskToReadyList( pxTCB );
 80042ac:	50d1      	str	r1, [r2, r3]
        return xReturn;
 80042ae:	e7cd      	b.n	800424c <xTaskPriorityDisinherit+0x8>
 80042b0:	20000bd4 	.word	0x20000bd4
 80042b4:	200006f8 	.word	0x200006f8
 80042b8:	20000774 	.word	0x20000774

080042bc <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
 80042bc:	b510      	push	{r4, lr}
 80042be:	0004      	movs	r4, r0
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 80042c0:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80042c2:	6100      	str	r0, [r0, #16]

        if( xNextExpiryTime <= xTimeNow )
 80042c4:	4291      	cmp	r1, r2
 80042c6:	d80b      	bhi.n	80042e0 <prvInsertTimerInActiveList+0x24>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80042c8:	1ad2      	subs	r2, r2, r3
 80042ca:	6983      	ldr	r3, [r0, #24]
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
 80042cc:	2001      	movs	r0, #1
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80042ce:	429a      	cmp	r2, r3
 80042d0:	d205      	bcs.n	80042de <prvInsertTimerInActiveList+0x22>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80042d2:	4b07      	ldr	r3, [pc, #28]	@ (80042f0 <prvInsertTimerInActiveList+0x34>)
 80042d4:	1d21      	adds	r1, r4, #4
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80042d6:	6818      	ldr	r0, [r3, #0]
 80042d8:	f7fe ff49 	bl	800316e <vListInsert>
        BaseType_t xProcessTimerNow = pdFALSE;
 80042dc:	2000      	movs	r0, #0
            }
        }

        return xProcessTimerNow;
    }
 80042de:	bd10      	pop	{r4, pc}
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80042e0:	429a      	cmp	r2, r3
 80042e2:	d202      	bcs.n	80042ea <prvInsertTimerInActiveList+0x2e>
                xProcessTimerNow = pdTRUE;
 80042e4:	2001      	movs	r0, #1
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80042e6:	4299      	cmp	r1, r3
 80042e8:	d2f9      	bcs.n	80042de <prvInsertTimerInActiveList+0x22>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80042ea:	4b02      	ldr	r3, [pc, #8]	@ (80042f4 <prvInsertTimerInActiveList+0x38>)
 80042ec:	1d21      	adds	r1, r4, #4
 80042ee:	e7f2      	b.n	80042d6 <prvInsertTimerInActiveList+0x1a>
 80042f0:	20000cd4 	.word	0x20000cd4
 80042f4:	20000cd8 	.word	0x20000cd8

080042f8 <prvReloadTimer>:
    {
 80042f8:	b570      	push	{r4, r5, r6, lr}
 80042fa:	0004      	movs	r4, r0
 80042fc:	000d      	movs	r5, r1
 80042fe:	0016      	movs	r6, r2
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004300:	69a1      	ldr	r1, [r4, #24]
 8004302:	002b      	movs	r3, r5
 8004304:	0032      	movs	r2, r6
 8004306:	0020      	movs	r0, r4
 8004308:	1869      	adds	r1, r5, r1
 800430a:	f7ff ffd7 	bl	80042bc <prvInsertTimerInActiveList>
 800430e:	2800      	cmp	r0, #0
 8004310:	d100      	bne.n	8004314 <prvReloadTimer+0x1c>
    }
 8004312:	bd70      	pop	{r4, r5, r6, pc}
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
 8004314:	69a3      	ldr	r3, [r4, #24]
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004316:	0020      	movs	r0, r4
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
 8004318:	18ed      	adds	r5, r5, r3
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800431a:	6a23      	ldr	r3, [r4, #32]
 800431c:	4798      	blx	r3
 800431e:	e7ef      	b.n	8004300 <prvReloadTimer+0x8>

08004320 <prvProcessExpiredTimer>:
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004320:	4b0d      	ldr	r3, [pc, #52]	@ (8004358 <prvProcessExpiredTimer+0x38>)
    {
 8004322:	b570      	push	{r4, r5, r6, lr}
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004324:	681b      	ldr	r3, [r3, #0]
    {
 8004326:	0005      	movs	r5, r0
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004328:	68db      	ldr	r3, [r3, #12]
    {
 800432a:	000e      	movs	r6, r1
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800432c:	68dc      	ldr	r4, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800432e:	1d20      	adds	r0, r4, #4
 8004330:	f7fe ff34 	bl	800319c <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004334:	0022      	movs	r2, r4
 8004336:	3228      	adds	r2, #40	@ 0x28
 8004338:	7813      	ldrb	r3, [r2, #0]
 800433a:	0759      	lsls	r1, r3, #29
 800433c:	d508      	bpl.n	8004350 <prvProcessExpiredTimer+0x30>
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
 800433e:	0032      	movs	r2, r6
 8004340:	0029      	movs	r1, r5
 8004342:	0020      	movs	r0, r4
 8004344:	f7ff ffd8 	bl	80042f8 <prvReloadTimer>
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004348:	0020      	movs	r0, r4
 800434a:	6a23      	ldr	r3, [r4, #32]
 800434c:	4798      	blx	r3
    }
 800434e:	bd70      	pop	{r4, r5, r6, pc}
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004350:	2101      	movs	r1, #1
 8004352:	438b      	bics	r3, r1
 8004354:	7013      	strb	r3, [r2, #0]
 8004356:	e7f7      	b.n	8004348 <prvProcessExpiredTimer+0x28>
 8004358:	20000cd8 	.word	0x20000cd8

0800435c <prvSampleTimeNow>:
    {
 800435c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800435e:	0005      	movs	r5, r0
        xTimeNow = xTaskGetTickCount();
 8004360:	f7ff fca8 	bl	8003cb4 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 8004364:	4e0e      	ldr	r6, [pc, #56]	@ (80043a0 <prvSampleTimeNow+0x44>)
        xTimeNow = xTaskGetTickCount();
 8004366:	0004      	movs	r4, r0
        if( xTimeNow < xLastTime )
 8004368:	6833      	ldr	r3, [r6, #0]
 800436a:	4283      	cmp	r3, r0
 800436c:	d90c      	bls.n	8004388 <prvSampleTimeNow+0x2c>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 800436e:	2701      	movs	r7, #1
 8004370:	427f      	negs	r7, r7
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8004372:	490c      	ldr	r1, [pc, #48]	@ (80043a4 <prvSampleTimeNow+0x48>)
 8004374:	680b      	ldr	r3, [r1, #0]
 8004376:	681a      	ldr	r2, [r3, #0]
 8004378:	2a00      	cmp	r2, #0
 800437a:	d10a      	bne.n	8004392 <prvSampleTimeNow+0x36>
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
 800437c:	4a0a      	ldr	r2, [pc, #40]	@ (80043a8 <prvSampleTimeNow+0x4c>)
 800437e:	6810      	ldr	r0, [r2, #0]
        pxOverflowTimerList = pxTemp;
 8004380:	6013      	str	r3, [r2, #0]
        pxCurrentTimerList = pxOverflowTimerList;
 8004382:	6008      	str	r0, [r1, #0]
            *pxTimerListsWereSwitched = pdTRUE;
 8004384:	2301      	movs	r3, #1
 8004386:	e000      	b.n	800438a <prvSampleTimeNow+0x2e>
 8004388:	2300      	movs	r3, #0
    }
 800438a:	0020      	movs	r0, r4
            *pxTimerListsWereSwitched = pdTRUE;
 800438c:	602b      	str	r3, [r5, #0]
        xLastTime = xTimeNow;
 800438e:	6034      	str	r4, [r6, #0]
    }
 8004390:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004392:	68db      	ldr	r3, [r3, #12]
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 8004394:	0039      	movs	r1, r7
 8004396:	6818      	ldr	r0, [r3, #0]
 8004398:	f7ff ffc2 	bl	8004320 <prvProcessExpiredTimer>
 800439c:	e7e9      	b.n	8004372 <prvSampleTimeNow+0x16>
 800439e:	46c0      	nop			@ (mov r8, r8)
 80043a0:	20000cc8 	.word	0x20000cc8
 80043a4:	20000cd8 	.word	0x20000cd8
 80043a8:	20000cd4 	.word	0x20000cd4

080043ac <prvTimerTask>:
    {
 80043ac:	b5f0      	push	{r4, r5, r6, r7, lr}
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80043ae:	2701      	movs	r7, #1
    {
 80043b0:	b087      	sub	sp, #28
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80043b2:	4b49      	ldr	r3, [pc, #292]	@ (80044d8 <prvTimerTask+0x12c>)
 80043b4:	003d      	movs	r5, r7
 80043b6:	681b      	ldr	r3, [r3, #0]
 80043b8:	681c      	ldr	r4, [r3, #0]
 80043ba:	2c00      	cmp	r4, #0
 80043bc:	d002      	beq.n	80043c4 <prvTimerTask+0x18>
 80043be:	2500      	movs	r5, #0
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80043c0:	68db      	ldr	r3, [r3, #12]
 80043c2:	681c      	ldr	r4, [r3, #0]
        vTaskSuspendAll();
 80043c4:	f7ff fc6e 	bl	8003ca4 <vTaskSuspendAll>
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80043c8:	a802      	add	r0, sp, #8
 80043ca:	f7ff ffc7 	bl	800435c <prvSampleTimeNow>
            if( xTimerListsWereSwitched == pdFALSE )
 80043ce:	9b02      	ldr	r3, [sp, #8]
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80043d0:	0006      	movs	r6, r0
            if( xTimerListsWereSwitched == pdFALSE )
 80043d2:	2b00      	cmp	r3, #0
 80043d4:	d13d      	bne.n	8004452 <prvTimerTask+0xa6>
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80043d6:	2d00      	cmp	r5, #0
 80043d8:	d129      	bne.n	800442e <prvTimerTask+0x82>
 80043da:	42a0      	cmp	r0, r4
 80043dc:	d32c      	bcc.n	8004438 <prvTimerTask+0x8c>
                    ( void ) xTaskResumeAll();
 80043de:	f7ff fd27 	bl	8003e30 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 80043e2:	0031      	movs	r1, r6
 80043e4:	0020      	movs	r0, r4
 80043e6:	f7ff ff9b 	bl	8004320 <prvProcessExpiredTimer>
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80043ea:	4b3c      	ldr	r3, [pc, #240]	@ (80044dc <prvTimerTask+0x130>)
 80043ec:	2200      	movs	r2, #0
 80043ee:	6818      	ldr	r0, [r3, #0]
 80043f0:	a902      	add	r1, sp, #8
 80043f2:	f7ff f905 	bl	8003600 <xQueueReceive>
 80043f6:	2800      	cmp	r0, #0
 80043f8:	d0db      	beq.n	80043b2 <prvTimerTask+0x6>
                if( xMessage.xMessageID < ( BaseType_t ) 0 )
 80043fa:	9b02      	ldr	r3, [sp, #8]
                    pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 80043fc:	9804      	ldr	r0, [sp, #16]
                if( xMessage.xMessageID < ( BaseType_t ) 0 )
 80043fe:	2b00      	cmp	r3, #0
 8004400:	db2a      	blt.n	8004458 <prvTimerTask+0xac>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8004402:	9c04      	ldr	r4, [sp, #16]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8004404:	6963      	ldr	r3, [r4, #20]
 8004406:	2b00      	cmp	r3, #0
 8004408:	d12d      	bne.n	8004466 <prvTimerTask+0xba>
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800440a:	a801      	add	r0, sp, #4
 800440c:	f7ff ffa6 	bl	800435c <prvSampleTimeNow>
 8004410:	0006      	movs	r6, r0
                switch( xMessage.xMessageID )
 8004412:	9802      	ldr	r0, [sp, #8]
 8004414:	3801      	subs	r0, #1
 8004416:	2808      	cmp	r0, #8
 8004418:	d8e7      	bhi.n	80043ea <prvTimerTask+0x3e>
 800441a:	0025      	movs	r5, r4
 800441c:	3528      	adds	r5, #40	@ 0x28
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800441e:	782b      	ldrb	r3, [r5, #0]
                switch( xMessage.xMessageID )
 8004420:	f7fb fe7a 	bl	8000118 <__gnu_thumb1_case_uqi>
 8004424:	41572525 	.word	0x41572525
 8004428:	57252550 	.word	0x57252550
 800442c:	41          	.byte	0x41
 800442d:	00          	.byte	0x00
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800442e:	4b2c      	ldr	r3, [pc, #176]	@ (80044e0 <prvTimerTask+0x134>)
 8004430:	681b      	ldr	r3, [r3, #0]
 8004432:	681d      	ldr	r5, [r3, #0]
 8004434:	426b      	negs	r3, r5
 8004436:	415d      	adcs	r5, r3
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8004438:	4b28      	ldr	r3, [pc, #160]	@ (80044dc <prvTimerTask+0x130>)
 800443a:	002a      	movs	r2, r5
 800443c:	6818      	ldr	r0, [r3, #0]
 800443e:	1ba1      	subs	r1, r4, r6
 8004440:	f7ff f9dc 	bl	80037fc <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 8004444:	f7ff fcf4 	bl	8003e30 <xTaskResumeAll>
 8004448:	2800      	cmp	r0, #0
 800444a:	d1ce      	bne.n	80043ea <prvTimerTask+0x3e>
                        portYIELD_WITHIN_API();
 800444c:	f000 f8ec 	bl	8004628 <vPortYield>
 8004450:	e7cb      	b.n	80043ea <prvTimerTask+0x3e>
                ( void ) xTaskResumeAll();
 8004452:	f7ff fced 	bl	8003e30 <xTaskResumeAll>
    }
 8004456:	e7c8      	b.n	80043ea <prvTimerTask+0x3e>
                    pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 8004458:	9b03      	ldr	r3, [sp, #12]
 800445a:	9905      	ldr	r1, [sp, #20]
 800445c:	4798      	blx	r3
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800445e:	9b02      	ldr	r3, [sp, #8]
 8004460:	2b00      	cmp	r3, #0
 8004462:	dbc2      	blt.n	80043ea <prvTimerTask+0x3e>
 8004464:	e7cd      	b.n	8004402 <prvTimerTask+0x56>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004466:	1d20      	adds	r0, r4, #4
 8004468:	f7fe fe98 	bl	800319c <uxListRemove>
 800446c:	e7cd      	b.n	800440a <prvTimerTask+0x5e>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800446e:	433b      	orrs	r3, r7
 8004470:	702b      	strb	r3, [r5, #0]
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8004472:	9b03      	ldr	r3, [sp, #12]
 8004474:	69a1      	ldr	r1, [r4, #24]
 8004476:	0032      	movs	r2, r6
 8004478:	0020      	movs	r0, r4
 800447a:	1859      	adds	r1, r3, r1
 800447c:	f7ff ff1e 	bl	80042bc <prvInsertTimerInActiveList>
 8004480:	2800      	cmp	r0, #0
 8004482:	d0b2      	beq.n	80043ea <prvTimerTask+0x3e>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004484:	782b      	ldrb	r3, [r5, #0]
 8004486:	075a      	lsls	r2, r3, #29
 8004488:	d50a      	bpl.n	80044a0 <prvTimerTask+0xf4>
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
 800448a:	9903      	ldr	r1, [sp, #12]
 800448c:	69a3      	ldr	r3, [r4, #24]
 800448e:	0032      	movs	r2, r6
 8004490:	0020      	movs	r0, r4
 8004492:	18c9      	adds	r1, r1, r3
 8004494:	f7ff ff30 	bl	80042f8 <prvReloadTimer>
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004498:	0020      	movs	r0, r4
 800449a:	6a23      	ldr	r3, [r4, #32]
 800449c:	4798      	blx	r3
 800449e:	e7a4      	b.n	80043ea <prvTimerTask+0x3e>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 80044a0:	43bb      	bics	r3, r7
 80044a2:	702b      	strb	r3, [r5, #0]
 80044a4:	e7f8      	b.n	8004498 <prvTimerTask+0xec>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80044a6:	433b      	orrs	r3, r7
 80044a8:	702b      	strb	r3, [r5, #0]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80044aa:	9903      	ldr	r1, [sp, #12]
 80044ac:	61a1      	str	r1, [r4, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80044ae:	2900      	cmp	r1, #0
 80044b0:	d101      	bne.n	80044b6 <prvTimerTask+0x10a>
 80044b2:	b672      	cpsid	i
 80044b4:	e7fe      	b.n	80044b4 <prvTimerTask+0x108>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80044b6:	0033      	movs	r3, r6
 80044b8:	0032      	movs	r2, r6
 80044ba:	0020      	movs	r0, r4
 80044bc:	1871      	adds	r1, r6, r1
 80044be:	f7ff fefd 	bl	80042bc <prvInsertTimerInActiveList>
                        break;
 80044c2:	e792      	b.n	80043ea <prvTimerTask+0x3e>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 80044c4:	2202      	movs	r2, #2
 80044c6:	4213      	tst	r3, r2
 80044c8:	d103      	bne.n	80044d2 <prvTimerTask+0x126>
                                vPortFree( pxTimer );
 80044ca:	0020      	movs	r0, r4
 80044cc:	f000 f97c 	bl	80047c8 <vPortFree>
 80044d0:	e78b      	b.n	80043ea <prvTimerTask+0x3e>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 80044d2:	43bb      	bics	r3, r7
 80044d4:	702b      	strb	r3, [r5, #0]
 80044d6:	e788      	b.n	80043ea <prvTimerTask+0x3e>
 80044d8:	20000cd8 	.word	0x20000cd8
 80044dc:	20000cd0 	.word	0x20000cd0
 80044e0:	20000cd4 	.word	0x20000cd4

080044e4 <prvCheckForValidListAndQueue>:
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 80044e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 80044e6:	f000 f8ab 	bl	8004640 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 80044ea:	4c10      	ldr	r4, [pc, #64]	@ (800452c <prvCheckForValidListAndQueue+0x48>)
 80044ec:	6825      	ldr	r5, [r4, #0]
 80044ee:	2d00      	cmp	r5, #0
 80044f0:	d118      	bne.n	8004524 <prvCheckForValidListAndQueue+0x40>
            {
                vListInitialise( &xActiveTimerList1 );
 80044f2:	4f0f      	ldr	r7, [pc, #60]	@ (8004530 <prvCheckForValidListAndQueue+0x4c>)
 80044f4:	0038      	movs	r0, r7
 80044f6:	f7fe fe21 	bl	800313c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 80044fa:	4e0e      	ldr	r6, [pc, #56]	@ (8004534 <prvCheckForValidListAndQueue+0x50>)
 80044fc:	0030      	movs	r0, r6
 80044fe:	f7fe fe1d 	bl	800313c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 8004502:	4b0d      	ldr	r3, [pc, #52]	@ (8004538 <prvCheckForValidListAndQueue+0x54>)
                    /* The timer queue is allocated statically in case
                     * configSUPPORT_DYNAMIC_ALLOCATION is 0. */
                    PRIVILEGED_DATA static StaticQueue_t xStaticTimerQueue;                                                                          /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
                    PRIVILEGED_DATA static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8004504:	2110      	movs	r1, #16
                pxCurrentTimerList = &xActiveTimerList1;
 8004506:	601f      	str	r7, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 8004508:	4b0c      	ldr	r3, [pc, #48]	@ (800453c <prvCheckForValidListAndQueue+0x58>)
                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800450a:	200a      	movs	r0, #10
                pxOverflowTimerList = &xActiveTimerList2;
 800450c:	601e      	str	r6, [r3, #0]
                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800450e:	4a0c      	ldr	r2, [pc, #48]	@ (8004540 <prvCheckForValidListAndQueue+0x5c>)
 8004510:	4b0c      	ldr	r3, [pc, #48]	@ (8004544 <prvCheckForValidListAndQueue+0x60>)
 8004512:	9500      	str	r5, [sp, #0]
 8004514:	f7fe ff2b 	bl	800336e <xQueueGenericCreateStatic>
 8004518:	6020      	str	r0, [r4, #0]
                }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                {
                    if( xTimerQueue != NULL )
 800451a:	2800      	cmp	r0, #0
 800451c:	d002      	beq.n	8004524 <prvCheckForValidListAndQueue+0x40>
                    {
                        vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800451e:	490a      	ldr	r1, [pc, #40]	@ (8004548 <prvCheckForValidListAndQueue+0x64>)
 8004520:	f7ff f94a 	bl	80037b8 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8004524:	f000 f898 	bl	8004658 <vPortExitCritical>
    }
 8004528:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800452a:	46c0      	nop			@ (mov r8, r8)
 800452c:	20000cd0 	.word	0x20000cd0
 8004530:	20000cf0 	.word	0x20000cf0
 8004534:	20000cdc 	.word	0x20000cdc
 8004538:	20000cd8 	.word	0x20000cd8
 800453c:	20000cd4 	.word	0x20000cd4
 8004540:	20000c28 	.word	0x20000c28
 8004544:	20000bd8 	.word	0x20000bd8
 8004548:	08004951 	.word	0x08004951

0800454c <xTimerCreateTimerTask>:
    {
 800454c:	b510      	push	{r4, lr}
 800454e:	b088      	sub	sp, #32
        prvCheckForValidListAndQueue();
 8004550:	f7ff ffc8 	bl	80044e4 <prvCheckForValidListAndQueue>
        if( xTimerQueue != NULL )
 8004554:	4b10      	ldr	r3, [pc, #64]	@ (8004598 <xTimerCreateTimerTask+0x4c>)
 8004556:	681b      	ldr	r3, [r3, #0]
 8004558:	2b00      	cmp	r3, #0
 800455a:	d017      	beq.n	800458c <xTimerCreateTimerTask+0x40>
                StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 800455c:	2400      	movs	r4, #0
                vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800455e:	aa07      	add	r2, sp, #28
 8004560:	a906      	add	r1, sp, #24
 8004562:	a805      	add	r0, sp, #20
                StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 8004564:	9405      	str	r4, [sp, #20]
                StackType_t * pxTimerTaskStackBuffer = NULL;
 8004566:	9406      	str	r4, [sp, #24]
                vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8004568:	f7fe fddc 	bl	8003124 <vApplicationGetTimerTaskMemory>
                xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 800456c:	9b05      	ldr	r3, [sp, #20]
 800456e:	490b      	ldr	r1, [pc, #44]	@ (800459c <xTimerCreateTimerTask+0x50>)
 8004570:	9302      	str	r3, [sp, #8]
 8004572:	9b06      	ldr	r3, [sp, #24]
 8004574:	480a      	ldr	r0, [pc, #40]	@ (80045a0 <xTimerCreateTimerTask+0x54>)
 8004576:	9301      	str	r3, [sp, #4]
 8004578:	2302      	movs	r3, #2
 800457a:	9a07      	ldr	r2, [sp, #28]
 800457c:	9300      	str	r3, [sp, #0]
 800457e:	0023      	movs	r3, r4
 8004580:	f7ff fab3 	bl	8003aea <xTaskCreateStatic>
 8004584:	4b07      	ldr	r3, [pc, #28]	@ (80045a4 <xTimerCreateTimerTask+0x58>)
 8004586:	6018      	str	r0, [r3, #0]
                if( xTimerTaskHandle != NULL )
 8004588:	42a0      	cmp	r0, r4
 800458a:	d101      	bne.n	8004590 <xTimerCreateTimerTask+0x44>
        configASSERT( xReturn );
 800458c:	b672      	cpsid	i
 800458e:	e7fe      	b.n	800458e <xTimerCreateTimerTask+0x42>
    }
 8004590:	2001      	movs	r0, #1
 8004592:	b008      	add	sp, #32
 8004594:	bd10      	pop	{r4, pc}
 8004596:	46c0      	nop			@ (mov r8, r8)
 8004598:	20000cd0 	.word	0x20000cd0
 800459c:	08004956 	.word	0x08004956
 80045a0:	080043ad 	.word	0x080043ad
 80045a4:	20000ccc 	.word	0x20000ccc

080045a8 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    volatile uint32_t ulDummy = 0UL;
 80045a8:	2300      	movs	r3, #0
{
 80045aa:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0UL;
 80045ac:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 80045ae:	4b06      	ldr	r3, [pc, #24]	@ (80045c8 <prvTaskExitError+0x20>)
 80045b0:	681b      	ldr	r3, [r3, #0]
 80045b2:	3301      	adds	r3, #1
 80045b4:	d001      	beq.n	80045ba <prvTaskExitError+0x12>
 80045b6:	b672      	cpsid	i
 80045b8:	e7fe      	b.n	80045b8 <prvTaskExitError+0x10>
    portDISABLE_INTERRUPTS();
 80045ba:	b672      	cpsid	i

    while( ulDummy == 0 )
 80045bc:	9b01      	ldr	r3, [sp, #4]
 80045be:	2b00      	cmp	r3, #0
 80045c0:	d0fc      	beq.n	80045bc <prvTaskExitError+0x14>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 80045c2:	b002      	add	sp, #8
 80045c4:	4770      	bx	lr
 80045c6:	46c0      	nop			@ (mov r8, r8)
 80045c8:	2000000c 	.word	0x2000000c
 80045cc:	00000000 	.word	0x00000000

080045d0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
 80045d0:	4a0b      	ldr	r2, [pc, #44]	@ (8004600 <pxCurrentTCBConst2>)
 80045d2:	6813      	ldr	r3, [r2, #0]
 80045d4:	6818      	ldr	r0, [r3, #0]
 80045d6:	3020      	adds	r0, #32
 80045d8:	f380 8809 	msr	PSP, r0
 80045dc:	2002      	movs	r0, #2
 80045de:	f380 8814 	msr	CONTROL, r0
 80045e2:	f3bf 8f6f 	isb	sy
 80045e6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 80045e8:	46ae      	mov	lr, r5
 80045ea:	bc08      	pop	{r3}
 80045ec:	bc04      	pop	{r2}
 80045ee:	b662      	cpsie	i
 80045f0:	4718      	bx	r3
 80045f2:	46c0      	nop			@ (mov r8, r8)
 80045f4:	46c0      	nop			@ (mov r8, r8)
 80045f6:	46c0      	nop			@ (mov r8, r8)
 80045f8:	46c0      	nop			@ (mov r8, r8)
 80045fa:	46c0      	nop			@ (mov r8, r8)
 80045fc:	46c0      	nop			@ (mov r8, r8)
 80045fe:	46c0      	nop			@ (mov r8, r8)

08004600 <pxCurrentTCBConst2>:
 8004600:	20000bd4 	.word	0x20000bd4

08004604 <pxPortInitialiseStack>:
{
 8004604:	b510      	push	{r4, lr}
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
 8004606:	2480      	movs	r4, #128	@ 0x80
 8004608:	1f03      	subs	r3, r0, #4
 800460a:	0464      	lsls	r4, r4, #17
 800460c:	601c      	str	r4, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
 800460e:	3b04      	subs	r3, #4
 8004610:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
 8004612:	4903      	ldr	r1, [pc, #12]	@ (8004620 <pxPortInitialiseStack+0x1c>)
 8004614:	3b04      	subs	r3, #4
 8004616:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 8004618:	3b14      	subs	r3, #20
    pxTopOfStack -= 8;                                       /* R11..R4. */
 800461a:	3840      	subs	r0, #64	@ 0x40
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 800461c:	601a      	str	r2, [r3, #0]
}
 800461e:	bd10      	pop	{r4, pc}
 8004620:	080045a9 	.word	0x080045a9

08004624 <SVC_Handler>:
}
 8004624:	4770      	bx	lr
	...

08004628 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8004628:	2280      	movs	r2, #128	@ 0x80
 800462a:	4b04      	ldr	r3, [pc, #16]	@ (800463c <vPortYield+0x14>)
 800462c:	0552      	lsls	r2, r2, #21
 800462e:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
 8004630:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 8004634:	f3bf 8f6f 	isb	sy
}
 8004638:	4770      	bx	lr
 800463a:	46c0      	nop			@ (mov r8, r8)
 800463c:	e000ed04 	.word	0xe000ed04

08004640 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 8004640:	b672      	cpsid	i
    uxCriticalNesting++;
 8004642:	4a04      	ldr	r2, [pc, #16]	@ (8004654 <vPortEnterCritical+0x14>)
 8004644:	6813      	ldr	r3, [r2, #0]
 8004646:	3301      	adds	r3, #1
 8004648:	6013      	str	r3, [r2, #0]
    __asm volatile ( "dsb" ::: "memory" );
 800464a:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 800464e:	f3bf 8f6f 	isb	sy
}
 8004652:	4770      	bx	lr
 8004654:	2000000c 	.word	0x2000000c

08004658 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
 8004658:	4a05      	ldr	r2, [pc, #20]	@ (8004670 <vPortExitCritical+0x18>)
 800465a:	6813      	ldr	r3, [r2, #0]
 800465c:	2b00      	cmp	r3, #0
 800465e:	d101      	bne.n	8004664 <vPortExitCritical+0xc>
 8004660:	b672      	cpsid	i
 8004662:	e7fe      	b.n	8004662 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 8004664:	3b01      	subs	r3, #1
 8004666:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
 8004668:	2b00      	cmp	r3, #0
 800466a:	d100      	bne.n	800466e <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800466c:	b662      	cpsie	i
    }
}
 800466e:	4770      	bx	lr
 8004670:	2000000c 	.word	0x2000000c

08004674 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
 8004674:	f3ef 8010 	mrs	r0, PRIMASK
 8004678:	b672      	cpsid	i
 800467a:	4770      	bx	lr

0800467c <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
 800467c:	f380 8810 	msr	PRIMASK, r0
 8004680:	4770      	bx	lr
	...

08004690 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
 8004690:	f3ef 8009 	mrs	r0, PSP
 8004694:	4b0e      	ldr	r3, [pc, #56]	@ (80046d0 <pxCurrentTCBConst>)
 8004696:	681a      	ldr	r2, [r3, #0]
 8004698:	3820      	subs	r0, #32
 800469a:	6010      	str	r0, [r2, #0]
 800469c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800469e:	4644      	mov	r4, r8
 80046a0:	464d      	mov	r5, r9
 80046a2:	4656      	mov	r6, sl
 80046a4:	465f      	mov	r7, fp
 80046a6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 80046a8:	b508      	push	{r3, lr}
 80046aa:	b672      	cpsid	i
 80046ac:	f7ff fc60 	bl	8003f70 <vTaskSwitchContext>
 80046b0:	b662      	cpsie	i
 80046b2:	bc0c      	pop	{r2, r3}
 80046b4:	6811      	ldr	r1, [r2, #0]
 80046b6:	6808      	ldr	r0, [r1, #0]
 80046b8:	3010      	adds	r0, #16
 80046ba:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80046bc:	46a0      	mov	r8, r4
 80046be:	46a9      	mov	r9, r5
 80046c0:	46b2      	mov	sl, r6
 80046c2:	46bb      	mov	fp, r7
 80046c4:	f380 8809 	msr	PSP, r0
 80046c8:	3820      	subs	r0, #32
 80046ca:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80046cc:	4718      	bx	r3
 80046ce:	46c0      	nop			@ (mov r8, r8)

080046d0 <pxCurrentTCBConst>:
 80046d0:	20000bd4 	.word	0x20000bd4

080046d4 <xPortSysTickHandler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80046d4:	b510      	push	{r4, lr}
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 80046d6:	f7ff ffcd 	bl	8004674 <ulSetInterruptMaskFromISR>
 80046da:	0004      	movs	r4, r0
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
 80046dc:	f7ff fafc 	bl	8003cd8 <xTaskIncrementTick>
 80046e0:	2800      	cmp	r0, #0
 80046e2:	d003      	beq.n	80046ec <xPortSysTickHandler+0x18>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80046e4:	2280      	movs	r2, #128	@ 0x80
 80046e6:	4b03      	ldr	r3, [pc, #12]	@ (80046f4 <xPortSysTickHandler+0x20>)
 80046e8:	0552      	lsls	r2, r2, #21
 80046ea:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 80046ec:	0020      	movs	r0, r4
 80046ee:	f7ff ffc5 	bl	800467c <vClearInterruptMaskFromISR>
}
 80046f2:	bd10      	pop	{r4, pc}
 80046f4:	e000ed04 	.word	0xe000ed04

080046f8 <vPortSetupTimerInterrupt>:
        ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
    }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 80046f8:	2300      	movs	r3, #0
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80046fa:	21fa      	movs	r1, #250	@ 0xfa
{
 80046fc:	b510      	push	{r4, lr}
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80046fe:	4a07      	ldr	r2, [pc, #28]	@ (800471c <vPortSetupTimerInterrupt+0x24>)
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004700:	4c07      	ldr	r4, [pc, #28]	@ (8004720 <vPortSetupTimerInterrupt+0x28>)
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004702:	0089      	lsls	r1, r1, #2
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004704:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8004706:	6013      	str	r3, [r2, #0]
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004708:	4b06      	ldr	r3, [pc, #24]	@ (8004724 <vPortSetupTimerInterrupt+0x2c>)
 800470a:	6818      	ldr	r0, [r3, #0]
 800470c:	f7fb fd0e 	bl	800012c <__udivsi3>
 8004710:	4b05      	ldr	r3, [pc, #20]	@ (8004728 <vPortSetupTimerInterrupt+0x30>)
 8004712:	3801      	subs	r0, #1
 8004714:	6018      	str	r0, [r3, #0]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004716:	2307      	movs	r3, #7
 8004718:	6023      	str	r3, [r4, #0]
}
 800471a:	bd10      	pop	{r4, pc}
 800471c:	e000e018 	.word	0xe000e018
 8004720:	e000e010 	.word	0xe000e010
 8004724:	20000000 	.word	0x20000000
 8004728:	e000e014 	.word	0xe000e014

0800472c <xPortStartScheduler>:
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 800472c:	22ff      	movs	r2, #255	@ 0xff
 800472e:	4b0c      	ldr	r3, [pc, #48]	@ (8004760 <xPortStartScheduler+0x34>)
 8004730:	0412      	lsls	r2, r2, #16
 8004732:	6819      	ldr	r1, [r3, #0]
{
 8004734:	b510      	push	{r4, lr}
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8004736:	430a      	orrs	r2, r1
 8004738:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 800473a:	22ff      	movs	r2, #255	@ 0xff
    uxCriticalNesting = 0;
 800473c:	2400      	movs	r4, #0
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 800473e:	6819      	ldr	r1, [r3, #0]
 8004740:	0612      	lsls	r2, r2, #24
 8004742:	430a      	orrs	r2, r1
 8004744:	601a      	str	r2, [r3, #0]
    vPortSetupTimerInterrupt();
 8004746:	f7ff ffd7 	bl	80046f8 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 800474a:	4b06      	ldr	r3, [pc, #24]	@ (8004764 <xPortStartScheduler+0x38>)
 800474c:	601c      	str	r4, [r3, #0]
    vPortStartFirstTask();
 800474e:	f7ff ff3f 	bl	80045d0 <vPortStartFirstTask>
    vTaskSwitchContext();
 8004752:	f7ff fc0d 	bl	8003f70 <vTaskSwitchContext>
    prvTaskExitError();
 8004756:	f7ff ff27 	bl	80045a8 <prvTaskExitError>
}
 800475a:	0020      	movs	r0, r4
 800475c:	bd10      	pop	{r4, pc}
 800475e:	46c0      	nop			@ (mov r8, r8)
 8004760:	e000ed20 	.word	0xe000ed20
 8004764:	2000000c 	.word	0x2000000c

08004768 <pvPortMalloc>:
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8004768:	2307      	movs	r3, #7
{
 800476a:	b570      	push	{r4, r5, r6, lr}
 800476c:	0004      	movs	r4, r0
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 800476e:	4218      	tst	r0, r3
 8004770:	d006      	beq.n	8004780 <pvPortMalloc+0x18>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 8004772:	0002      	movs	r2, r0
 8004774:	439a      	bics	r2, r3
 8004776:	0013      	movs	r3, r2
 8004778:	3308      	adds	r3, #8
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
            }
            else
            {
                xWantedSize = 0;
 800477a:	4298      	cmp	r0, r3
 800477c:	41a4      	sbcs	r4, r4
 800477e:	401c      	ands	r4, r3
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 8004780:	f7ff fa90 	bl	8003ca4 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 8004784:	4a0c      	ldr	r2, [pc, #48]	@ (80047b8 <pvPortMalloc+0x50>)
 8004786:	6813      	ldr	r3, [r2, #0]
 8004788:	2b00      	cmp	r3, #0
 800478a:	d103      	bne.n	8004794 <pvPortMalloc+0x2c>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 800478c:	2107      	movs	r1, #7
 800478e:	4b0b      	ldr	r3, [pc, #44]	@ (80047bc <pvPortMalloc+0x54>)
 8004790:	438b      	bics	r3, r1
 8004792:	6013      	str	r3, [r2, #0]
    void * pvReturn = NULL;
 8004794:	1e25      	subs	r5, r4, #0
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 8004796:	d00b      	beq.n	80047b0 <pvPortMalloc+0x48>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8004798:	4909      	ldr	r1, [pc, #36]	@ (80047c0 <pvPortMalloc+0x58>)
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 800479a:	480a      	ldr	r0, [pc, #40]	@ (80047c4 <pvPortMalloc+0x5c>)
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 800479c:	680b      	ldr	r3, [r1, #0]
    void * pvReturn = NULL;
 800479e:	2500      	movs	r5, #0
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 80047a0:	191c      	adds	r4, r3, r4
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 80047a2:	4284      	cmp	r4, r0
 80047a4:	d804      	bhi.n	80047b0 <pvPortMalloc+0x48>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 80047a6:	42a3      	cmp	r3, r4
 80047a8:	d202      	bcs.n	80047b0 <pvPortMalloc+0x48>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 80047aa:	6815      	ldr	r5, [r2, #0]
            xNextFreeByte += xWantedSize;
 80047ac:	600c      	str	r4, [r1, #0]
            pvReturn = pucAlignedHeap + xNextFreeByte;
 80047ae:	18ed      	adds	r5, r5, r3
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 80047b0:	f7ff fb3e 	bl	8003e30 <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
 80047b4:	0028      	movs	r0, r5
 80047b6:	bd70      	pop	{r4, r5, r6, pc}
 80047b8:	20000d04 	.word	0x20000d04
 80047bc:	20000d13 	.word	0x20000d13
 80047c0:	20000d08 	.word	0x20000d08
 80047c4:	00000ff7 	.word	0x00000ff7

080047c8 <vPortFree>:
     * heap_4.c for alternative implementations, and the memory management pages of
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
 80047c8:	2800      	cmp	r0, #0
 80047ca:	d001      	beq.n	80047d0 <vPortFree+0x8>
 80047cc:	b672      	cpsid	i
 80047ce:	e7fe      	b.n	80047ce <vPortFree+0x6>
}
 80047d0:	4770      	bx	lr

080047d2 <__itoa>:
 80047d2:	1e93      	subs	r3, r2, #2
 80047d4:	b510      	push	{r4, lr}
 80047d6:	000c      	movs	r4, r1
 80047d8:	2b22      	cmp	r3, #34	@ 0x22
 80047da:	d904      	bls.n	80047e6 <__itoa+0x14>
 80047dc:	2300      	movs	r3, #0
 80047de:	001c      	movs	r4, r3
 80047e0:	700b      	strb	r3, [r1, #0]
 80047e2:	0020      	movs	r0, r4
 80047e4:	bd10      	pop	{r4, pc}
 80047e6:	2a0a      	cmp	r2, #10
 80047e8:	d109      	bne.n	80047fe <__itoa+0x2c>
 80047ea:	2800      	cmp	r0, #0
 80047ec:	da07      	bge.n	80047fe <__itoa+0x2c>
 80047ee:	232d      	movs	r3, #45	@ 0x2d
 80047f0:	700b      	strb	r3, [r1, #0]
 80047f2:	2101      	movs	r1, #1
 80047f4:	4240      	negs	r0, r0
 80047f6:	1861      	adds	r1, r4, r1
 80047f8:	f000 f808 	bl	800480c <__utoa>
 80047fc:	e7f1      	b.n	80047e2 <__itoa+0x10>
 80047fe:	2100      	movs	r1, #0
 8004800:	e7f9      	b.n	80047f6 <__itoa+0x24>

08004802 <itoa>:
 8004802:	b510      	push	{r4, lr}
 8004804:	f7ff ffe5 	bl	80047d2 <__itoa>
 8004808:	bd10      	pop	{r4, pc}
	...

0800480c <__utoa>:
 800480c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800480e:	000c      	movs	r4, r1
 8004810:	0016      	movs	r6, r2
 8004812:	b08d      	sub	sp, #52	@ 0x34
 8004814:	2225      	movs	r2, #37	@ 0x25
 8004816:	0007      	movs	r7, r0
 8004818:	4915      	ldr	r1, [pc, #84]	@ (8004870 <__utoa+0x64>)
 800481a:	a802      	add	r0, sp, #8
 800481c:	f000 f86c 	bl	80048f8 <memcpy>
 8004820:	1e62      	subs	r2, r4, #1
 8004822:	1eb3      	subs	r3, r6, #2
 8004824:	2500      	movs	r5, #0
 8004826:	9201      	str	r2, [sp, #4]
 8004828:	2b22      	cmp	r3, #34	@ 0x22
 800482a:	d904      	bls.n	8004836 <__utoa+0x2a>
 800482c:	7025      	strb	r5, [r4, #0]
 800482e:	002c      	movs	r4, r5
 8004830:	0020      	movs	r0, r4
 8004832:	b00d      	add	sp, #52	@ 0x34
 8004834:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004836:	0038      	movs	r0, r7
 8004838:	0031      	movs	r1, r6
 800483a:	f7fb fcfd 	bl	8000238 <__aeabi_uidivmod>
 800483e:	000b      	movs	r3, r1
 8004840:	aa02      	add	r2, sp, #8
 8004842:	5cd3      	ldrb	r3, [r2, r3]
 8004844:	9a01      	ldr	r2, [sp, #4]
 8004846:	0029      	movs	r1, r5
 8004848:	3501      	adds	r5, #1
 800484a:	5553      	strb	r3, [r2, r5]
 800484c:	003b      	movs	r3, r7
 800484e:	0007      	movs	r7, r0
 8004850:	429e      	cmp	r6, r3
 8004852:	d9f0      	bls.n	8004836 <__utoa+0x2a>
 8004854:	2300      	movs	r3, #0
 8004856:	0022      	movs	r2, r4
 8004858:	5563      	strb	r3, [r4, r5]
 800485a:	000b      	movs	r3, r1
 800485c:	1ac8      	subs	r0, r1, r3
 800485e:	4283      	cmp	r3, r0
 8004860:	dde6      	ble.n	8004830 <__utoa+0x24>
 8004862:	7810      	ldrb	r0, [r2, #0]
 8004864:	5ce5      	ldrb	r5, [r4, r3]
 8004866:	7015      	strb	r5, [r2, #0]
 8004868:	54e0      	strb	r0, [r4, r3]
 800486a:	3201      	adds	r2, #1
 800486c:	3b01      	subs	r3, #1
 800486e:	e7f5      	b.n	800485c <__utoa+0x50>
 8004870:	0800495e 	.word	0x0800495e

08004874 <memset>:
 8004874:	0003      	movs	r3, r0
 8004876:	1882      	adds	r2, r0, r2
 8004878:	4293      	cmp	r3, r2
 800487a:	d100      	bne.n	800487e <memset+0xa>
 800487c:	4770      	bx	lr
 800487e:	7019      	strb	r1, [r3, #0]
 8004880:	3301      	adds	r3, #1
 8004882:	e7f9      	b.n	8004878 <memset+0x4>

08004884 <strcat>:
 8004884:	0002      	movs	r2, r0
 8004886:	b510      	push	{r4, lr}
 8004888:	7813      	ldrb	r3, [r2, #0]
 800488a:	0014      	movs	r4, r2
 800488c:	3201      	adds	r2, #1
 800488e:	2b00      	cmp	r3, #0
 8004890:	d1fa      	bne.n	8004888 <strcat+0x4>
 8004892:	5cca      	ldrb	r2, [r1, r3]
 8004894:	54e2      	strb	r2, [r4, r3]
 8004896:	3301      	adds	r3, #1
 8004898:	2a00      	cmp	r2, #0
 800489a:	d1fa      	bne.n	8004892 <strcat+0xe>
 800489c:	bd10      	pop	{r4, pc}
	...

080048a0 <__libc_init_array>:
 80048a0:	b570      	push	{r4, r5, r6, lr}
 80048a2:	2600      	movs	r6, #0
 80048a4:	4c0c      	ldr	r4, [pc, #48]	@ (80048d8 <__libc_init_array+0x38>)
 80048a6:	4d0d      	ldr	r5, [pc, #52]	@ (80048dc <__libc_init_array+0x3c>)
 80048a8:	1b64      	subs	r4, r4, r5
 80048aa:	10a4      	asrs	r4, r4, #2
 80048ac:	42a6      	cmp	r6, r4
 80048ae:	d109      	bne.n	80048c4 <__libc_init_array+0x24>
 80048b0:	2600      	movs	r6, #0
 80048b2:	f000 f82b 	bl	800490c <_init>
 80048b6:	4c0a      	ldr	r4, [pc, #40]	@ (80048e0 <__libc_init_array+0x40>)
 80048b8:	4d0a      	ldr	r5, [pc, #40]	@ (80048e4 <__libc_init_array+0x44>)
 80048ba:	1b64      	subs	r4, r4, r5
 80048bc:	10a4      	asrs	r4, r4, #2
 80048be:	42a6      	cmp	r6, r4
 80048c0:	d105      	bne.n	80048ce <__libc_init_array+0x2e>
 80048c2:	bd70      	pop	{r4, r5, r6, pc}
 80048c4:	00b3      	lsls	r3, r6, #2
 80048c6:	58eb      	ldr	r3, [r5, r3]
 80048c8:	4798      	blx	r3
 80048ca:	3601      	adds	r6, #1
 80048cc:	e7ee      	b.n	80048ac <__libc_init_array+0xc>
 80048ce:	00b3      	lsls	r3, r6, #2
 80048d0:	58eb      	ldr	r3, [r5, r3]
 80048d2:	4798      	blx	r3
 80048d4:	3601      	adds	r6, #1
 80048d6:	e7f2      	b.n	80048be <__libc_init_array+0x1e>
 80048d8:	08004a34 	.word	0x08004a34
 80048dc:	08004a34 	.word	0x08004a34
 80048e0:	08004a38 	.word	0x08004a38
 80048e4:	08004a34 	.word	0x08004a34

080048e8 <strcpy>:
 80048e8:	0003      	movs	r3, r0
 80048ea:	780a      	ldrb	r2, [r1, #0]
 80048ec:	3101      	adds	r1, #1
 80048ee:	701a      	strb	r2, [r3, #0]
 80048f0:	3301      	adds	r3, #1
 80048f2:	2a00      	cmp	r2, #0
 80048f4:	d1f9      	bne.n	80048ea <strcpy+0x2>
 80048f6:	4770      	bx	lr

080048f8 <memcpy>:
 80048f8:	2300      	movs	r3, #0
 80048fa:	b510      	push	{r4, lr}
 80048fc:	429a      	cmp	r2, r3
 80048fe:	d100      	bne.n	8004902 <memcpy+0xa>
 8004900:	bd10      	pop	{r4, pc}
 8004902:	5ccc      	ldrb	r4, [r1, r3]
 8004904:	54c4      	strb	r4, [r0, r3]
 8004906:	3301      	adds	r3, #1
 8004908:	e7f8      	b.n	80048fc <memcpy+0x4>
	...

0800490c <_init>:
 800490c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800490e:	46c0      	nop			@ (mov r8, r8)
 8004910:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004912:	bc08      	pop	{r3}
 8004914:	469e      	mov	lr, r3
 8004916:	4770      	bx	lr

08004918 <_fini>:
 8004918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800491a:	46c0      	nop			@ (mov r8, r8)
 800491c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800491e:	bc08      	pop	{r3}
 8004920:	469e      	mov	lr, r3
 8004922:	4770      	bx	lr
